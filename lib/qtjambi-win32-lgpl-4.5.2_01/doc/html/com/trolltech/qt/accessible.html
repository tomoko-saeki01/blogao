<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Accessibility</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Accessibility</h1></center><p> <ul><li> <a href="#introduction">Introduction</a></li><li> <a href="#architecture">Architecture</a></li> <ul><li> <a href="#accessibility-in-qt">Accessibility in Qt</a></li><li> <a href="#the-accessible-object-tree">The Accessible Object Tree</a></li><li> <a href="#the-static-qaccessible-functions">The Static QAccessible Functions</a></li></ul><li> <a href="#implementing-accessibility">Implementing Accessibility</a></li> <ul><li> <a href="#the-qaccessibleobject-and-qaccessiblewidget-convenience-classes">The QAccessibleObject and QAccessibleWidget Convenience Classes</a></li><li> <a href="#qaccessiblewidget-example">QAccessibleWidget Example</a></li><li> <a href="#handling-action-requests-from-clients">Handling Action Requests from Clients</a></li><li> <a href="#implementing-accessible-plugins">Implementing Accessible Plugins</a></li><li> <a href="#implementing-interface-factories">Implementing Interface Factories</a></li></ul><li> <a href="#further-reading">Further Reading</a></li></ul><a name="introduction"><h2>Introduction</h2> Accessibility in computer software is making applications usable for people with disabilities. This could be achieved by providing keyboard shortcuts, a high-contrast user interface that uses specially selected colors and fonts, or support for assistive tools such as screen readers and braille displays. <p>An application does not usually communicate directly with assistive tools but through an assistive technology, which is a bridge for exchange of information between the applications and the tools. Information about user interface elements, such as buttons and scroll bars, is exposed to the assistive technologies. Qt supports Microsoft Active Accessibility (MSAA) on Windows and Mac OS X Accessibility on Mac OS X. On Unix/X11, support is preliminary. The individual technologies are abstracted from Qt, and there is only a single interface to consider. We will use MSAA throughout this document when we need to address technology related issues. <p>In this overview document, we will examine the overall Qt accessibility architecture, and how to implement accessibility for custom widgets and elements.<a name="architecture"><h2>Architecture</h2> Providing accessibility is a collaboration between accessibility compliant applications, the assistive technology, and the assistive tools. <br><center><img src="images/accessibilityarchitecture.png"></center><br> Accessibility compliant applications are called AT-Servers while assistive tools are called AT-Clients. A Qt application will typically be an AT-Server, but specialized programs might also function like AT-Clients. We will refer to clients and servers when talking about AT-Clients and AT-Servers in the rest of this document. <p>We will from now on focus on the Qt accessibility interface and how it is implemented to create Qt applications that support accessibility.<a name="accessibility-in-qt"><h3>Accessibility in Qt</h3> When we communicate with the assistive technologies, we need to describe Qt's user interface in a way that they can understand. Qt applications use <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> to expose information about the individual UI elements. Currently, Qt provides support for its widgets and widget parts, e.g., slider handles, but the interface could also be implemented for any <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> if necessary. <a href="../../../com/trolltech/qt/gui/QAccessible.html">QAccessible</a> contains enums that describe the UI. The description is mainly based on MSAA and is independent of Qt. We will examine the enums in the course of this document. <p>The structure of the UI is represented as a tree of <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> subclasses. You can think of this as a representation of a UI like the <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> tree built by Qt. Objects can be widgets or widget parts (such as scroll bar handles). We examine the tree in detail in the next section. <p>Servers notify clients through <a href="../../../com/trolltech/qt/gui/QAccessible.html#updateAccessibility(com.trolltech.qt.core.QObject, int, com.trolltech.qt.gui.QAccessible.Event)">updateAccessibility()</a> about changes in objects by sending events, and the clients register to receive the events. The available events are defined by the <a href="../../../com/trolltech/qt/gui/QAccessible.Event.html">QAccessible::Event</a> enum. The clients may then query for the object that generated the event through <a href="../../../com/trolltech/qt/gui/QAccessible.html#queryAccessibleInterface(com.trolltech.qt.core.QObject)">QAccessible::queryAccessibleInterface()</a>. <p>Three of the enums in <a href="../../../com/trolltech/qt/gui/QAccessible.html">QAccessible</a> help clients query and alter accessible objects: <ul><li> <a href="../../../com/trolltech/qt/gui/QAccessible.Role.html">Role</a>: Describes the role the object fills in the user interface, e.g., if it is a main window, a text caret, or a cell in an item view.</li><li> <a href="../../../com/trolltech/qt/gui/QAccessible.Action.html">Action</a>: The actions that the clients can perform on the objects, e.g., pushing a button.</li><li> Relation: Describes the relationship between objects in the object tree. This is used for navigation.</li></ul> The clients also have some possibilities to get the content of objects, e.g., a button's text; the object provides strings defined by the <a href="../../../com/trolltech/qt/gui/QAccessible.Text.html">QAccessible::Text</a> enum, that give information about content. <p>The objects can be in a number of different states as defined by the State enum. Examples of states are whether the object is disabled, if it has focus, or if it provides a pop-up menu.<a name="the-accessible-object-tree"><h3>The Accessible Object Tree</h3> As mentioned, a tree structure is built from the accessible objects of an application. By navigating through the tree, the clients can access all elements in the UI. Object relations give clients information about the UI. For instance, a slider handle is a child of the slider to which it belongs. QAccessible::Relation describes the various relationships the clients can ask objects for. <p>Note that there are no direct mapping between the Qt <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> tree and the accessible object tree. For instance, scroll bar handles are accessible objects but are not widgets or objects in Qt. <p>AT-Clients have access to the accessibility object tree through the root object in the tree, which is the <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a>. They can query other objects through QAccessible::navigate(), which fetches objects based on Relations. The children of any node is 1-based numbered. The child numbered 0 is the object itself. The children of all interfaces are numbered this way, i.e., it is not a fixed numbering from the root node in the entire tree. <p>Qt provides accessible interfaces for its widgets. Interfaces for any <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass can be requested through QAccessible::queryInterface(). A default implementation is provided if a more specialized interface is not defined. An AT-Client cannot acquire an interface for accessible objects that do not have an equivalent <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>, e.g., scroll bar handles, but they appear as normal objects through interfaces of parent accessible objects, e.g., you can query their relationships with QAccessible::relationTo(). <p>To illustrate, we present an image of an accessible object tree. Beneath the tree is a table with examples of object relationships. <br><center><img src="images/accessibleobjecttree.png"></center><br> The labels in top-down order are: the <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> class name, the widget for which an interface is provided, and the <a href="../../../com/trolltech/qt/gui/QAccessible.Role.html">Role</a> of the object. The Position, PageLeft and PageRight correspond to the slider handle, the slider groove left and the slider groove right, respectively. These accessible objects do not have an equivalent <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. <table align="center" border="0" cellpadding="2" cellspacing="1" width="40%"><thead><tr class="qt-style" valign="top"><th><center> Source Object</center></th><th><center> Target Object</center></th><th><center> Relation</center></th></tr></thead><tr valign="top" class="even"><td> Slider</td><td> Indicator</td><td> Controller</td></tr><tr valign="top" class="odd"><td> Indicator</td><td> Slider</td><td> Controlled</td></tr><tr valign="top" class="even"><td> Slider</td><td> Application</td><td> Ancestor</td></tr><tr valign="top" class="odd"><td> Application</td><td> Slider</td><td> Child</td></tr><tr valign="top" class="even"><td> PushButton</td><td> Indicator</td><td> Sibling</td></tr></table><a name="the-static-qaccessible-functions"><h3>The Static QAccessible Functions</h3> The accessibility is managed by <a href="../../../com/trolltech/qt/gui/QAccessible.html">QAccessible</a>'s static functions, which we will examine shortly. They produce <a href="../../../com/trolltech/qt/gui/QAccessible.html">QAccessible</a> interfaces, build the object tree, and initiate the connection with MSAA or the other platform specific technologies. If you are only interested in learning how to make your application accessible, you can safely skip over this section to <a href="accessible.html#implementing-accessibility">Implementing Accessibility</a>. <p>The communication between clients and the server is initiated when <a href="../../../com/trolltech/qt/gui/QAccessible.html#setRootObject(com.trolltech.qt.core.QObject)">setRootObject()</a> is called. This is done when the <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> instance is instantiated and you should not have to do this yourself. <p>When a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> calls <a href="../../../com/trolltech/qt/gui/QAccessible.html#updateAccessibility(com.trolltech.qt.core.QObject, int, com.trolltech.qt.gui.QAccessible.Event)">updateAccessibility()</a>, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible <a href="../../../com/trolltech/qt/gui/QAccessible.Event.html">events</a> are posted by <a href="../../../com/trolltech/qt/gui/QAccessible.html#updateAccessibility(com.trolltech.qt.core.QObject, int, com.trolltech.qt.gui.QAccessible.Event)">updateAccessibility()</a>. <p><a href="../../../com/trolltech/qt/gui/QAccessible.html#queryAccessibleInterface(com.trolltech.qt.core.QObject)">queryAccessibleInterface()</a> returns accessible interfaces for <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s. All widgets in Qt provide interfaces; if you need interfaces to control the behavior of other <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclasses, you must implement the interfaces yourself, although the <a href="../../../com/trolltech/qt/gui/QAccessibleObject.html">QAccessibleObject</a> convenience class implements parts of the functionality for you. <p>The factory that produces accessibility interfaces for QObjects is a function of type QAccessible::InterfaceFactory. It is possible to have several factories installed. The last factory installed will be the first to be asked for interfaces. <a href="../../../com/trolltech/qt/gui/QAccessible.html#queryAccessibleInterface(com.trolltech.qt.core.QObject)">queryAccessibleInterface()</a> uses the factories to create interfaces for <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s. Normally, you need not be concerned about factories because you can implement plugins that produce interfaces. We will give examples of both approaches later.<a name="implementing-accessibility"><h2>Implementing Accessibility</h2> To provide accessibility support for a widget or other user interface element, you need to implement the <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> and distribute it in a <a href="../../../com/trolltech/qt/gui/QAccessiblePlugin.html">QAccessiblePlugin</a>. It is also possible to compile the interface into the application and provide a QAccessible::InterfaceFactory for it. The factory can be used if you link statically or do not want the added complexity of plugins. This can be an advantage if you, for instance, are delivering a 3-rd party library. <p>All widgets and other user interface elements should have interfaces and plugins. If you want your application to support accessibility, you will need to consider the following: <ul><li> Qt already implements accessibility for its own widgets. We therefore recommend that you use Qt widgets where possible.</li><li> A <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> needs to be implemented for each element that you want to make available to accessibility clients.</li><li> You need to send accessibility events from the custom user interface elements that you implement.</li></ul> In general, it is recommended that you are somewhat familiar with MSAA, which Qt originally was built for. You should also study the enum values of <a href="../../../com/trolltech/qt/gui/QAccessible.html">QAccessible</a>, which describe the roles, actions, relationships, and events that you need to consider. <p>Note that you can examine how Qt's widgets implement their accessibility. One major problem with the MSAA standard is that interfaces are often implemented in an inconsistent way. This makes life difficult for clients and often leads to guesswork on object functionality. <p>It is possible to implement interfaces by inheriting <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> and implementing its pure virtual functions. In practice, however, it is usually preferable to inherit <a href="../../../com/trolltech/qt/gui/QAccessibleObject.html">QAccessibleObject</a> or <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a>, which implement part of the functionality for you. In the next section, we will see an example of implementing accessibility for a widget by inheriting the <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a> class.<a name="the-qaccessibleobject-and-qaccessiblewidget-convenience-classes"><h3>The QAccessibleObject and QAccessibleWidget Convenience Classes</h3> When implementing an accessibility interface for widgets, one would as a rule inherit <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a>, which is a convenience class for widgets. Another available convenience class, which is inherited by <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a>, is the <a href="../../../com/trolltech/qt/gui/QAccessibleObject.html">QAccessibleObject</a>, which implements part of the interface for QObjects. <p>The <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a> provides the following functionality: <ul><li> It handles the navigation of the tree and hit testing of the objects.</li><li> It handles events, roles, and actions that are common for all <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>s.</li><li> It handles action and methods that can be performed on all widgets.</li><li> It calculates bounding rectangles with <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#rect(int)">rect()</a>.</li><li> It gives <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#text(com.trolltech.qt.gui.QAccessible.Text, int)">text()</a> strings that are appropriate for a generic widget.</li><li> It sets the states that are common for all widgets.</li></ul><a name="qaccessiblewidget-example"><h3>QAccessibleWidget Example</h3> Instead of creating a custom widget and implementing an interface for it, we will show how accessibility can be implemented for one of Qt's standard widgets: <a href="../../../com/trolltech/qt/gui/QSlider.html">QSlider</a>. Making this widget accessible demonstrates many of the issues that need to be faced when making a custom widget accessible. <p>The slider is a complex control that functions as a <a href="../../../com/trolltech/qt/gui/QAccessible.RelationFlag.html">Controller</a> for its accessible children. This relationship must be known by the interface (for <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#relationTo(int, com.trolltech.qt.gui.QAccessibleInterface, int)">relationTo()</a> and <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#navigate(com.trolltech.qt.gui.QAccessible.RelationFlag, int)">navigate()</a>). This can be done using a controlling signal, which is a mechanism provided by <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a>. We do this in the constructor:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QAccessibleSlider::QAccessibleSlider(QWidget *w)
: QAccessibleAbstractSlider(w)
{
    Q_ASSERT(slider());
    addControllingSignal(QLatin1String("valueChanged(int)"));
}
</pre> The choice of signal shown is not important; the same principles apply to all signals that are declared in this way. Note that we use QLatin1String to ensure that the signal name is correctly specified. <p>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how <a href="../../../com/trolltech/qt/gui/QSlider.html">QSlider</a> calls <a href="../../../com/trolltech/qt/gui/QAccessible.html#updateAccessibility(com.trolltech.qt.core.QObject, int, com.trolltech.qt.gui.QAccessible.Event)">updateAccessibility()</a> to indicate that its value has changed: <pre class="snippet">
void setValue(int value)
...
    QAccessible.updateAccessibility(this, 0, QAccessible.Event.ValueChanged);
...
}
</pre> Note that the call is made after the value of the slider has changed because clients may query the new value immediately after receiving the event. <p>The interface must be able to calculate bounding rectangles of itself and any children that do not provide an interface of their own. The <tt>QAccessibleSlider</tt> has three such children identified by the private enum, <tt>SliderElements</tt>, which has the following values: <tt>PageLeft</tt> (the rectangle on the left hand side of the slider handle), <tt>PageRight</tt> (the rectangle on the right hand side of the handle), and <tt>Position</tt> (the slider handle). Here is the implementation of <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#rect(int)">rect()</a>:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QRect QAccessibleSlider::rect(int child) const
{
...
    switch (child) {
    case PageLeft:
        if (slider()-&gt;orientation() == Qt::Vertical)
            rect = QRect(0, 0, slider()-&gt;width(), srect.y());
        else
            rect = QRect(0, 0, srect.x(), slider()-&gt;height());
        break;
    case Position:
        rect = srect;
        break;
    case PageRight:
        if (slider()-&gt;orientation() == Qt::Vertical)
            rect = QRect(0, srect.y() + srect.height(), slider()-&gt;width(), slider()-&gt;height()- srect.y() - srect.height());
        else
            rect = QRect(srect.x() + srect.width(), 0, slider()-&gt;width() - srect.x() - srect.width(), slider()-&gt;height());
        break;
    default:
        return QAccessibleAbstractSlider::rect(child);
    }
...</pre> The first part of the function, which we have omitted, uses the current <a href="../../../com/trolltech/qt/gui/QStyle.html">style</a> to calculate the slider handle's bounding rectangle; it is stored in <tt>srect</tt>. Notice that child 0, covered in the default case in the above code, is the slider itself, so we can simply return the <a href="../../../com/trolltech/qt/gui/QSlider.html">QSlider</a> bounding rectangle obtained from the superclass, which is effectively the value obtained from <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#rect(int)">QAccessibleWidget::rect()</a>.<br><br>The following code example is written in c++.<br> <pre class="snippet">

    QPoint tp = slider()-&gt;mapToGlobal(QPoint(0,0));
    return QRect(tp.x() + rect.x(), tp.y() + rect.y(), rect.width(), rect.height());
}
</pre> Before the rectangle is returned it must be mapped to screen coordinates. <p>The QAccessibleSlider must reimplement <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#childCount()">QAccessibleInterface::childCount()</a> since it manages children without interfaces. <p>The <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#text(com.trolltech.qt.gui.QAccessible.Text, int)">text()</a> function returns the <a href="../../../com/trolltech/qt/gui/QAccessible.Text.html">QAccessible::Text</a> strings for the slider:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QString QAccessibleSlider::text(Text t, int child) const
{
    if (!slider()-&gt;isVisible())
        return QString();
    switch (t) {
    case Value:
        if (!child || child == 2)
            return QString::number(slider()-&gt;value());
        return QString();
    case Name:
        switch (child) {
        case PageLeft:
            return slider()-&gt;orientation() == Qt::Horizontal ?
                QSlider::tr("Page left") : QSlider::tr("Page up");
        case Position:
            return QSlider::tr("Position");
        case PageRight:
            return slider()-&gt;orientation() == Qt::Horizontal ?
                QSlider::tr("Page right") : QSlider::tr("Page down");
        }
        break;
    default:
        break;
    }
    return QAccessibleAbstractSlider::text(t, child);
}
</pre> The <tt>slider()</tt> function returns a pointer to the interface's <a href="../../../com/trolltech/qt/gui/QSlider.html">QSlider</a>. Some values are left for the superclass's implementation. Not all values are appropriate for all accessible objects, as you can see for <a href="../../../com/trolltech/qt/gui/QAccessible.Text.html">QAccessible::Value</a> case. You should just return an empty string for those values where no relevant text can be provided. <p>The implementation of the <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#role(int)">role()</a> function is straightforward:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QAccessible::Role QAccessibleSlider::role(int child) const
{
    switch (child) {
    case PageLeft:
    case PageRight:
        return PushButton;
    case Position:
        return Indicator;
    default:
        return Slider;
    }
}
</pre> The role function should be reimplemented by all objects and describes the role of themselves and the children that do not provide accessible interfaces of their own. <p>Next, the accessible interface needs to return the states that the slider can be in. We look at parts of the <tt>state()</tt> implementation to show how just a few of the states are handled:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QAccessible::State QAccessibleSlider::state(int child) const
{
    const State parentState = QAccessibleAbstractSlider::state(0);
...
    switch (child) {
    case PageLeft:
        if (slider-&gt;value() &lt;= slider-&gt;minimum())
            state |= Unavailable;
        break;
    case PageRight:
        if (slider-&gt;value() &gt;= slider-&gt;maximum())
            state |= Unavailable;
        break;
    case Position:
    default:
        break;
    }

    return state;
}
</pre> The superclass implementation of <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#state(int)">state()</a>, uses the <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#state(int)">QAccessibleInterface::state()</a> implementation. We simply need to disable the buttons if the slider is at its minimum or maximum. <p>We have now exposed the information we have about the slider to the clients. For the clients to be able to alter the slider - for example, to change its value - we must provide information about the actions that can be performed and perform them upon request. We discuss this in the next section.<a name="handling-action-requests-from-clients"><h3>Handling Action Requests from Clients</h3> <a href="../../../com/trolltech/qt/gui/QAccessible.html">QAccessible</a> provides a number of <a href="../../../com/trolltech/qt/gui/QAccessible.Action.html">Action</a>s that can be performed on request from clients. If an accessible object supports actions, it should reimplement the following functions from <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a>: <ul><li> <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#actionText(int, com.trolltech.qt.gui.QAccessible.Text, int)">actionText()</a> returns strings that describe each action. The descriptions to be made available are one for each <a href="../../../com/trolltech/qt/gui/QAccessible.Text.html">Text</a> enum value.</li><li> <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#doAction(int, int, java.util.List<java.lang.Object>)">doAction()</a> executes requests from clients to perform actions.</li></ul> Note that a client can request any action from an object. If the object does not support the action, it returns false from <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#doAction(int, int, java.util.List<java.lang.Object>)">doAction()</a>. <p>None of the standard actions take any parameters. It is possible to provide user-defined actions that can take parameters. The interface must then also reimplement <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#userActionCount(int)">userActionCount()</a>. Since this is not defined in the MSAA specification, it is probably only useful to use this if you know which specific AT-Clients will use the application. <p><a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> gives another technique for clients to handle accessible objects. It works basically the same way, but uses the concept of methods in place of actions. The available methods are defined by the <a href="../../../com/trolltech/qt/gui/QAccessible.Method.html">QAccessible::Method</a> enum. The following functions need to be reimplemented from <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html">QAccessibleInterface</a> if the accessible object is to support methods: <ul><li> <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#supportedMethods()">supportedMethods()</a> returns a QSet of <a href="../../../com/trolltech/qt/gui/QAccessible.Method.html">Method</a> values that are supported by the object.</li><li> <a href="../../../com/trolltech/qt/gui/QAccessibleInterface.html#invokeMethod(com.trolltech.qt.gui.QAccessible.Method, int, java.util.List<java.lang.Object>)">invokeMethod()</a> executes methods requested by clients.</li></ul> The action mechanism will probably be substituted by providing methods in place of the standard actions. <p>To see examples on how to implement actions and methods, you could examine the <a href="../../../com/trolltech/qt/gui/QAccessibleObject.html">QAccessibleObject</a> and <a href="../../../com/trolltech/qt/gui/QAccessibleWidget.html">QAccessibleWidget</a> implementations. You might also want to take a look at the MSAA documentation.<a name="implementing-accessible-plugins"><h3>Implementing Accessible Plugins</h3> In this section we will explain the procedure of implementing accessible plugins for your interfaces. A plugin is a class stored in a shared library that can be loaded at run-time. It is convenient to distribute interfaces as plugins since they will only be loaded when required. <p>Creating an accessible plugin is achieved by inheriting <a href="../../../com/trolltech/qt/gui/QAccessiblePlugin.html">QAccessiblePlugin</a>, reimplementing <a href="../../../com/trolltech/qt/gui/QAccessiblePlugin.html#keys()">keys()</a> and <a href="../../../com/trolltech/qt/gui/QAccessiblePlugin.html#create(java.lang.String, com.trolltech.qt.core.QObject)">create()</a> from that class, and adding one or two macros. The <tt>.pro</tt> file must be altered to use the plugin template, and the library containing the plugin must be placed on a path where Qt searches for accessible plugins. <p>We will go through the implementation of <tt>SliderPlugin</tt>, which is an accessible plugin that produces interfaces for the QAccessibleSlider we implemented in the <a href="accessible.html#qaccessiblewidget-example">QAccessibleWidget Example</a>. We start with the <tt>key()</tt> function:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QStringList SliderPlugin::keys() const
{
    return QStringList() &lt;&lt; "QSlider";
}
</pre> We simply need to return the class name of the single interface our plugin can create an accessible interface for. A plugin can support any number of classes; just add more class names to the string list. We move on to the <tt>create()</tt> function:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QAccessibleInterface *SliderPlugin::create(const QString &classname, QObject *object)
{
    QAccessibleInterface *interface = 0;

    if (classname == "QSlider" && object && object-&gt;isWidgetType())
        interface = new AccessibleSlider(classname, static_cast&lt;QWidget *&gt;(object));

    return interface;
}
</pre> We check whether the interface requested is for the <a href="../../../com/trolltech/qt/gui/QSlider.html">QSlider</a>; if it is, we create and return an interface for it. Note that <tt>object</tt> will always be an instance of <tt>classname</tt>. You must return 0 if you do not support the class. <a href="../../../com/trolltech/qt/gui/QAccessible.html#updateAccessibility(com.trolltech.qt.core.QObject, int, com.trolltech.qt.gui.QAccessible.Event)">updateAccessibility()</a> checks with the available accessibility plugins until it finds one that does not return 0. <p>Finally, you need to include macros in the cpp file:<br><br>The following code example is written in c++.<br> <pre class="snippet">
Q_EXPORT_STATIC_PLUGIN(SliderPlugin)
Q_EXPORT_PLUGIN2(acc_sliderplugin, SliderPlugin)
</pre> The Q_EXPORT_PLUGIN2 macro exports the plugin in the <tt>SliderPlugin</tt> class into the <tt>acc_sliderplugin</tt> library. The first argument is the name of the plugin library file, excluding the file suffix, and the second is the class name. For more information on plugins, consult the plugins <a href="plugins-howto.html">overview document</a>. <p>You can omit the the first macro unless you want the plugin to be statically linked with the application.<a name="implementing-interface-factories"><h3>Implementing Interface Factories</h3> If you do not want to provide plugins for your accessibility interfaces, you can use an interface factory (QAccessible::InterfaceFactory), which is the recommended way to provide accessible interfaces in a statically-linked application. <p>A factory is a function pointer for a function that takes the same parameters as <a href="../../../com/trolltech/qt/gui/QAccessiblePlugin.html">QAccessiblePlugin</a>'s <a href="../../../com/trolltech/qt/gui/QAccessiblePlugin.html#create(java.lang.String, com.trolltech.qt.core.QObject)">create()</a> - a QString and a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. It also works the same way. You install the factory with the installFactory() function. We give an example of how to create a factory for the <tt>SliderPlugin</tt> class:<br><br>The following code example is written in c++.<br> <pre class="snippet">
QAccessibleInterface *sliderFactory(const QString &classname, QObject *object)
{
    QAccessibleInterface *interface = 0;

    if (classname == "QSlider" && object && object-&gt;isWidgetType())
        interface = new SliderInterface(classname,
                                        static_cast&lt;QWidget *&gt;(object));
    
    return interface;
}

int main(int argv, char **args)
{
    QApplication app(argv, args);
    QAccessible::installFactory(sliderFactory);
...
}
</pre><a name="further-reading"><h2>Further Reading</h2> The <a href="qt4-accessibility.html">Cross-Platform Accessibility Support in Qt 4</a> document contains a more general overview of Qt's accessibility features and discusses how it is used on each platform. issues<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
