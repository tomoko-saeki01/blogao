<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Mon Feb 09 12:20:30 CET 2009 -->
<TITLE>
QIODevice
</TITLE>

<META NAME="date" CONTENT="2009-02-09">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="QIODevice";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/trolltech/qt/core/QFutureWatcher.html" title="class in com.trolltech.qt.core"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?com/trolltech/qt/core/QIODevice.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="QIODevice.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.trolltech.qt.core</FONT>
<BR>
Class QIODevice</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by ">com.trolltech.qt.internal.QSignalEmitterInternal
      <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../com/trolltech/qt/QSignalEmitter.html" title="class in com.trolltech.qt">com.trolltech.qt.QSignalEmitter</A>
          <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../com/trolltech/qt/QtJambiObject.html" title="class in com.trolltech.qt">com.trolltech.qt.QtJambiObject</A>
              <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../com/trolltech/qt/core/QObject.html" title="class in com.trolltech.qt.core">com.trolltech.qt.core.QObject</A>
                  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>com.trolltech.qt.core.QIODevice</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../com/trolltech/qt/QtJambiInterface.html" title="interface in com.trolltech.qt">QtJambiInterface</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../com/trolltech/qt/network/QAbstractSocket.html" title="class in com.trolltech.qt.network">QAbstractSocket</A>, <A HREF="../../../../com/trolltech/qt/core/QBuffer.html" title="class in com.trolltech.qt.core">QBuffer</A>, <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core">QFile</A>, <A HREF="../../../../com/trolltech/qt/network/QLocalSocket.html" title="class in com.trolltech.qt.network">QLocalSocket</A>, <A HREF="../../../../com/trolltech/qt/network/QNetworkReply.html" title="class in com.trolltech.qt.network">QNetworkReply</A>, <A HREF="../../../../com/trolltech/qt/core/QProcess.html" title="class in com.trolltech.qt.core">QProcess</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>QIODevice</B><DT>extends <A HREF="../../../../com/trolltech/qt/core/QObject.html" title="class in com.trolltech.qt.core">QObject</A></DL>
</PRE>

<P>
The QIODevice class is the base interface class of all I/O devices in Qt. QIODevice provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data, such as <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core"><CODE>QFile</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QBuffer.html" title="class in com.trolltech.qt.core"><CODE>QBuffer</CODE></A> and <A HREF="../../../../com/trolltech/qt/network/QTcpSocket.html" title="class in com.trolltech.qt.network"><CODE>QTcpSocket</CODE></A>. QIODevice is abstract and can not be instantiated, but it is common to use the interface it defines to provide device-independent I/O features. For example, Qt's XML classes operate on a QIODevice pointer, allowing them to be used with various devices (such as files and buffers). <p>Before accessing the device, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>open()</CODE></A> must be called to set the correct OpenMode (such as <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>ReadOnly </CODE></A> or <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>ReadWrite </CODE></A>). You can then write to the device with <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(com.trolltech.qt.core.QByteArray)"><CODE>write()</CODE></A> or putChar(), and read by calling either <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A>, or <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readAll()"><CODE>readAll()</CODE></A>. Call <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#close()"><CODE>close()</CODE></A> when you are done with the device. <p>QIODevice distinguishes between two types of devices: random-access devices and sequential devices. <ul><li> Random-access devices support seeking to arbitrary positions using <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#seek(long)"><CODE>seek()</CODE></A>. The current position in the file is available by calling <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#pos()"><CODE>pos()</CODE></A>. <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core"><CODE>QFile</CODE></A> and <A HREF="../../../../com/trolltech/qt/core/QBuffer.html" title="class in com.trolltech.qt.core"><CODE>QBuffer</CODE></A> are examples of random-access devices.</li><li> Sequential devices don't support seeking to arbitrary positions. The data must be read in one pass. The functions <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#pos()"><CODE>pos()</CODE></A> and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#size()"><CODE>size()</CODE></A> don't work for sequential devices. <A HREF="../../../../com/trolltech/qt/network/QTcpSocket.html" title="class in com.trolltech.qt.network"><CODE>QTcpSocket</CODE></A> and <A HREF="../../../../com/trolltech/qt/core/QProcess.html" title="class in com.trolltech.qt.core"><CODE>QProcess</CODE></A> are examples of sequential devices.</li></ul> You can use <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A> to determine the type of device. <p>QIODevice emits <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> when new data is available for reading; for example, if new data has arrived on the network or if additional data is appended to a file that you are reading from. You can call <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A> to determine the number of bytes that currently available for reading. It's common to use <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A> together with the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> signal when programming with asynchronous devices such as <A HREF="../../../../com/trolltech/qt/network/QTcpSocket.html" title="class in com.trolltech.qt.network"><CODE>QTcpSocket</CODE></A>, where fragments of data can arrive at arbitrary points in time. QIODevice emits the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> signal every time a payload of data has been written to the device. Use <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesToWrite()"><CODE>bytesToWrite()</CODE></A> to determine the current amount of data waiting to be written. <p>Certain subclasses of QIODevice, such as <A HREF="../../../../com/trolltech/qt/network/QTcpSocket.html" title="class in com.trolltech.qt.network"><CODE>QTcpSocket</CODE></A> and <A HREF="../../../../com/trolltech/qt/core/QProcess.html" title="class in com.trolltech.qt.core"><CODE>QProcess</CODE></A>, are asynchronous. This means that I/O functions such as <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(com.trolltech.qt.core.QByteArray)"><CODE>write()</CODE></A> or <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A> always return immediately, while communication with the device itself may happen when control goes back to the event loop. QIODevice provides functions that allow you to force these operations to be performed immediately, while blocking the calling thread and without entering the event loop. This allows QIODevice subclasses to be used without an event loop, or in a separate thread: <ul><li> <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForReadyRead(int)"><CODE>waitForReadyRead()</CODE></A> - This function suspends operation in the calling thread until new data is available for reading.</li><li> <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForBytesWritten(int)"><CODE>waitForBytesWritten()</CODE></A> - This function suspends operation in the calling thread until one payload of data has been written to the device.</li><li> waitFor....() - Subclasses of QIODevice implement blocking functions for device-specific operations. For example, <A HREF="../../../../com/trolltech/qt/core/QProcess.html" title="class in com.trolltech.qt.core"><CODE>QProcess</CODE></A> has a function called waitForStarted() which suspends operation in the calling thread until the process has started.</li></ul> Calling these functions from the main, GUI thread, may cause your user interface to freeze. Example: <pre class="snippet">
        QProcess gzip = new QProcess();
        gzip.start("gzip", Arrays.asList("-c"));
        if (!gzip.waitForStarted())
            return false;

        gzip.write(new QByteArray("uncompressed data"));

        QByteArray compressed = new QByteArray();
        while (gzip.waitForReadyRead(5000))
            compressed.append(gzip.readAll());
</pre> By subclassing QIODevice, you can provide the same interface to your own I/O devices. Subclasses of QIODevice are only required to implement the protected <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readData(byte[])"><CODE>readData()</CODE></A> and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#writeData(byte[])"><CODE>writeData()</CODE></A> functions. QIODevice uses these functions to implement all its convenience functions, such as getChar(), <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A> and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(com.trolltech.qt.core.QByteArray)"><CODE>write()</CODE></A>. QIODevice also handles access control for you, so you can safely assume that the device is opened in write mode if <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#writeData(byte[])"><CODE>writeData()</CODE></A> is called. <p>Some subclasses, such as <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core"><CODE>QFile</CODE></A> and <A HREF="../../../../com/trolltech/qt/network/QTcpSocket.html" title="class in com.trolltech.qt.network"><CODE>QTcpSocket</CODE></A>, are implemented using a memory buffer for intermediate storing of data. This reduces the number of required device accessing calls, which are often very slow. Buffering makes functions like getChar() and putChar() fast, as they can operate on the memory buffer instead of directly on the device itself. Certain I/O operations, however, don't work well with a buffer. For example, if several users open the same device and read it character by character, they may end up reading the same data when they meant to read a separate chunk each. For this reason, QIODevice allows you to bypass any buffering by passing the Unbuffered flag to <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>open()</CODE></A>. When subclassing QIODevice, remember to bypass any buffer you may use when the device is open in Unbuffered mode. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QBuffer.html" title="class in com.trolltech.qt.core"><CODE>QBuffer</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core"><CODE>QFile</CODE></A>, and <A HREF="../../../../com/trolltech/qt/network/QTcpSocket.html" title="class in com.trolltech.qt.network"><CODE>QTcpSocket</CODE></A>. <br></DD></DT>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core">QIODevice.OpenModeFlag</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enum is used with <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>open()</CODE></A> to describe the mode in which a device is opened.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_com.trolltech.qt.QSignalEmitter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class com.trolltech.qt.<A HREF="../../../../com/trolltech/qt/QSignalEmitter.html" title="class in com.trolltech.qt">QSignalEmitter</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../com/trolltech/qt/QSignalEmitter.AbstractSignal.html" title="class in com.trolltech.qt">QSignalEmitter.AbstractSignal</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal0.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal0</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal1.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal1</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal2.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal2</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal3.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal3</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal4.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal4</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal5.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal5</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal6.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal6</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal7.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal7</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal8.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal8</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.PrivateSignal9.html" title="class in com.trolltech.qt">QSignalEmitter.PrivateSignal9</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal1.html" title="class in com.trolltech.qt">QSignalEmitter.Signal1</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal2.html" title="class in com.trolltech.qt">QSignalEmitter.Signal2</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal3.html" title="class in com.trolltech.qt">QSignalEmitter.Signal3</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal4.html" title="class in com.trolltech.qt">QSignalEmitter.Signal4</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal5.html" title="class in com.trolltech.qt">QSignalEmitter.Signal5</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal6.html" title="class in com.trolltech.qt">QSignalEmitter.Signal6</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal7.html" title="class in com.trolltech.qt">QSignalEmitter.Signal7</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal8.html" title="class in com.trolltech.qt">QSignalEmitter.Signal8</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal9.html" title="class in com.trolltech.qt">QSignalEmitter.Signal9</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_com.trolltech.qt.internal.QSignalEmitterInternal"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class com.trolltech.qt.internal.QSignalEmitterInternal</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>com.trolltech.qt.internal.QSignalEmitterInternal.AbstractSignalInternal</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#aboutToClose">aboutToClose</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This signal is emitted when the device is about to close.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal1.html" title="class in com.trolltech.qt">QSignalEmitter.Signal1</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten">bytesWritten</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This signal takes 1 generic argument(s).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readChannelFinished">readChannelFinished</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This signal is emitted when the input (reading) stream is closed in this device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead">readyRead</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This signal is emitted once every time new data is available for reading from the device.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_com.trolltech.qt.internal.QSignalEmitterInternal"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class com.trolltech.qt.internal.QSignalEmitterInternal</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>currentSender</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#QIODevice()">QIODevice</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a QIODevice object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#QIODevice(com.trolltech.qt.core.QObject)">QIODevice</A></B>(<A HREF="../../../../com/trolltech/qt/core/QObject.html" title="class in com.trolltech.qt.core">QObject</A>&nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a QIODevice object with the given <tt>parent</tt>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#atEnd()">atEnd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the current read and write position is at the end of the device (i.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()">bytesAvailable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of bytes that are available for reading.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesToWrite()">bytesToWrite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For buffered devices, this function returns the number of bytes waiting to be written.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#canReadLine()">canReadLine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if a complete line of data can be read from the device; otherwise returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First emits <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#aboutToClose"><CODE>aboutToClose() </CODE></A>, then closes the device and sets its OpenMode to <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>NotOpen </CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#errorString()">errorString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a human-readable description of the last device error that occurred.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#getByte()">getByte</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a byte from the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isOpen()">isOpen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the device is open; otherwise returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isReadable()">isReadable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if data can be read from the device; otherwise returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()">isSequential</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if this device is sequential; otherwise returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isTextModeEnabled()">isTextModeEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>Text </CODE></A> flag is enabled; otherwise returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isWritable()">isWritable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if data can be written to the device; otherwise returns false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenMode)">open</A></B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A>&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opens the device and sets its OpenMode to <tt>mode</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])">open</A></B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core">QIODevice.OpenModeFlag</A>[]&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()">openMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the mode in which the device has been opened; i.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#peek(byte[])">peek</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#peek(long)">peek</A></B>(long&nbsp;maxlen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is an overloaded member function, provided for convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#pos()">pos</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For random-access devices, this function returns the position that data is written to or read from.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#putByte(byte)">putByte</A></B>(byte&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes the character <tt>c</tt> to the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(byte[])">read</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)">read</A></B>(long&nbsp;maxlen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is an overloaded member function, provided for convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readAll()">readAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is an overloaded member function, provided for convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readData(byte[])">readData</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads up to <tt>maxSize</tt> bytes from the device into <tt>data</tt>, and returns the number of bytes read or -1 if an error occurred.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()">readLine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is an overloaded member function, provided for convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine(byte[])">readLine</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine(long)">readLine</A></B>(long&nbsp;maxlen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is an overloaded member function, provided for convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLineData(byte[])">readLineData</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads up to <tt>maxSize</tt> characters into <tt>data</tt> and returns the number of characters read.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seeks to the start of input for random-access devices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#seek(long)">seek</A></B>(long&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For random-access devices, this function sets the current position to <tt>pos</tt>, returning true on success, or false if an error occurred.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setErrorString(java.lang.String)">setErrorString</A></B>(java.lang.String&nbsp;errorString)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the human readable description of the last device error that occurred to <tt>str</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setOpenMode(com.trolltech.qt.core.QIODevice.OpenMode)">setOpenMode</A></B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A>&nbsp;openMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the OpenMode of the device to <tt>openMode</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setOpenMode(com.trolltech.qt.core.QIODevice.OpenModeFlag[])">setOpenMode</A></B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core">QIODevice.OpenModeFlag</A>[]&nbsp;openMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setTextModeEnabled(boolean)">setTextModeEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If <tt>enabled</tt> is true, this function sets the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>Text </CODE></A> flag on the device; otherwise the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>Text </CODE></A> flag is removed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For open random-access devices, this function returns the size of the device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#ungetByte(byte)">ungetByte</A></B>(byte&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Puts the character <tt>c</tt> back into the device, and decrements the current position unless the position is 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForBytesWritten(int)">waitForBytesWritten</A></B>(int&nbsp;msecs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For buffered devices, this function waits until a payload of buffered written data has been written to the device and the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> signal has been emitted, or until <tt>msecs</tt> milliseconds have passed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForReadyRead(int)">waitForReadyRead</A></B>(int&nbsp;msecs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blocks until data is available for reading and the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> signal has been emitted, or until <tt>msecs</tt> milliseconds have passed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(byte[])">write</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(com.trolltech.qt.core.QByteArray)">write</A></B>(<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is an overloaded member function, provided for convenience.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#writeData(byte[])">writeData</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes up to <tt>maxSize</tt> bytes from <tt>data</tt> to the device.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_com.trolltech.qt.core.QObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class com.trolltech.qt.core.<A HREF="../../../../com/trolltech/qt/core/QObject.html" title="class in com.trolltech.qt.core">QObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../com/trolltech/qt/core/QObject.html#childEvent(com.trolltech.qt.core.QChildEvent)">childEvent</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#children()">children</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#connectSlotsByName()">connectSlotsByName</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#customEvent(com.trolltech.qt.core.QEvent)">customEvent</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#disposeLater()">disposeLater</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#dumpObjectInfo()">dumpObjectInfo</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#dumpObjectTree()">dumpObjectTree</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#dynamicPropertyNames()">dynamicPropertyNames</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#event(com.trolltech.qt.core.QEvent)">event</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#eventFilter(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">eventFilter</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChild()">findChild</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChild(java.lang.Class)">findChild</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChild(java.lang.Class, java.lang.String)">findChild</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChildren()">findChildren</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChildren(java.lang.Class)">findChildren</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChildren(java.lang.Class, com.trolltech.qt.core.QRegExp)">findChildren</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#findChildren(java.lang.Class, java.lang.String)">findChildren</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#indexOfProperty(java.lang.String)">indexOfProperty</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#installEventFilter(com.trolltech.qt.core.QObject)">installEventFilter</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#isWidgetType()">isWidgetType</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#killTimer(int)">killTimer</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#moveToThread(java.lang.Thread)">moveToThread</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#objectName()">objectName</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#parent()">parent</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#properties()">properties</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#property(java.lang.String)">property</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#removeEventFilter(com.trolltech.qt.core.QObject)">removeEventFilter</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#setObjectName(java.lang.String)">setObjectName</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#setParent(com.trolltech.qt.core.QObject)">setParent</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#startTimer(int)">startTimer</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#timerEvent(com.trolltech.qt.core.QTimerEvent)">timerEvent</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#toString()">toString</A>, <A HREF="../../../../com/trolltech/qt/core/QObject.html#userProperty()">userProperty</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_com.trolltech.qt.QtJambiObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class com.trolltech.qt.<A HREF="../../../../com/trolltech/qt/QtJambiObject.html" title="class in com.trolltech.qt">QtJambiObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../com/trolltech/qt/QtJambiObject.html#dispose()">dispose</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#disposed()">disposed</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#finalize()">finalize</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#reassignNativeResources(com.trolltech.qt.QtJambiObject, java.lang.Class)">reassignNativeResources</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#tr(java.lang.String)">tr</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#tr(java.lang.String, java.lang.String)">tr</A>, <A HREF="../../../../com/trolltech/qt/QtJambiObject.html#tr(java.lang.String, java.lang.String, int)">tr</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_com.trolltech.qt.QSignalEmitter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class com.trolltech.qt.<A HREF="../../../../com/trolltech/qt/QSignalEmitter.html" title="class in com.trolltech.qt">QSignalEmitter</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../com/trolltech/qt/QSignalEmitter.html#blockSignals(boolean)">blockSignals</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.html#disconnect()">disconnect</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.html#disconnect(java.lang.Object)">disconnect</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.html#signalsBlocked()">signalsBlocked</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.html#signalSender()">signalSender</A>, <A HREF="../../../../com/trolltech/qt/QSignalEmitter.html#thread()">thread</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_com.trolltech.qt.internal.QSignalEmitterInternal"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class com.trolltech.qt.internal.QSignalEmitterInternal</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>__qt_signalInitialization</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_com.trolltech.qt.QtJambiInterface"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface com.trolltech.qt.<A HREF="../../../../com/trolltech/qt/QtJambiInterface.html" title="interface in com.trolltech.qt">QtJambiInterface</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../com/trolltech/qt/QtJambiInterface.html#disableGarbageCollection()">disableGarbageCollection</A>, <A HREF="../../../../com/trolltech/qt/QtJambiInterface.html#nativeId()">nativeId</A>, <A HREF="../../../../com/trolltech/qt/QtJambiInterface.html#nativePointer()">nativePointer</A>, <A HREF="../../../../com/trolltech/qt/QtJambiInterface.html#reenableGarbageCollection()">reenableGarbageCollection</A>, <A HREF="../../../../com/trolltech/qt/QtJambiInterface.html#setJavaOwnership()">setJavaOwnership</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="aboutToClose"><!-- --></A><H3>
aboutToClose</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A> <B>aboutToClose</B></PRE>
<DL>
<DD>This signal is emitted when the device is about to close. Connect this signal if you have operations that need to be performed before the device closes (e.g., if you have data in a separate buffer that needs to be written to the device).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="bytesWritten"><!-- --></A><H3>
bytesWritten</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal1.html" title="class in com.trolltech.qt">QSignalEmitter.Signal1</A> <B>bytesWritten</B></PRE>
<DL>
<DD><p>This signal takes 1 generic argument(s). We list their type and the name they go by in the description of this signal. &lt;java.lang.Long(named: bytes)&gt;:<p> This signal is emitted every time a payload of data has been written to the device. The <tt>bytes</tt> argument is set to the number of bytes that were written in this payload. <p><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> is not emitted recursively; if you reenter the event loop or call <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForBytesWritten(int)"><CODE>waitForBytesWritten()</CODE></A> inside a slot connected to the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> signal, the signal will not be reemitted (although <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForBytesWritten(int)"><CODE>waitForBytesWritten()</CODE></A> may still return true). <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A>. <br></DD></DT>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="readChannelFinished"><!-- --></A><H3>
readChannelFinished</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A> <B>readChannelFinished</B></PRE>
<DL>
<DD>This signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected, which means that there might still be data available for reading with <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#atEnd()"><CODE>atEnd()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>. <br></DD></DT>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="readyRead"><!-- --></A><H3>
readyRead</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/QSignalEmitter.Signal0.html" title="class in com.trolltech.qt">QSignalEmitter.Signal0</A> <B>readyRead</B></PRE>
<DL>
<DD>This signal is emitted once every time new data is available for reading from the device. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device. <p><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> is not emitted recursively; if you reenter the event loop or call <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForReadyRead(int)"><CODE>waitForReadyRead()</CODE></A> inside a slot connected to the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> signal, the signal will not be reemitted (although <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForReadyRead(int)"><CODE>waitForReadyRead()</CODE></A> may still return true). <p>Note for developers implementing classes derived from QIODevice: you should always emit <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> in other conditions. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A>. <br></DD></DT>
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="QIODevice()"><!-- --></A><H3>
QIODevice</H3>
<PRE>
public <B>QIODevice</B>()</PRE>
<DL>
<DD>Constructs a QIODevice object.
<P>
</DL>
<HR>

<A NAME="QIODevice(com.trolltech.qt.core.QObject)"><!-- --></A><H3>
QIODevice</H3>
<PRE>
public <B>QIODevice</B>(<A HREF="../../../../com/trolltech/qt/core/QObject.html" title="class in com.trolltech.qt.core">QObject</A>&nbsp;parent)</PRE>
<DL>
<DD>Constructs a QIODevice object with the given <tt>parent</tt>.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="errorString()"><!-- --></A><H3>
errorString</H3>
<PRE>
public final java.lang.String <B>errorString</B>()</PRE>
<DL>
<DD>Returns a human-readable description of the last device error that occurred. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setErrorString(java.lang.String)"><CODE>setErrorString()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isOpen()"><!-- --></A><H3>
isOpen</H3>
<PRE>
public final boolean <B>isOpen</B>()</PRE>
<DL>
<DD>Returns true if the device is open; otherwise returns false. A device is open if it can be read from and/or written to. By default, this function returns false if <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()"><CODE>openMode()</CODE></A> returns <tt>NotOpen</tt>. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()"><CODE>openMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isReadable()"><!-- --></A><H3>
isReadable</H3>
<PRE>
public final boolean <B>isReadable</B>()</PRE>
<DL>
<DD>Returns true if data can be read from the device; otherwise returns false. Use <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A> to determine how many bytes can be read. <p>This is a convenience function which checks if the OpenMode of the device contains the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>ReadOnly </CODE></A> flag. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()"><CODE>openMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isTextModeEnabled()"><!-- --></A><H3>
isTextModeEnabled</H3>
<PRE>
public final boolean <B>isTextModeEnabled</B>()</PRE>
<DL>
<DD>Returns true if the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>Text </CODE></A> flag is enabled; otherwise returns false. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setTextModeEnabled(boolean)"><CODE>setTextModeEnabled()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isWritable()"><!-- --></A><H3>
isWritable</H3>
<PRE>
public final boolean <B>isWritable</B>()</PRE>
<DL>
<DD>Returns true if data can be written to the device; otherwise returns false. <p>This is a convenience function which checks if the OpenMode of the device contains the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>WriteOnly </CODE></A> flag. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()"><CODE>openMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="openMode()"><!-- --></A><H3>
openMode</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A> <B>openMode</B>()</PRE>
<DL>
<DD>Returns the mode in which the device has been opened; i. . <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>ReadOnly </CODE></A> or <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>WriteOnly </CODE></A>. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setOpenMode(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>setOpenMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="peek(long)"><!-- --></A><H3>
peek</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A> <B>peek</B>(long&nbsp;maxlen)</PRE>
<DL>
<DD>This is an overloaded member function, provided for convenience. <p>Peeks at most <tt>maxSize</tt> bytes from the device, returning the data peeked as a <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core"><CODE>QByteArray</CODE></A>. <p>Example: <pre class="snippet">
        public boolean isExeFile(QFile file)
        {
            return file.peek(2).equals("MZ");
        }
</pre> This function has no way of reporting errors; returning an empty QByteArray() can mean either that no data was currently available for peeking, or that an error occurred. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="putByte(byte)"><!-- --></A><H3>
putByte</H3>
<PRE>
public final boolean <B>putByte</B>(byte&nbsp;c)</PRE>
<DL>
<DD>Writes the character <tt>c</tt> to the device. Returns true on success; otherwise returns false. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(com.trolltech.qt.core.QByteArray)"><CODE>write()</CODE></A>, getChar(), and ungetChar(). <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="read(long)"><!-- --></A><H3>
read</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A> <B>read</B>(long&nbsp;maxlen)</PRE>
<DL>
<DD>This is an overloaded member function, provided for convenience. <p>Reads at most <tt>maxSize</tt> bytes from the device, and returns the data read as a <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core"><CODE>QByteArray</CODE></A>. <p>This function has no way of reporting errors; returning an empty QByteArray() can mean either that no data was currently available for reading, or that an error occurred.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readAll()"><!-- --></A><H3>
readAll</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A> <B>readAll</B>()</PRE>
<DL>
<DD>This is an overloaded member function, provided for convenience. <p>Reads all available data from the device, and returns it as a <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core"><CODE>QByteArray</CODE></A>. <p>This function has no way of reporting errors; returning an empty QByteArray() can mean either that no data was currently available for reading, or that an error occurred.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readLine()"><!-- --></A><H3>
readLine</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A> <B>readLine</B>()</PRE>
<DL>
<DD>This is an overloaded member function, provided for convenience. <p>Reads a line from the device, but no more than <tt>maxSize</tt> characters, and returns the result as a <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core"><CODE>QByteArray</CODE></A>. <p>This function has no way of reporting errors; returning an empty QByteArray() can mean either that no data was currently available for reading, or that an error occurred.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readLine(long)"><!-- --></A><H3>
readLine</H3>
<PRE>
public final <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A> <B>readLine</B>(long&nbsp;maxlen)</PRE>
<DL>
<DD>This is an overloaded member function, provided for convenience. <p>Reads a line from the device, but no more than <tt>maxSize</tt> characters, and returns the result as a <A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core"><CODE>QByteArray</CODE></A>. <p>This function has no way of reporting errors; returning an empty QByteArray() can mean either that no data was currently available for reading, or that an error occurred.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setErrorString(java.lang.String)"><!-- --></A><H3>
setErrorString</H3>
<PRE>
protected final void <B>setErrorString</B>(java.lang.String&nbsp;errorString)</PRE>
<DL>
<DD>Sets the human readable description of the last device error that occurred to <tt>str</tt>. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#errorString()"><CODE>errorString()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOpenMode(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><!-- --></A><H3>
setOpenMode</H3>
<PRE>
protected final void <B>setOpenMode</B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core">QIODevice.OpenModeFlag</A>[]&nbsp;openMode)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOpenMode(com.trolltech.qt.core.QIODevice.OpenMode)"><!-- --></A><H3>
setOpenMode</H3>
<PRE>
protected final void <B>setOpenMode</B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A>&nbsp;openMode)</PRE>
<DL>
<DD>Sets the OpenMode of the device to <tt>openMode</tt>. Call this function to set the open mode if the flags change after the device has been opened. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()"><CODE>openMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTextModeEnabled(boolean)"><!-- --></A><H3>
setTextModeEnabled</H3>
<PRE>
public final void <B>setTextModeEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>If <tt>enabled</tt> is true, this function sets the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>Text </CODE></A> flag on the device; otherwise the <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>Text </CODE></A> flag is removed. This feature is useful for classes that provide custom end-of-line handling on a QIODevice. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isTextModeEnabled()"><CODE>isTextModeEnabled()</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>open()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setOpenMode(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>setOpenMode()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ungetByte(byte)"><!-- --></A><H3>
ungetByte</H3>
<PRE>
public final void <B>ungetByte</B>(byte&nbsp;c)</PRE>
<DL>
<DD>Puts the character <tt>c</tt> back into the device, and decrements the current position unless the position is 0. This function is usually called to "undo" a getChar() operation, such as when writing a backtracking parser. <p>If <tt>c</tt> was not previously read from the device, the behavior is undefined.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="write(com.trolltech.qt.core.QByteArray)"><!-- --></A><H3>
write</H3>
<PRE>
public final long <B>write</B>(<A HREF="../../../../com/trolltech/qt/core/QByteArray.html" title="class in com.trolltech.qt.core">QByteArray</A>&nbsp;data)</PRE>
<DL>
<DD>This is an overloaded member function, provided for convenience. <p>Writes the content of <tt>byteArray</tt> to the device. Returns the number of bytes that were actually written, or -1 if an error occurred. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#writeData(byte[])"><CODE>writeData()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="atEnd()"><!-- --></A><H3>
atEnd</H3>
<PRE>
public boolean <B>atEnd</B>()</PRE>
<DL>
<DD>Returns true if the current read and write position is at the end of the device (i. . there is no more data available for reading on the device); otherwise returns false. <p>For some devices, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#atEnd()"><CODE>atEnd()</CODE></A> can return true even though there is more data to read. This special case only applies to devices that generate data in direct response to you calling <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A> (e.g., <tt>/dev</tt> or <tt>/proc</tt> files on Unix and Mac OS X, or console input / <tt>stdin</tt> on all platforms). <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bytesAvailable()"><!-- --></A><H3>
bytesAvailable</H3>
<PRE>
public long <B>bytesAvailable</B>()</PRE>
<DL>
<DD>Returns the number of bytes that are available for reading. This function is commonly used with sequential devices to determine the number of bytes to allocate in a buffer before reading. <p>Subclasses that reimplement this function must call the base implementation in order to include the size of QIODevices' buffer. Example: <pre class="snippet">
        public long bytesAvailable()
        {
            return buffer.size() + super.bytesAvailable();
        }
</pre> <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesToWrite()"><CODE>bytesToWrite()</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bytesToWrite()"><!-- --></A><H3>
bytesToWrite</H3>
<PRE>
public long <B>bytesToWrite</B>()</PRE>
<DL>
<DD>For buffered devices, this function returns the number of bytes waiting to be written. For devices with no buffer, this function returns 0. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="canReadLine()"><!-- --></A><H3>
canReadLine</H3>
<PRE>
public boolean <B>canReadLine</B>()</PRE>
<DL>
<DD>Returns true if a complete line of data can be read from the device; otherwise returns false. <p>Note that unbuffered devices, which have no way of determining what can be read, always return false. <p>This function is often called in conjunction with the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> signal. <p>Subclasses that reimplement this function must call the base implementation in order to include the size of the QIODevice's buffer. Example: <pre class="snippet">
        public boolean canReadLine()
        {
            return buffer.contains("\n") || super.canReadLine();
        }
</pre> <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()</PRE>
<DL>
<DD>First emits <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#aboutToClose"><CODE>aboutToClose() </CODE></A>, then closes the device and sets its OpenMode to <A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core"><CODE>NotOpen </CODE></A>. The error string is also reset. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#setOpenMode(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>setOpenMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSequential()"><!-- --></A><H3>
isSequential</H3>
<PRE>
public boolean <B>isSequential</B>()</PRE>
<DL>
<DD>Returns true if this device is sequential; otherwise returns false. <p>Sequential devices, as opposed to a random-access devices, have no concept of a start, an end, a size, or a current position, and they do not support seeking. You can only read from the device when it reports that data is available. The most common example of a sequential device is a network socket. On Unix, special files such as /dev/zero and fifo pipes are sequential. <p>Regular files, on the other hand, do support random access. They have both a size and a current position, and they also support seeking backwards and forwards in the data stream. Regular files are non-sequential. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><!-- --></A><H3>
open</H3>
<PRE>
public final boolean <B>open</B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenModeFlag.html" title="class in com.trolltech.qt.core">QIODevice.OpenModeFlag</A>[]&nbsp;mode)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="open(com.trolltech.qt.core.QIODevice.OpenMode)"><!-- --></A><H3>
open</H3>
<PRE>
public boolean <B>open</B>(<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core">QIODevice.OpenMode</A>&nbsp;mode)</PRE>
<DL>
<DD>Opens the device and sets its OpenMode to <tt>mode</tt>. Returns true if successful; otherwise returns false. This function should be called from any reimplementations of <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#open(com.trolltech.qt.core.QIODevice.OpenModeFlag[])"><CODE>open()</CODE></A> or other functions that open the device. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#openMode()"><CODE>openMode()</CODE></A>, and OpenMode. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pos()"><!-- --></A><H3>
pos</H3>
<PRE>
public long <B>pos</B>()</PRE>
<DL>
<DD>For random-access devices, this function returns the position that data is written to or read from. For sequential devices or closed devices, where there is no concept of a "current position", 0 is returned. <p>The current read/write position of the device is maintained internally by QIODevice, so reimplementing this function is not necessary. When subclassing QIODevice, use <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#seek(long)"><CODE>QIODevice::seek()</CODE></A> to notify QIODevice about changes in the device position. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#seek(long)"><CODE>seek()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readData(byte[])"><!-- --></A><H3>
readData</H3>
<PRE>
protected abstract int <B>readData</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD>Reads up to <tt>maxSize</tt> bytes from the device into <tt>data</tt>, and returns the number of bytes read or -1 if an error occurred. If there are no bytes to be read, this function should return -1 if there can never be more bytes available (for example: socket closed, pipe closed, sub-process finished). <p>This function is called by QIODevice. Reimplement this function when creating a subclass of QIODevice. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#writeData(byte[])"><CODE>writeData()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readLineData(byte[])"><!-- --></A><H3>
readLineData</H3>
<PRE>
protected int <B>readLineData</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD>Reads up to <tt>maxSize</tt> characters into <tt>data</tt> and returns the number of characters read. <p>This function is called by <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A>, and provides its base implementation, using getChar(). Buffered devices can improve the performance of <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A> by reimplementing this function. <p><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLine()"><CODE>readLine()</CODE></A> appends a '\0' byte to <tt>data</tt>; <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readLineData(byte[])"><CODE>readLineData()</CODE></A> does not need to do this. <p>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public boolean <B>reset</B>()</PRE>
<DL>
<DD>Seeks to the start of input for random-access devices. Returns true on success; otherwise returns false (for example, if the device is not open). <p>Note that when using a <A HREF="../../../../com/trolltech/qt/core/QTextStream.html" title="class in com.trolltech.qt.core"><CODE>QTextStream</CODE></A> on a <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core"><CODE>QFile</CODE></A>, calling <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#reset()"><CODE>reset()</CODE></A> on the <A HREF="../../../../com/trolltech/qt/core/QFile.html" title="class in com.trolltech.qt.core"><CODE>QFile</CODE></A> will not have the expected result because <A HREF="../../../../com/trolltech/qt/core/QTextStream.html" title="class in com.trolltech.qt.core"><CODE>QTextStream</CODE></A> buffers the file. Use the <A HREF="../../../../com/trolltech/qt/core/QTextStream.html#seek(long)"><CODE>QTextStream::seek()</CODE></A> function instead. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#seek(long)"><CODE>seek()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="seek(long)"><!-- --></A><H3>
seek</H3>
<PRE>
public boolean <B>seek</B>(long&nbsp;pos)</PRE>
<DL>
<DD>For random-access devices, this function sets the current position to <tt>pos</tt>, returning true on success, or false if an error occurred. For sequential devices, the default behavior is to do nothing and return false. <p>When subclassing QIODevice, you must call <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#seek(long)"><CODE>QIODevice::seek()</CODE></A> at the start of your function to ensure integrity with QIODevice's built-in buffer. The base implementation always returns true. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#pos()"><CODE>pos()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public long <B>size</B>()</PRE>
<DL>
<DD>For open random-access devices, this function returns the size of the device. For open sequential devices, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesAvailable()"><CODE>bytesAvailable()</CODE></A> is returned. <p>If the device is closed, the size returned will not reflect the actual size of the device. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#isSequential()"><CODE>isSequential()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#pos()"><CODE>pos()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="waitForBytesWritten(int)"><!-- --></A><H3>
waitForBytesWritten</H3>
<PRE>
public boolean <B>waitForBytesWritten</B>(int&nbsp;msecs)</PRE>
<DL>
<DD>For buffered devices, this function waits until a payload of buffered written data has been written to the device and the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> signal has been emitted, or until <tt>msecs</tt> milliseconds have passed. If msecs is -1, this function will not time out. For unbuffered devices, it returns immediately. <p>Returns true if a payload of data was written to the device; otherwise returns false (i.e. if the operation timed out, or if an error occurred). <p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread. <p>If called from within a slot connected to the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> signal, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#bytesWritten"><CODE>bytesWritten() </CODE></A> will not be reemitted. <p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns false. <p><b>Warning:</b> Calling this function from the main (GUI) thread might cause your user interface to freeze. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForReadyRead(int)"><CODE>waitForReadyRead()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="waitForReadyRead(int)"><!-- --></A><H3>
waitForReadyRead</H3>
<PRE>
public boolean <B>waitForReadyRead</B>(int&nbsp;msecs)</PRE>
<DL>
<DD>Blocks until data is available for reading and the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> signal has been emitted, or until <tt>msecs</tt> milliseconds have passed. If msecs is -1, this function will not time out. <p>Returns true if data is available for reading; otherwise returns false (if the operation timed out or if an error occurred). <p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread. <p>If called from within a slot connected to the <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> signal, <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#readyRead"><CODE>readyRead() </CODE></A> will not be reemitted. <p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns false. <p><b>Warning:</b> Calling this function from the main (GUI) thread might cause your user interface to freeze. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#waitForBytesWritten(int)"><CODE>waitForBytesWritten()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="writeData(byte[])"><!-- --></A><H3>
writeData</H3>
<PRE>
protected abstract int <B>writeData</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD>Writes up to <tt>maxSize</tt> bytes from <tt>data</tt> to the device. Returns the number of bytes written, or -1 if an error occurred. <p>This function is called by QIODevice. Reimplement this function when creating a subclass of QIODevice. <p><DT><b>See also:</b><br><DD><A HREF="../../../../com/trolltech/qt/core/QIODevice.html#read(long)"><CODE>read()</CODE></A>, and <A HREF="../../../../com/trolltech/qt/core/QIODevice.html#write(com.trolltech.qt.core.QByteArray)"><CODE>write()</CODE></A>. <br></DD></DT>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getByte()"><!-- --></A><H3>
getByte</H3>
<PRE>
public final int <B>getByte</B>()</PRE>
<DL>
<DD>Gets a byte from the device.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>-1 on failure, or the value of the byte on success</DL>
</DD>
</DL>
<HR>

<A NAME="peek(byte[])"><!-- --></A><H3>
peek</H3>
<PRE>
public final int <B>peek</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="read(byte[])"><!-- --></A><H3>
read</H3>
<PRE>
public final int <B>read</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readLine(byte[])"><!-- --></A><H3>
readLine</H3>
<PRE>
public final int <B>readLine</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[])"><!-- --></A><H3>
write</H3>
<PRE>
public final int <B>write</B>(byte[]&nbsp;data)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/trolltech/qt/core/QFutureWatcher.html" title="class in com.trolltech.qt.core"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/trolltech/qt/core/QIODevice.OpenMode.html" title="class in com.trolltech.qt.core"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?com/trolltech/qt/core/QIODevice.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="QIODevice.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
