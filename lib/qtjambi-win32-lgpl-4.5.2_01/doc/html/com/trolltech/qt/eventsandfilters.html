<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Events and Event Filters</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Events and Event Filters</h1></center><p>A guide to event handling in Qt. In Qt, events are objects, derived from the abstract <a href="../../../com/trolltech/qt/core/QEvent.html">QEvent</a> class, that represent things that have happened either within an application or as a result of outside activity that the application needs to know about. Events can be received and handled by any instance of a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass, but they are especially relevant to widgets. This document describes how events are delivered and handled in a typical application. <ul><li> <a href="#how-events-are-delivered">How Events are Delivered</a></li><li> <a href="#event-types">Event Types</a></li><li> <a href="#event-handlers">Event Handlers</a></li><li> <a href="#event-filters">Event Filters</a></li><li> <a href="#sending-events">Sending Events</a></li></ul><a name="how-events-are-delivered"><h2>How Events are Delivered</h2> When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate <a href="../../../com/trolltech/qt/core/QEvent.html">QEvent</a> subclass, and delivers it to a particular instance of <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> (or one of its subclasses) by calling its <a href="../../../com/trolltech/qt/core/QObject.html#event(com.trolltech.qt.core.QEvent)">event()</a> function. <p>This function does not handle the event itself; based on the type of event delivered, it calls an event handler for that specific type of event, and sends a response based on whether the event was accepted or ignored. <p>Some events, such as <a href="../../../com/trolltech/qt/gui/QMouseEvent.html">QMouseEvent</a> and <a href="../../../com/trolltech/qt/gui/QKeyEvent.html">QKeyEvent</a>, come from the window system; some, such as <a href="../../../com/trolltech/qt/core/QTimerEvent.html">QTimerEvent</a>, come from other sources; some come from the application itself.<a name="event-types"><h2>Event Types</h2> Most events types have special classes, notably <a href="../../../com/trolltech/qt/gui/QResizeEvent.html">QResizeEvent</a>, <a href="../../../com/trolltech/qt/gui/QPaintEvent.html">QPaintEvent</a>, <a href="../../../com/trolltech/qt/gui/QMouseEvent.html">QMouseEvent</a>, <a href="../../../com/trolltech/qt/gui/QKeyEvent.html">QKeyEvent</a>, and <a href="../../../com/trolltech/qt/gui/QCloseEvent.html">QCloseEvent</a>. Each class subclasses <a href="../../../com/trolltech/qt/core/QEvent.html">QEvent</a> and adds event-specific functions. For example, <a href="../../../com/trolltech/qt/gui/QResizeEvent.html">QResizeEvent</a> adds <a href="../../../com/trolltech/qt/gui/QResizeEvent.html#size()">size()</a> and <a href="../../../com/trolltech/qt/gui/QResizeEvent.html#oldSize()">oldSize()</a> to enable widgets to discover how their dimensions have been changed. <p>Some classes support more than one actual event type. <a href="../../../com/trolltech/qt/gui/QMouseEvent.html">QMouseEvent</a> supports mouse button presses, double-clicks, moves, and other related operations. <p>Each event has an associated type, defined in <a href="../../../com/trolltech/qt/core/QEvent.Type.html">QEvent::Type</a>, and this can be used as a convenient source of run-time type information to quickly determine which subclass a given event object was constructed from. <p>Since programs need to react in varied and complex ways, Qt's event delivery mechanisms are flexible. The documentation for <a href="../../../com/trolltech/qt/core/QCoreApplication.html#notify(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::notify()</a> concisely tells the whole story; the Qt Quarterly article Another Look at Events rehashes it less concisely. Here we will explain enough for 95% of applications.<a name="event-handlers"><h2>Event Handlers</h2> The normal way for an event to be delivered is by calling a virtual function. For example, <a href="../../../com/trolltech/qt/gui/QPaintEvent.html">QPaintEvent</a> is delivered by calling <a href="../../../com/trolltech/qt/gui/QWidget.html#paintEvent(com.trolltech.qt.gui.QPaintEvent)">QWidget::paintEvent()</a>. This virtual function is responsible for reacting appropriately, normally by repainting the widget. If you do not perform all the necessary work in your implementation of the virtual function, you may need to call the base class's implementation. <p>For example, the following code handles left mouse button clicks on a custom checkbox widget while passing all other button clicks to the base <a href="../../../com/trolltech/qt/gui/QCheckBox.html">QCheckBox</a> class: <pre class="snippet">
        public void mousePressEvent(QMouseEvent event)
        {
            if (event.button().equals(Qt.MouseButton.LeftButton)) {
                // handle left mouse button here
            } else {
                // pass on other buttons to base class
                super.mousePressEvent(event);
            }
        }
        </pre> If you want to replace the base class's function, you must implement everything yourself. However, if you only want to extend the base class's functionality, then you implement what you want and call the base class to obtain the default behavior for any cases you do not want to handle. <p>Occasionally, there isn't such an event-specific function, or the event-specific function isn't sufficient. The most common example involves <b>Tab</b> key presses. Normally, <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> intercepts these to move the keyboard focus, but a few widgets need the <b>Tab</b> key for themselves. <p>These objects can reimplement <a href="../../../com/trolltech/qt/core/QObject.html#event(com.trolltech.qt.core.QEvent)">QObject::event()</a>, the general event handler, and either do their event handling before or after the usual handling, or they can replace the function completely. A very unusual widget that both interprets <b>Tab</b> and has an application-specific custom event might contain the following <a href="../../../com/trolltech/qt/core/QObject.html#event(com.trolltech.qt.core.QEvent)">event()</a> function: <pre class="snippet">
        public boolean event(QEvent event)
        {
            if (event.type().equals(QEvent.EventType.KeyPress)) {
                QKeyEvent ke = (QKeyEvent) event;
                if (ke.key().equals(Qt.Key.Key_Tab)) {
                    // special tab handling here
                    return true;
                }
            } else if (event.type() == MyCustomEventType) {
                MyCustomEvent myEvent = static_cast&lt;MyCustomEvent &gt;(event);
                // custom event handling here
                return true;
            }

            return super.event(event);
        }
        </pre> Note that <a href="../../../com/trolltech/qt/gui/QWidget.html#event(com.trolltech.qt.core.QEvent)">QWidget::event()</a> is still called for all of the cases not handled, and that the return value indicates whether an event was dealt with; a <tt>true</tt> value prevents the event from being sent on to other objects.<a name="event-filters"><h2>Event Filters</h2> Sometimes an object needs to look at, and possibly intercept, the events that are delivered to another object. For example, dialogs commonly want to filter key presses for some widgets; for example, to modify <b>Return</b>-key handling. <p>The <a href="../../../com/trolltech/qt/core/QObject.html#installEventFilter(com.trolltech.qt.core.QObject)">QObject::installEventFilter()</a> function enables this by setting up an event filter, causing a nominated filter object to receive the events for a target object in its <a href="../../../com/trolltech/qt/core/QObject.html#eventFilter(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QObject::eventFilter()</a> function. An event filter gets to process events before the target object does, allowing it to inspect and discard the events as required. An existing event filter can be removed using the <a href="../../../com/trolltech/qt/core/QObject.html#removeEventFilter(com.trolltech.qt.core.QObject)">QObject::removeEventFilter()</a> function. <p>When the filter object's <a href="../../../com/trolltech/qt/core/QObject.html#eventFilter(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">eventFilter()</a> implementation is called, it can accept or reject the event, and allow or deny further processing of the event. If all the event filters allow further processing of an event (by each returning <tt>false</tt>), the event is sent to the target object itself. If one of them stops processing (by returning <tt>true</tt>), the target and any later event filters do not get to see the event at all. <pre class="snippet">
    public boolean eventFilter(QObject object, QEvent event)
    {
        if (object.equals(target)  && event.type().equals(QEvent.Type.KeyPress)) {
            QKeyEvent keyEvent = (QKeyEvent) event;
            if (keyEvent.key() == Qt.Key.Key_Tab.value()) {
                // Special tab handling
                return true;
            } else
                return false;
        }
        return false;
    }
    </pre> The above code shows another way to intercept <b>Tab</b> key press events sent to a particular target widget. In this case, the filter handles the relevant events and returns <tt>true</tt> to stop them from being processed any further. All other events are ignored, and the filter returns <tt>false</tt> to allow them to be sent on to the target widget, via any other event filters that are installed on it. <p>It is also possible to filter all events for the entire application, by installing an event filter on the <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> or <a href="../../../com/trolltech/qt/core/QCoreApplication.html">QCoreApplication</a> object. Such global event filters are called before the object-specific filters. This is very powerful, but it also slows down event delivery of every single event in the entire application; the other techniques discussed should generally be used instead.<a name="sending-events"><h2>Sending Events</h2> Many applications want to create and send their own events. You can send events in exactly the same ways as Qt's own event loop by constructing suitable event objects and sending them with <a href="../../../com/trolltech/qt/core/QCoreApplication.html#sendEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::sendEvent()</a> and <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::postEvent()</a>. <p><a href="../../../com/trolltech/qt/core/QCoreApplication.html#sendEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">sendEvent()</a> processes the event immediately. When it returns, the event filters and/or the object itself have already processed the event. For many event classes there is a function called isAccepted() that tells you whether the event was accepted or rejected by the last handler that was called. <p><a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">postEvent()</a> posts the event on a queue for later dispatch. The next time Qt's main event loop runs, it dispatches all posted events, with some optimization. For example, if there are several resize events, they are are compressed into one. The same applies to paint events: <a href="../../../com/trolltech/qt/gui/QWidget.html#update()">QWidget::update()</a> calls <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">postEvent()</a>, which eliminates flickering and increases speed by avoiding multiple repaints. <p><a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">postEvent()</a> is also used during object initialization, since the posted event will typically be dispatched very soon after the initialization of the object is complete. When implementing a widget, it is important to realise that events can be delivered very early in its lifetime so, in its constructor, be sure to initialize member variables early on, before there's any chance that it might receive an event. <p>To create events of a custom type, you need to define an event number, which must be greater than <a href="../../../com/trolltech/qt/core/QEvent.Type.html">QEvent::User</a>, and you may need to subclass <a href="../../../com/trolltech/qt/core/QEvent.html">QEvent</a> in order to pass specific information about your custom event. See the <a href="../../../com/trolltech/qt/core/QEvent.html">QEvent</a> documentation for further details.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
