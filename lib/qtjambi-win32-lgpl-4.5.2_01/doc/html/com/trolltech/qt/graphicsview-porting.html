<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Porting to Graphics View</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Porting to Graphics View</h1></center><p>[Previous: <a href="porting4-designer.html">Porting .ui Files to Qt 4</a>][<a href="porting.html">Porting Guides</a>][Next: <a href="qt3to4.html">qt3to4 - The Qt 3 to 4 Porting Tool</a>]<p>Hints and tips to assist with porting canvas applications to the Graphics View framework.<a name="qgraphicsview-graphicsview-porting-graphics-canvas"> Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation. Graphics View was introduced in Qt 4.2, replacing its predecessor, <a href="porting4.html">QCanvas</a>. For more on Graphics View, see <a href="graphicsview.html">The Graphics View Framework</a>. <p>This document walks through the steps needed, class by class and function by function, to port a <a href="porting4.html">QCanvas</a> application to Graphics View. <ul><li> <a href="#introduction">Introduction</a></li><li> <a href="#porting-from-q3canvas">Porting from Q3Canvas</a></li> <ul><li> <a href="#porting-table">Porting table</a></li><li> <a href="#porting-scenes-with-tiles">Porting scenes with tiles</a></li></ul><li> <a href="#porting-from-q3canvasview">Porting from Q3CanvasView</a></li> <ul><li> <a href="#porting-table">Porting table</a></li><li> <a href="#other-differences">Other differences</a></li></ul><li> <a href="#porting-from-q3canvasitem">Porting from Q3CanvasItem</a></li> <ul><li> <a href="#q3canvaspolygonalitem">Q3CanvasPolygonalItem</a></li><li> <a href="#q3canvasellipse">Q3CanvasEllipse</a></li><li> <a href="#q3canvasline">Q3CanvasLine</a></li><li> <a href="#q3canvaspolygon">Q3CanvasPolygon</a></li><li> <a href="#q3canvasspline">Q3CanvasSpline</a></li><li> <a href="#q3canvasrectangle">Q3CanvasRectangle</a></li><li> <a href="#q3canvassprite">Q3CanvasSprite</a></li> <ul><li> <a href="#q3canvaspixmap-q3canvaspixmaparray">Q3CanvasPixmap, Q3CanvasPixmapArray</a></li></ul><li> <a href="#q3canvastext">Q3CanvasText</a></li><li> <a href="#q3canvasitemlist">Q3CanvasItemList</a></li></ul><li> <a href="#other-resources">Other Resources</a></li></ul> Qt 4.2 provides two complete examples of Q3Canvas applications ported to Graphics View: <ul><li> <a href="graphicsview-portedcanvas.html">Ported Canvas Example</a>, the canvas example from Qt 3.</li><li> <a href="graphicsview-portedasteroids.html">Ported Asteroids Example</a>, the Asteroids game from the Qt 3 demo.</li></ul><a name="introduction"><h2>Introduction</h2> Conceptually, the Graphics View classes from Qt 4 and the Canvas classes from Qt 3 provide similar functionality using a similar design. Instead of "canvas", we use the term "scene". Otherwise, the class names and functions are almost the same as in Qt 3. The easiest classes to port will be <a href="porting4.html">QCanvas</a> and QCanvasView. Experience shows that most time is spent porting the item classes, depending on the complexity of the QCanvasItem classes you have been using before. <p>This porting guide will assume you have already ported your application to Qt 4, by making use of Q3Canvas. If you have not done so already, as a first step, run the <a href="qt3to4.html">qt3to4</a> tool on your project. This tool will automate the most tedious part of the porting effort. <p>Some additional steps are usually required before your application will compile and run. You can read more about the porting process in <a href="porting4.html">Porting to Qt 4</a>.<a name="porting-from-q3canvas"><h2>Porting from Q3Canvas</h2> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> is the closest equivalent to Q3Canvas. There are some noticable differences in this new API: Whereas the Q3Canvas classes use integer precision, <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> is entirely based on double coordinates, with graphical primitives such as <a href="../../../com/trolltech/qt/core/QPointF.html">QPointF</a> instead of <a href="../../../com/trolltech/qt/core/QPoint.html">QPoint</a>, <a href="../../../com/trolltech/qt/core/QRectF.html">QRectF</a> instead of <a href="../../../com/trolltech/qt/core/QRect.html">QRect</a>, and <a href="../../../com/trolltech/qt/gui/QPolygonF.html">QPolygonF</a> and <a href="../../../com/trolltech/qt/gui/QPainterPath.html">QPainterPath</a>. The canvas area is defined by a scene rectangle, allowing negative coordinates, as opposed to Q3Canvas, which only defines a size (<a href="../../../com/trolltech/qt/core/QSize.html">QSize</a>), and whose top-left corner is always (0, 0). <p>In addition, there is no explicit support for canvas tiles anymore; see <a href="graphicsview-porting.html#porting-scenes-with-tiles">Porting scenes with tiles</a> for more information. The chunks-based indexing system has been replaced with an implicitly maintained internal BSP tree.<a name="porting-table"><h3>Porting table</h3> <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3Canvas</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3Canvas::Q3Canvas()</td><td> There is no <a href="../../../com/trolltech/qt/gui/QPixmap.html">QPixmap</a> based constructor, and the concept of tiles is gone. You can use <a href="../../../QGraphicsScene.html#backgroundBrush()">QGraphicsScene::backgroundBrush</a> to set a brush pattern for the background, or reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsScene::drawBackground()</a> in a <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> subclass (see <a href="graphicsview-porting.html#porting-scenes-with-tiles">Porting scenes with tiles</a>). In addition, the <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> geometry is provided as a full <a href="../../../com/trolltech/qt/core/QRectF.html">QRectF</a>. Instead of Q3Canvas(int width, int height), you can use <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>(int top, int left, int width, int height).</td></tr><tr valign="top" class="odd"><td> Q3Canvas::allItems()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#items()">QGraphicsScene::items()</a> returns a list of all items on the scene.</td></tr><tr valign="top" class="even"><td> Q3Canvas::backgroundColor()</td><td> You can assign a color for the background through the <a href="../../../QGraphicsScene.html#backgroundBrush()">QGraphicsScene::backgroundBrush</a> or <a href="../../../QGraphicsView.html#backgroundBrush()">QGraphicsView::backgroundBrush</a> properties.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::backgroundPixmap()</td><td> You can set a tiled pixmap for the background through <a href="../../../QGraphicsScene.html#backgroundBrush()">QGraphicsScene::backgroundBrush</a> or <a href="../../../QGraphicsView.html#backgroundBrush()">QGraphicsView::backgroundBrush</a>. For more control on the pixmap positioning, you can reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsScene::drawBackground()</a> or <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsView::drawBackground()</a>.</td></tr><tr valign="top" class="even"><td> Q3Canvas::chunkSize()</td><td> The closest equivalent to the chunks size in Q3Canvas is the depth of <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>'s BSP tree. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> assigns a depth automatically, and the size of each scene segment depends on this depth, and <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#sceneRect()">QGraphicsScene::sceneRect()</a>. See <a href="../../../QGraphicsScene.html#itemIndexMethod()">QGraphicsScene::itemIndexMethod</a>.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::collisions()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> provides several means to detect item collisions. The <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#items()">QGraphicsScene::items()</a> overloads return items that collide with a point, a rectangle, a polygon, or an arbitrary vector path (<a href="../../../com/trolltech/qt/gui/QPainterPath.html">QPainterPath</a>). You can also call <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#collidingItems(com.trolltech.qt.gui.QGraphicsItemInterface)">QGraphicsScene::collidingItems()</a> to determine collision with an item.</td></tr><tr valign="top" class="even"><td> Q3Canvas::drawArea()</td><td> The <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRectF)">QGraphicsScene::render()</a> function provides the original behavior Q3Canvas::drawArea(). In addition, you can pass a source rectangle for rendering only parts of the scene, and a destination rectangle for rendering onto designated area of the destination device. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRectF)">QGraphicsScene::render()</a> can optionally transform the source rectangle to fit into the destination rectangle. See <a href="graphicsview.html">Printing</a></td></tr><tr valign="top" class="odd"><td> Q3Canvas::onCanvas()</td><td> The is no equivalent to this function in Graphics View. However, you can combine <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#sceneRect()">QGraphicsScene::sceneRect()</a> and <a href="../../../com/trolltech/qt/core/QRectF.html#intersects(com.trolltech.qt.core.QRectF)">QRectF::intersects()</a>: <pre class="snippet">
item-&gt;scene().sceneRect().intersects(item-&gt;sceneBoundingRect());
</pre></td></tr><tr valign="top" class="even"><td> Q3Canvas::rect()</td><td> The equivalent, <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#sceneRect()">QGraphicsScene::sceneRect()</a>, returns a <a href="../../../com/trolltech/qt/core/QRectF.html">QRectF</a> (double precision coordinates). Its top-left corner can be an arbitrary coordinate (Q3Canvas::rect().topLeft() is always (0, 0)).</td></tr><tr valign="top" class="odd"><td> Q3Canvas::resize()</td><td> You can call QGraphicsScene::setSceneRect(0, 0, width, height) instead.</td></tr><tr valign="top" class="even"><td> Q3Canvas::retune()</td><td> See <a href="../../../QGraphicsScene.html#itemIndexMethod()">QGraphicsScene::itemIndexMethod</a>. You can tune the indexing by setting a suitable sceneRect(). The optimal depth of <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>'s BSP tree is determined automatically.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::setAdvancePeriod()</td><td> There is no concept of an advance period in the new API; instead, you can connect QTimer::timeout() to the <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#advance()">QGraphicsScene::advance()</a> slot to obtain similar functionality. This will cause all items' <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#advance(int)">QGraphicsItem::advance()</a> function to be called. See also <a href="../../../com/trolltech/qt/gui/QGraphicsItemAnimation.html">QGraphicsItemAnimation</a>.</td></tr><tr valign="top" class="even"><td> Q3Canvas::setAllChanged()</td><td> You can call <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#update()">QGraphicsScene::update()</a> with no arguments.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::setChanged()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#update()">QGraphicsScene::update()</a> will trigger a repaint of the whole scene, or parts of the scene.</td></tr><tr valign="top" class="even"><td> Q3Canvas::setDoubleBuffering()</td><td> Q3Canvas' double buffering enabled cacheing of the scene contents in device (i.e., viewport) coordinates. This cache layer has been moved to the view instead; you can cache <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>'s background through <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#setCacheMode(com.trolltech.qt.gui.QGraphicsView.CacheModeFlag[])">QGraphicsView::setCacheMode()</a>. <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#resetCachedContent()">QGraphicsView::resetCachedContent()</a> will reset the areas of the cache that has changed.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::tile()</td><td> See <a href="graphicsview-porting.html#porting-scenes-with-tiles">Porting scenes with tiles</a>.</td></tr><tr valign="top" class="even"><td> Q3Canvas::setTiles()</td><td> See <a href="graphicsview-porting.html#porting-scenes-with-tiles">Porting scenes with tiles</a>.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::setUnchanged()</td><td> There is no equivalent in Graphics View. This call can usually be removed with no side effects.</td></tr><tr valign="top" class="even"><td> Q3Canvas::setUpdatePeriod()</td><td> There is no concept of an update period in the new API; instead, you can connect QTimer::timeout() to the <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#update()">QGraphicsScene::update()</a> slot to obtain similar functionality. See also <a href="../../../com/trolltech/qt/gui/QGraphicsItemAnimation.html">QGraphicsItemAnimation</a>.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::size()</td><td> <tt>QGraphicsScene::sceneRect().size()</tt><a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#sceneRect()">QGraphicsScene::sceneRect()</a>size() returns a <a href="../../../com/trolltech/qt/core/QSizeF.html">QSizeF</a>, with double precision coordinates.</td></tr><tr valign="top" class="even"><td> Q3Canvas::validChunk()</td><td> To determine if an area is inside the scene area or not, you can combine <a href="../../../com/trolltech/qt/core/QRectF.html#intersects(com.trolltech.qt.core.QRectF)">QRectF::intersects()</a> with <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#sceneRect()">QGraphicsScene::sceneRect()</a>.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::resized()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> emits sceneRectChanged() whenever the scene rect changes.</td></tr><tr valign="top" class="even"><td> Q3Canvas::drawBackground()</td><td> You can reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsScene::drawBackground()</a> to render the scene background. You can also reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsView::drawBackground()</a> to override this background if you need different backgrounds for different views.</td></tr><tr valign="top" class="odd"><td> Q3Canvas::drawForeground()</td><td> You can reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#drawForeground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsScene::drawForeground()</a> to render the scene foreground. You can also reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawForeground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsView::drawForeground()</a> to override this foreground if you need different foregrounds for different views.</td></tr></table><a name="porting-scenes-with-tiles"><h3>Porting scenes with tiles</h3> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> does not provide an API for tiles. However, you can achieve similar behavior by drawing pixmaps in a reimplementation of <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsScene::drawBackground()</a>. <p>Q3Canvas' tile support is based on providing one pixmap containing tiles of a fixed width and height, and then accessing them (reading and replacing tiles) by index. The tiles in the pixmap are arranged from the left to right, top to bottom. <table align="center" border="0" cellpadding="2" cellspacing="1"><tr valign="top" class="even"><td> 0</td><td> 1</td><td> 2</td><td> 3</td></tr><tr valign="top" class="odd"><td> 4</td><td> 5</td><td> 6</td><td> 7</td></tr></table> With Graphics View, this pixmap can be stored as a member of a subclass of <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>. The three main functions that make out the public tile API can then be declared as new members of this class. Here is one example of how to implement tile support: <pre class="snippet">
class TileScene : public QGraphicsScene
{
public:
    ...

    void setTiles(const QPixmap &pixmap, int h, int v,
                  int tileHeight, int tileWidth);
    void setTile(int x, int y, int tilenum);

private:
    QRect tileRect(int x, int y) const;
    QRect tileRect(int tileNum) const;

    QVector&lt;QVector&lt;int&gt; &gt; tiles;
    QPixmap tilePixmap;
    int tileW, tileH;
    int hTiles, vTiles;
};
</pre> Depending on how your scene uses tiles, you may be able to simplify this approach. In this example, we will try to mimic the behavior of the Q3Canvas functions. <p>We start by creating a subclass of <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> ("TileScene"). In this class, we declare two of the tile functions from Q3Canvas, and we then add two helper function that returns the rectangle for a certain tile in our tile pixmap. We will use a two-dimensional vector of ints to keep track of what tiles should be used at what parts of the scene. <pre class="snippet">
void TileScene::setTiles(const QPixmap &pixmap, int h, int v,
                         int tileHeight, int tileWidth)
{
    tilePixmap = pixmap;
    tileW = tileWidth;
    tileH = tileHeight;
    hTiles = h;
    vTiles = v;

    tiles.resize(v);
    for (int y = 0; y &lt; v; ++y)
        tiles[y].resize(h);
}
</pre> In setTiles(), we store the pixmap and tile properties as members of the class. Then we resize the tiles vector to match the width and height of our tile grid. <pre class="snippet">
void TileScene::setTile(int x, int y, int tilenum)
{
    tiles[y][x] = tilenum;
    update(tileRect(x, y));
}
</pre> The setTile() function updates the tiles index, and then updates the corresponding rect in the scene by calling tileRect(). <pre class="snippet">
QRect TileScene::tileRect(int x, int y) const
{
    return QRect(x * tileW, y * tileH, tileW, tileH);
}
</pre> The first tileRect() function returns a <a href="../../../com/trolltech/qt/core/QRect.html">QRect</a> for the tile at position (x, y). <pre class="snippet">
QRect TileScene::tileRect(int tileNum) const
{
    int numHTiles = tilePixmap.width() / tileW;
    int numVTiles = tilePixmap.height() / tileH;
    return tileRect(tileNum % numHTiles, tileNum / numHTiles);
}
</pre> The second tileRect() function returns a <a href="../../../com/trolltech/qt/core/QRect.html">QRect</a> for a tile number. With these functions in place, we can implement the drawBackground() function. <pre class="snippet">
void drawBackground(QPainter *painter, const QRectF &exposed)
{
    for (int y = 0; y &lt; vTiles; ++y) {
        for (int x = 0; x &lt; hTiles; ++x) {
            QRect destRect = tileRect(x, y);
            if (exposed.intersects(destRect)) {
                painter-&gt;drawPixmap(destRect, tilePixmap,
                                    tileRect(tiles[y][x]));
            }
        }
    }
}
</pre> In drawBackground(), we redraw all tiles that have been exposed by intersecting each tile rect with the exposed background area.<a name="porting-from-q3canvasview"><h2>Porting from Q3CanvasView</h2> The closest equivalent to Q3CanvasView in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>. In most cases, this is the easiest class to port. In addition to providing all of Q3CanvasView's functionality, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> includes some useful new features. You can read more about this in <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>'s documentation.<a name="porting-table"><h3>Porting table</h3> <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasView</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasView::Q3CanvasView()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> provides the same constructors as Q3CanvasView, but without the name and flags arguments. You can set the name by calling setObjectName(), and the flags by calling <a href="../../../com/trolltech/qt/gui/QWidget.html#setWindowFlags(com.trolltech.qt.core.Qt.WindowType[])">setWindowFlags()</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasView::canvas()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#scene()">QGraphicsView::scene()</a> returns the scene that is currently associated with the view. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> also provides the opposite function, <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#views()">QGraphicsScene::views()</a>, which returns a list of views observing the scene.</td></tr><tr valign="top" class="even"><td> Q3CanvasView::inverseWorldMatrix()</td><td> You can call <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#matrix()">QGraphicsView::matrix()</a> and <a href="../../../com/trolltech/qt/gui/QMatrix.html#inverted()">QMatrix::inverted()</a>. <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapToScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapToScene()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapFromScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapFromScene()</a> allow transforming of viewport shapes to scene shapes, and vice versa.</td></tr><tr valign="top" class="odd"><td> Q3CanvasView::setCanvas()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#setScene(com.trolltech.qt.gui.QGraphicsScene)">QGraphicsView::setScene()</a>.</td></tr><tr valign="top" class="even"><td> Q3CanvasView::setWorldMatrix()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#setMatrix(com.trolltech.qt.gui.QMatrix)">QGraphicsView::setMatrix()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#rotate(double)">QGraphicsView::rotate()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#scale(double, double)">QGraphicsView::scale()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#shear(double, double)">QGraphicsView::shear()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#translate(double, double)">QGraphicsView::translate()</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasView::worldMatrix()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#matrix()">QGraphicsView::matrix()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasView::drawContents()</td><td> The <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawBackground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsView::drawBackground()</a> function draws the background, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawItems(com.trolltech.qt.gui.QPainter, com.trolltech.qt.gui.QGraphicsItemInterface[], com.trolltech.qt.gui.QStyleOptionGraphicsItem[])">QGraphicsView::drawItems()</a> draws the items, and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawForeground(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF)">QGraphicsView::drawForeground()</a> draws the foreground of the scene in scene coordinates. You can also reimplement these functions in <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>.</td></tr></table><a name="other-differences"><h3>Other differences</h3> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> can cache the visible contents of the scene, similar to how Q3Canvas::setDoubleBuffering() could cache the entire scene contents. You can call <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#setCacheMode(com.trolltech.qt.gui.QGraphicsView.CacheModeFlag[])">QGraphicsView::setCacheMode()</a> to configure cacheing, and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#resetCachedContent()">QGraphicsView::resetCachedContent()</a> invalidates the cache. <p>For improved navigation support, you can set a resize or transformation anchor through <a href="../../../QGraphicsView.html#resizeAnchor()">QGraphicsView::resizeAnchor</a> and <a href="../../../QGraphicsView.html#transformationAnchor()">QGraphicsView::transformationAnchor</a>. This allows you to easily rotate and zoom the view while keeping the center fixed, or zooming towards the position under the mouse cursor. In addition, if you set the <a href="../../../QGraphicsView.html#dragMode()">QGraphicsView::dragMode</a> of the view, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> will provide rubber band selection or click-and-pull navigation using the <a href="../../../com/trolltech/qt/core/Qt.CursorShape.html">OpenHandCursor</a> and <a href="../../../com/trolltech/qt/core/Qt.CursorShape.html">ClosedHandCursor</a> cursors.<a name="porting-from-q3canvasitem"><h2>Porting from Q3CanvasItem</h2> The closest equivalent to Q3CanvasItem in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>. Deriving from this class is very common, and because of that, porting from Q3CanvasItem often involves more work than Q3Canvas and Q3CanvasView. <p>Q3CanvasItem has become easier to use, easier to subclass, and more powerful with <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>. The key difference from Q3CanvasItem lies in event propagation and item groups, but you will also find several convenient new features, such as support for tooltips, cursors, item transformation and drag and drop. You can read all about <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> in its own class documentation. <p>This section starts with a table that shows how to port each function from Q3CanvasItem to <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>. Immediately after that, each of Q3CanvasItem's standard subclasses have a section of their own. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasItem</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasItem::advance()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#advance(int)">QGraphicsItem::advance()</a> is provided for compatibility. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#advance()">QGraphicsScene::advance()</a> calls <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#advance(int)">QGraphicsItem::advance()</a> for all items. See also <a href="../../../com/trolltech/qt/core/QTimeLine.html">QTimeLine</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItemAnimation.html">QGraphicsItemAnimation</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::animated()</td><td> No equivalent; all items are advanced by <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#advance()">QGraphicsScene::advance()</a>.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::boundingRectAdvanced()</td><td> No equivalent. You can translate <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#boundingRect()">QGraphicsItem::boundingRect()</a> instead (see <a href="../../../com/trolltech/qt/core/QRectF.html#translate(com.trolltech.qt.core.QPointF)">QRectF::translate()</a>).</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::canvas()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#scene()">QGraphicsItem::scene()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasItem::collidesWith()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#collidesWithItem(com.trolltech.qt.gui.QGraphicsItemInterface)">QGraphicsItem::collidesWithItem()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#collidesWithPath(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::collidesWithPath()</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::collisions()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#collidingItems()">QGraphicsItem::collidingItems()</a> returns a list of all items that collide with an item. You can specify whether you want fast, rough estimate collision between bounding rectangles, or the slower, more accurate shapes.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::draw()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#paint(com.trolltech.qt.gui.QPainter, com.trolltech.qt.gui.QStyleOptionGraphicsItem)">QGraphicsItem::paint()</a>. See also <a href="../../../com/trolltech/qt/gui/QStyleOptionGraphicsItem.html">QStyleOptionGraphicsItem</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#drawItems(com.trolltech.qt.gui.QPainter, com.trolltech.qt.gui.QGraphicsItemInterface[], com.trolltech.qt.gui.QStyleOptionGraphicsItem[])">QGraphicsScene::drawItems()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#drawItems(com.trolltech.qt.gui.QPainter, com.trolltech.qt.gui.QGraphicsItemInterface[], com.trolltech.qt.gui.QStyleOptionGraphicsItem[])">QGraphicsView::drawItems()</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::hide()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#hide()">QGraphicsItem::hide()</a> or <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setVisible(boolean)">QGraphicsItem::setVisible()</a>. <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>s are visible by default; Q3CanvasItems, however, are not.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::isActive()</td><td> No equivalent. To achieve similar behavior, you can add this property in a custom subclass of <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::isVisible()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#isVisible()">QGraphicsItem::isVisible()</a>. <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>s are visible by default; Q3CanvasItems, however, are not.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::move()</td><td> You can call <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setPos(com.trolltech.qt.core.QPointF)">QGraphicsItem::setPos()</a> to change the position of the item.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::rtti()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#type()">QGraphicsItem::type()</a> and qgraphicsitem_cast().</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::setActive()</td><td> No equivalent.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::setAnimated()</td><td> No equivalent; all items are by default "animated" (i.e., <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#advance()">QGraphicsScene::advance()</a> advances all items on the scene).</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::setCanvas()</td><td> You can call <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#addItem(com.trolltech.qt.gui.QGraphicsItemInterface)">QGraphicsScene::addItem()</a>, or pass a pointer to the canvas to <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>'s constructor.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::setVelocity()</td><td> No equivalent. You can add x and y velocity as member data of your class, and call QGraphicsItem::moveBy(x, y) from inside <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#advance(int)">QGraphicsItem::advance()</a>. See also <a href="../../../com/trolltech/qt/core/QTimeLine.html">QTimeLine</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItemAnimation.html">QGraphicsItemAnimation</a>.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::setVisible()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setVisible(boolean)">QGraphicsItem::setVisible()</a>. <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>s are visible by default; Q3CanvasItems, however, are not.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::setX()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setPos(com.trolltech.qt.core.QPointF)">QGraphicsItem::setPos()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasItem::setY()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setPos(com.trolltech.qt.core.QPointF)">QGraphicsItem::setPos()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::setXVelocity()</td><td> No equivalent.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::setYVelocity()</td><td> No equivalent.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::setZ()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setZValue(double)">QGraphicsItem::setZValue()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasItem::show()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#show()">QGraphicsItem::show()</a> or <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setVisible(boolean)">QGraphicsItem::setVisible()</a>. <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>s are visible by default; Q3CanvasItems, however, are not.</td></tr><tr valign="top" class="odd"><td> Q3CanvasItem::xVelocity()</td><td> No equivalent.</td></tr><tr valign="top" class="even"><td> Q3CanvasItem::yVelocity()</td><td> No equivalent.</td></tr></table> Note that some virtual functions that have passed on to <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> have lost their virtuality. An example is Q3CanvasItem::moveBy(), which was often used to track movement of items. In this case, the virtual <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#itemChange(com.trolltech.qt.gui.QGraphicsItem.GraphicsItemChange, java.lang.Object)">QGraphicsItem::itemChange()</a> has taken over as a substitute.<a name="q3canvaspolygonalitem"><h3>Q3CanvasPolygonalItem</h3> The closest equivalent to Q3CanvasPolygonalItem in Graphics View is called <a href="../../../com/trolltech/qt/gui/QAbstractGraphicsShapeItem.html">QAbstractGraphicsShapeItem</a>. Unlike Q3CanvasPolygonalItem, it does not define area points (Q3CanvasPolygonalItem::areaPoints()); instead, each item's geometry is stored as a member of the subclasses. <p>The Q3CanvasPolygonalItem::drawShape() function is no longer available; instead, you can set the brush and pen from inside <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#paint(com.trolltech.qt.gui.QPainter, com.trolltech.qt.gui.QStyleOptionGraphicsItem)">QGraphicsItem::paint()</a>. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasPolygonalItem</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QAbstractGraphicsShapeItem.html">QAbstractGraphicsShapeItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasPolygonalItem::areaPoints()</td><td> No equivalent; each item's geometry is stored in the respective subclass.</td></tr><tr valign="top" class="odd"><td> Q3CanvasPolygonalItem::areaPointsAdvanced()</td><td> No equivalent; you can use <a href="../../../com/trolltech/qt/gui/QPolygonF.html#translate(com.trolltech.qt.core.QPointF)">QPolygonF::translate()</a> or QPainterPath::translate() instead.</td></tr><tr valign="top" class="even"><td> Q3CanvasPolygonalItem::drawShape()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#paint(com.trolltech.qt.gui.QPainter, com.trolltech.qt.gui.QStyleOptionGraphicsItem)">QGraphicsItem::paint()</a>. You can set the pen and brush from inside this function.</td></tr><tr valign="top" class="odd"><td> Q3CanvasPolygonalItem::invalidate()</td><td> Call <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#prepareGeometryChange()">QGraphicsItem::prepareGeometryChange()</a> before changing the item's geometry.</td></tr><tr valign="top" class="even"><td> Q3CanvasPolygonalItem::isValid()</td><td> No equivalent; items' geometry is always in a valid state.</td></tr><tr valign="top" class="odd"><td> Q3CanvasPolygonalItem::winding()</td><td> This function is only useful for polygon items and path items; see <a href="../../../com/trolltech/qt/gui/QGraphicsPolygonItem.html#fillRule()">QGraphicsPolygonItem::fillRule()</a>, and <a href="../../../com/trolltech/qt/gui/QPainterPath.html#fillRule()">QPainterPath::fillRule()</a> for <a href="../../../com/trolltech/qt/gui/QGraphicsPathItem.html">QGraphicsPathItem</a>.</td></tr></table><a name="q3canvasellipse"><h3>Q3CanvasEllipse</h3> The closest equivalent to Q3CanvasEllipse in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html">QGraphicsEllipseItem</a>. The most noticable difference to <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html">QGraphicsEllipseItem</a> is that the ellipse is not longer drawn centered around its position; rather, it is drawn using a bounding <a href="../../../com/trolltech/qt/core/QRectF.html">QRectF</a>, just like <a href="../../../com/trolltech/qt/gui/QPainter.html#drawEllipse(com.trolltech.qt.core.QPoint, int, int)">QPainter::drawEllipse()</a>. <p>For compatibility, you may want to shift the ellipse up and to the left to keep the ellipse centered. Example: <pre class="snippet">
    // Before
    Q3CanvasEllipse ellipse(10, 10);

    // After
    QGraphicsEllipseItem ellipse(-5, -5, 10, 10);
</pre> Note: <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html">QGraphicsEllipseItem</a> uses <a href="../../../com/trolltech/qt/gui/QAbstractGraphicsShapeItem.html#pen()">QAbstractGraphicsShapeItem::pen()</a> for outlines, whereas Q3CanvasEllipse did not use Q3CanvasPolygonalItem::pen(). <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasEllipse</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html">QGraphicsEllipseItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasEllipse::angleLength()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html#spanAngle()">QGraphicsEllipseItem::spanAngle()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasEllipse::angleStart()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html#startAngle()">QGraphicsEllipseItem::startAngle()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasEllipse::setAngles()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html#setStartAngle(int)">QGraphicsEllipseItem::setStartAngle()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html#setSpanAngle(int)">QGraphicsEllipseItem::setSpanAngle()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasEllipse::setSize()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html#setRect(com.trolltech.qt.core.QRectF)">QGraphicsEllipseItem::setRect()</a></td></tr></table><a name="q3canvasline"><h3>Q3CanvasLine</h3> The closest equivalent to Q3CanvasLine in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsLineItem.html">QGraphicsLineItem</a>. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasLine</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsLineItem.html">QGraphicsLineItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasLine::endPoint()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsLineItem.html#line()">QGraphicsLineItem::line()</a> and <a href="../../../com/trolltech/qt/gui/QLineF.html#p2()">QLineF::p2()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasLine::setPoints()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsLineItem.html#setLine(com.trolltech.qt.gui.QLineF)">QGraphicsLineItem::setLine()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasLine::startPoint()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsLineItem.html#line()">QGraphicsLineItem::line()</a> and <a href="../../../com/trolltech/qt/gui/QLineF.html#p1()">QLineF::p1()</a></td></tr></table><a name="q3canvaspolygon"><h3>Q3CanvasPolygon</h3> The closest equivalent to Q3CanvasPolygon in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsPolygonItem.html">QGraphicsPolygonItem</a>. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasPolygon</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsPolygonItem.html">QGraphicsPolygonItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasPolygon::areaPoints()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsPolygonItem.html#polygon()">QGraphicsPolygonItem::polygon()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapToParent(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapToParent()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasPolygon::points()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsPolygonItem.html#polygon()">QGraphicsPolygonItem::polygon()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasPolygon::setPoints()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsPolygonItem.html#setPolygon(com.trolltech.qt.gui.QPolygonF)">QGraphicsPolygonItem::setPolygon()</a></td></tr></table><a name="q3canvasspline"><h3>Q3CanvasSpline</h3> The closest equivalent to Q3CanvasSpline in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsPathItem.html">QGraphicsPathItem</a>. This item can be used to describe any type of path supported by <a href="../../../com/trolltech/qt/gui/QPainter.html">QPainter</a>. <p>Q3CanvasSpline takes its control points as a Q3PointArray, but <a href="../../../com/trolltech/qt/gui/QPainterPath.html">QPainterPath</a> operates on a sequence of calls to <a href="../../../com/trolltech/qt/gui/QPainterPath.html#moveTo(com.trolltech.qt.core.QPointF)">QPainterPath::moveTo()</a> and <a href="../../../com/trolltech/qt/gui/QPainterPath.html#cubicTo(com.trolltech.qt.core.QPointF, com.trolltech.qt.core.QPointF, com.trolltech.qt.core.QPointF)">QPainterPath::cubicTo()</a>. Here is how you can convert a bezier curve Q3PointArray to a <a href="../../../com/trolltech/qt/gui/QPainterPath.html">QPainterPath</a>: <pre class="snippet">
static QPainterPath fromControlPoints(const Q3PointArray &pa)
{
    QPainterPath path;
    path.moveTo(pa[0]);
    for (int i = 1; i &lt; pa.size(); i += 3)
        path.cubicTo(pa[i], pa[(i + 1) % pa.size()], pa[(i + 2) % pa.size()]);
    return path;
}
</pre> Note: <a href="../../../com/trolltech/qt/gui/QGraphicsPathItem.html">QGraphicsPathItem</a> uses <a href="../../../com/trolltech/qt/gui/QAbstractGraphicsShapeItem.html#pen()">QAbstractGraphicsShapeItem::pen()</a> for outlines, whereas Q3CanvasSpline did not use Q3CanvasPolygonalItem::pen(). <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasSpline</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsPathItem.html">QGraphicsPathItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasSpline::closed()</td><td> No equivalent. You can call QPainterPath::closeSubPath() to close a subpath explicitly.</td></tr></table><a name="q3canvasrectangle"><h3>Q3CanvasRectangle</h3> The closest equivalent to Q3CanvasRectangle in Graphics View is called <a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html">QGraphicsRectItem</a>. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasRectangle</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html">QGraphicsRectItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasRectangle::height()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html#rect()">QGraphicsRectItem::rect()</a> and <a href="../../../com/trolltech/qt/core/QRectF.html#height()">QRectF::height()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasRectangle::setSize()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html#setRect(com.trolltech.qt.core.QRectF)">QGraphicsRectItem::setRect()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasRectangle::size()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html#rect()">QGraphicsRectItem::rect()</a> and <a href="../../../com/trolltech/qt/core/QRectF.html#size()">QRectF::size()</a></td></tr><tr valign="top" class="odd"><td> Q3CanvasRectangle::width()</td><td> <a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html#rect()">QGraphicsRectItem::rect()</a> and <a href="../../../com/trolltech/qt/core/QRectF.html#width()">QRectF::width()</a></td></tr><tr valign="top" class="even"><td> Q3CanvasRectangle::chunks()</td><td> No equivalent.</td></tr></table><a name="q3canvassprite"><h3>Q3CanvasSprite</h3> Q3CanvasSprite is the item class that differs the most from its Q3Canvas predecessor. The closest resemblance of Q3CanvasSprite in Graphics View is <a href="../../../com/trolltech/qt/gui/QGraphicsPixmapItem.html">QGraphicsPixmapItem</a>. <p>Q3CanvasSprite supports animated pixmaps; <a href="../../../com/trolltech/qt/gui/QGraphicsPixmapItem.html">QGraphicsPixmapItem</a>, however, is a simple single-frame pixmap item. If all you need is a pixmap item, porting is straight-forward. If you do need the animation support, extra work is required; there is no direct porting approach. <p>For the <a href="graphicsview-portedasteroids.html">Ported Asteroids Example</a>, a subclass of <a href="../../../com/trolltech/qt/gui/QGraphicsPixmapItem.html">QGraphicsPixmapItem</a> is used to replace Q3CanvasSprite, storing a list of pixmaps and a frame counter. The animation is advanced in <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#advance(int)">QGraphicsItem::advance()</a>.<a name="q3canvaspixmap-q3canvaspixmaparray"><h4>Q3CanvasPixmap, Q3CanvasPixmapArray</h4> These classes have been removed from the API. You can use <a href="../../../com/trolltech/qt/gui/QPixmap.html">QPixmap</a> instead of Q3CanvasPixmap, and QList instead of Q3CanvasPixmapArray. <p>Q3CanvasPixmapArray included convenience for loading a sequence of pixmaps or masks using a path with a wildcard (see Q3CanvasPixmapArray::readPixmaps() and Q3CanvasPixmapArray::readCollisionMasks()). To achieve similar functionality using Graphics View, you can load the images by using <a href="../../../com/trolltech/qt/core/QDir.html">QDir</a>: <pre class="snippet">
wildcardPath.replace("%1", "*");
QFileInfo fi(wildcardPath);

QList&lt;QPixmap&gt; frames;
foreach (QString entry, QDir(fi.path(), fi.fileName()).entryList())
    frames &lt;&lt; QPixmap(fi.path() + "/" + entry);
</pre><a name="q3canvastext"><h3>Q3CanvasText</h3> Q3CanvasText has been split into two classes in Graphics View: <a href="../../../com/trolltech/qt/gui/QGraphicsSimpleTextItem.html">QGraphicsSimpleTextItem</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsTextItem.html">QGraphicsTextItem</a>. For porting, <a href="../../../com/trolltech/qt/gui/QGraphicsSimpleTextItem.html">QGraphicsSimpleTextItem</a> should be adequate. <a href="../../../com/trolltech/qt/gui/QGraphicsTextItem.html">QGraphicsTextItem</a> provides advanced document structuring features similar to that of <a href="../../../com/trolltech/qt/gui/QTextEdit.html">QTextEdit</a>, and it also allows interaction (e.g., editing and selection). <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Q3CanvasText</center></th><th><center> <a href="../../../com/trolltech/qt/gui/QGraphicsSimpleTextItem.html">QGraphicsSimpleTextItem</a></center></th></tr></thead><tr valign="top" class="even"><td> Q3CanvasText::color()</td><td> <a href="../../../com/trolltech/qt/gui/QAbstractGraphicsShapeItem.html#pen()">QGraphicsSimpleTextItem::pen()</a>.</td></tr><tr valign="top" class="odd"><td> Q3CanvasText::setColor()</td><td> <a href="../../../com/trolltech/qt/gui/QAbstractGraphicsShapeItem.html#setPen(com.trolltech.qt.gui.QPen)">QGraphicsSimpleTextItem::setPen()</a>.</td></tr><tr valign="top" class="even"><td> Q3CanvasText::textFlags()</td><td> Use <a href="../../../com/trolltech/qt/gui/QGraphicsTextItem.html">QGraphicsTextItem</a> instead.</td></tr></table><a name="q3canvasitemlist"><h3>Q3CanvasItemList</h3> Use QList instead.<a name="other-resources"><h2>Other Resources</h2> The <a href="http://doc.trolltech.com/qq/qq21-portingcanvas.html">Porting to Qt 4.2's Graphics View</a> article in Qt Quarterly 21 covered the process of porting the Qt 3 canvas example to Qt 4. The result of this is the <a href="graphicsview-portedcanvas.html">Ported Canvas</a> example.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
