<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>The Graphics View Framework</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>The Graphics View Framework</h1></center><p>An overview of the Graphics View framework for interactive 2D graphics.<a name="graphics-view"><a name="graphicsview"><a name="graphics"><a name="canvas"> Graphics View provides a surface for managing and interacting with a large number of custom-made 2D graphical items, and a view widget for visualizing the items, with support for zooming and rotation. <p>The framework includes an event propagation architecture that allows precise double-precision interaction capabilities for the items on the scene. Items can handle key events, mouse press, move, release and double click events, and they can also track mouse movement. <p>Graphics View uses a BSP (Binary Space Partitioning) tree to provide very fast item discovery, and as a result of this, it can visualize large scenes in real-time, even with millions of items. <p>Graphics View was introduced in Qt 4.2, replacing its predecessor, <a href="porting4.html">QCanvas</a>. If you are porting from <a href="porting4.html">QCanvas</a>, see <a href="graphicsview-porting.html">Porting to Graphics View</a>. <p>Topics: <ul><li> <a href="#the-graphics-view-architecture">The Graphics View Architecture</a></li> <ul><li> <a href="#the-scene">The Scene</a></li><li> <a href="#the-view">The View</a></li><li> <a href="#the-item">The Item</a></li></ul><li> <a href="#the-graphics-view-coordinate-system">The Graphics View Coordinate System</a></li> <ul><li> <a href="#item-coordinates">Item Coordinates</a></li><li> <a href="#scene-coordinates">Scene Coordinates</a></li><li> <a href="#view-coordinates">View Coordinates</a></li><li> <a href="#coordinate-mapping">Coordinate Mapping</a></li></ul><li> <a href="#key-features">Key Features</a></li> <ul><li> <a href="#zooming-and-rotating">Zooming and rotating</a></li><li> <a href="#printing">Printing</a></li><li> <a href="#drag-and-drop">Drag and Drop</a></li><li> <a href="#cursors-and-tooltips">Cursors and Tooltips</a></li><li> <a href="#animation">Animation</a></li><li> <a href="#opengl-rendering">OpenGL Rendering</a></li><li> <a href="#item-groups">Item Groups</a></li><li> <a href="#widgets-and-layouts">Widgets and Layouts</a></li> <ul><li> <a href="#qgraphicswidget">QGraphicsWidget</a></li><li> <a href="#qgraphicslayout">QGraphicsLayout</a></li></ul><li> <a href="#embedded-widget-support">Embedded Widget Support</a></li></ul></ul><a name="the-graphics-view-architecture"><h2>The Graphics View Architecture</h2> Graphics View provides an item-based approach to model-view programming, much like <a href="demos-interview.html">InterView</a>'s convenience classes <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a>, <a href="../../../com/trolltech/qt/gui/QTreeWidget.html">QTreeWidget</a> and <a href="../../../com/trolltech/qt/gui/QListWidget.html">QListWidget</a>. Several views can observe a single scene, and the scene contains items of varying geometric shapes.<a name="the-scene"><h3>The Scene</h3> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> provides the Graphics View scene. The scene has the following responsibilities: <ul><li> Providing a fast interface for managing a large number of items</li><li> Propagating events to each item</li><li> Managing item state, such as selection and focus handling</li><li> Providing untransformed rendering functionality; mainly for printing</li></ul> The scene serves as a container for <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> objects. Items are added to the scene by calling <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#addItem(com.trolltech.qt.gui.QGraphicsItemInterface)">QGraphicsScene::addItem()</a>, and then retrieved by calling one of the many item discovery functions. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#items()">QGraphicsScene::items()</a> and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#itemAt(com.trolltech.qt.core.QPointF)">QGraphicsScene::itemAt()</a> returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most). <pre class="snippet">
QGraphicsScene scene;
QGraphicsRectItem *rect = scene.addRect(QRectF(0, 0, 100, 100));

QGraphicsItem *item = scene.itemAt(50, 50);
// item == rect
</pre> <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>'s event propagation architecture schedules scene events for delivery to items, and also manages propagation between items. If the scene receives a mouse press event at a certain position, the scene passes the event on to whichever item is at that position. <p><a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> also manages certain item states, such as item selection and focus. You can select items on the scene by calling <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#setSelectionArea(com.trolltech.qt.gui.QPainterPath)">QGraphicsScene::setSelectionArea()</a>, passing an arbitrary shape. This functionality is also used as a basis for rubberband selection in <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>. To get the list of all currently selected items, call <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#selectedItems()">QGraphicsScene::selectedItems()</a>. Another state handled by <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> is whether or not an item has keyboard input focus. You can set focus on an item by calling <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#setFocusItem(com.trolltech.qt.gui.QGraphicsItemInterface)">QGraphicsScene::setFocusItem()</a> or <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setFocus()">QGraphicsItem::setFocus()</a>, or get the current focus item by calling <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#focusItem()">QGraphicsScene::focusItem()</a>. <p>Finally, <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> allows you to render parts of the scene into a paint device through the <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRectF)">QGraphicsScene::render()</a> function. You can read more about this in the Printing section later in this document.<a name="the-view"><h3>The View</h3> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> provides the view widget, which visualizes the contents of a scene. You can attach several views to the same scene, to provide several viewports into the same data set. The view widget is a scroll area, and provides scroll bars for navigating through large scenes. To enable OpenGL support, you can set a <a href="../../../com/trolltech/qt/opengl/QGLWidget.html">QGLWidget</a> as the viewport by calling <a href="../../../com/trolltech/qt/gui/QAbstractScrollArea.html#setViewport(com.trolltech.qt.gui.QWidget)">QGraphicsView::setViewport()</a>. <pre class="snippet">
QGraphicsScene scene;
myPopulateScene(&scene);

QGraphicsView view(&scene);
view.show();
</pre> The view receives input events from the keyboard and mouse, and translates these to scene events (converting the coordinates used to scene coordinates where appropriate), before sending the events to the visualized scene. <p>Using its transformation matrix, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#matrix()">QGraphicsView::matrix()</a>, the view can transform the scene's coordinate system. This allows advanced navigation features such as zooming and rotation. For convenience, <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> also provides functions for translating between view and scene coordinates: <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapToScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapToScene()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapFromScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapFromScene()</a>. <br><center><img src="images/graphicsview-view.png"></center><br><a name="the-item"><h3>The Item</h3> <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> is the base class for graphical items in a scene. Graphics View provides several standard items for typical shapes, such as rectangles (<a href="../../../com/trolltech/qt/gui/QGraphicsRectItem.html">QGraphicsRectItem</a>), ellipses (<a href="../../../com/trolltech/qt/gui/QGraphicsEllipseItem.html">QGraphicsEllipseItem</a>) and text items (<a href="../../../com/trolltech/qt/gui/QGraphicsTextItem.html">QGraphicsTextItem</a>), but the most powerful <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> features are available when you write a custom item. Among other things, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> supports the following features: <ul><li> Mouse press, move, release and double click events, as well as mouse hover events, wheel events, and context menu events.</li><li> Keyboard input focus, and key events</li><li> Drag and drop</li><li> Grouping, both through parent-child relationships, and with <a href="../../../com/trolltech/qt/gui/QGraphicsItemGroup.html">QGraphicsItemGroup</a></li><li> Collision detection</li></ul> Items live in a local coordinate system, and like <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>, it also provides many functions for mapping coordinates between the item and the scene, and from item to item. Also, like <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>, it can transform its coordinate system using a matrix: QGraphicsItem::matrix(). This is useful for rotating and scaling individual items. <p>Items can contain other items (children). Parent items' transformations are inherited by all its children. Regardless of an item's accumulated transformation, though, all its functions (e.g., <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#contains(com.trolltech.qt.core.QPointF)">QGraphicsItem::contains()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#boundingRect()">QGraphicsItem::boundingRect()</a>, QGraphicsItem::collidesWith()) still operate in local coordinates. <p><a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> supports collision detection through the <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#shape()">QGraphicsItem::shape()</a> function, and QGraphicsItem::collidesWith(), which are both virtual functions. By returning your item's shape as a local coordinate <a href="../../../com/trolltech/qt/gui/QPainterPath.html">QPainterPath</a> from <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#shape()">QGraphicsItem::shape()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> will handle all collision detection for you. If you want to provide your own collision detection, however, you can reimplement QGraphicsItem::collidesWith(). <br><center><img src="images/graphicsview-items.png"></center><br><a name="the-graphics-view-coordinate-system"><h2>The Graphics View Coordinate System</h2> Graphics View is based on the Cartesian coordinate system; items' position and geometry on the scene are represented by sets of two numbers: the x-coordinate, and the y-coordinate. When observing a scene using an untransformed view, one unit on the scene is represented by one pixel on the screen. <p>There are three effective coordinate systems in play in Graphics View: Item coordinates, scene coordinates, and view coordinates. To simplify your implementation, Graphics View provides convenience functions that allow you to map between the three coordinate systems. <p>When rendering, Graphics View's scene coordinates correspond to <a href="../../../com/trolltech/qt/gui/QPainter.html">QPainter</a>'s logical coordinates, and view coordinates are the same as device coordinates. In <a href="coordsys.html">The Coordinate System</a>, you can read about the relationship between logical coordinates and device coordinates. <br><center><img src="images/graphicsview-parentchild.png"></center><br><a name="item-coordinates"><h3>Item Coordinates</h3> Items live in their own local coordinate system. Their coordinates are usually centered around its center point (0, 0), and this is also the center for all transformations. Geometric primitives in the item coordinate system are often referred to as item points, item lines, or item rectangles. <p>When creating a custom item, item coordinates are all you need to worry about; <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#contains(com.trolltech.qt.core.QPointF)">QGraphicsItem::contains()</a> virtual function, which returns true if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates. <p>At item's position is the coordinate of the item's center point in its parent's coordinate system; sometimes referred to as parent coordinates. The scene is in this sense regarded as all parent-less items' "parent". Top level items' position are in scene coordinates. <p>Child coordinates are relative to the parent's coordinates. If the child is untransformed, the difference between a child coordinate and a parent coordinate is the same as the distance between the items in parent coordinates. For example: If an untransformed child item is positioned precisely in its parent's center point, then the two items' coordinate systems will be identical. If the child's position is (10, 0), however, the child's (0, 10) point will correspond to its parent's (10, 10) point. <p>Because items' position and transformation are relative to the parent, child items' coordinates are unaffected by the parent's transformation, although the parent's transformation implicitly transforms the child. In the above example, even if the parent is rotated and scaled, the child's (0, 10) point will still correspond to the parent's (10, 10) point. Relative to the scene, however, the child will follow the parent's transformation and position. If the parent is scaled (2x, 2x), the child's position will be at scene coordinate (20, 0), and its (10, 0) point will correspond to the point (40, 0) on the scene. <p>With <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#pos()">QGraphicsItem::pos()</a> being one of the few exceptions, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>'s functions operate in item coordinates, regardless of the item, or any of its parents' transformation. For example, an item's bounding rect (i.e. <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#boundingRect()">QGraphicsItem::boundingRect()</a>) is always given in item coordinates.<a name="scene-coordinates"><h3>Scene Coordinates</h3> The scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle (<a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#scenePos()">QGraphicsItem::scenePos()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#sceneBoundingRect()">QGraphicsItem::sceneBoundingRect()</a>), in addition to its local item pos and bounding rectangle. The scene position describes the item's position in scene coordinates, and its scene bounding rect forms the basis for how <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a> determines what areas of the scene have changed. Changes in the scene are communicated through the QGraphicsScene::changed() signal, and the argument is a list of scene rectangles.<a name="view-coordinates"><h3>View Coordinates</h3> View coordinates are the coordinates of the widget. Each unit in view coordinates corresponds to one pixel. What's special about this coordinate system is that it is relative to the widget, or viewport, and unaffected by the observed scene. The top left corner of <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>'s viewport is always (0, 0), and the bottom right corner is always (viewport width, viewport height). All mouse events and drag and drop events are originally received as view coordinates, and you need to map these coordinates to the scene in order to interact with items.<a name="coordinate-mapping"><h3>Coordinate Mapping</h3> Often when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>'s viewport, you can ask the scene what item is under the cursor by calling <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapToScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapToScene()</a>, followed by <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#itemAt(com.trolltech.qt.core.QPointF)">QGraphicsScene::itemAt()</a>. If you want to know where in the viewport an item is located, you can call <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapToScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapToScene()</a> on the item, then <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapFromScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapFromScene()</a> on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a <a href="../../../com/trolltech/qt/gui/QPainterPath.html">QPainterPath</a> to mapToScene(), and then pass the mapped path to <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#items()">QGraphicsScene::items()</a>. <p>You can map coordinates and shapes to and from and item's scene by calling <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapToScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapToScene()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapFromScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapFromScene()</a>. You can also map to an item's parent item by calling <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapToParent(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapToParent()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapFromParent(com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapFromParent()</a>, or between items by calling <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapToItem(com.trolltech.qt.gui.QGraphicsItemInterface, com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapToItem()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#mapFromItem(com.trolltech.qt.gui.QGraphicsItemInterface, com.trolltech.qt.gui.QPainterPath)">QGraphicsItem::mapFromItem()</a>. All mapping functions can map both points, rectangles, polygons and paths. <p>The same mapping functions are available in the view, for mapping to and from the scene. <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapFromScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapFromScene()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#mapToScene(com.trolltech.qt.gui.QPainterPath)">QGraphicsView::mapToScene()</a>. To map from a view to an item, you first map to the scene, and then map from the scene to the item.<a name="key-features"><h2>Key Features</h2><a name="zooming-and-rotating"><h3>Zooming and rotating</h3> <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> supports the same affine transformations as <a href="../../../com/trolltech/qt/gui/QPainter.html">QPainter</a> does through <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#setMatrix(com.trolltech.qt.gui.QMatrix)">QGraphicsView::setMatrix()</a>. By applying a transformation to the view, you can easily add support for common navigation features such as zooming and rotating. <p>Here is an example of how to implement zoom and rotate slots in a subclass of <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a>: <pre class="snippet">
class View : public QGraphicsView
{
Q_OBJECT
    ...
public slots:
    void zoomIn() { scale(1.2, 1.2); }
    void zoomOut() { scale(1 / 1.2, 1 / 1.2); }
    void rotateLeft() { rotate(-10); }
    void rotateRight() { rotate(10); }
    ...
};
</pre> The slots could be connected to <a href="../../../com/trolltech/qt/gui/QToolButton.html">QToolButtons</a> with <a href="../../../QAbstractButton.html#autoRepeat()">autoRepeat</a> enabled. <p><a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> keeps the center of the view aligned when you transform the view. <p>See also the <a href="qtjambi-elasticnodes.html">Elastic Nodes</a> example for code that shows how to implement basic zooming features.<a name="printing"><h3>Printing</h3> Graphics View provides single-line printing through its rendering functions, <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRectF)">QGraphicsScene::render()</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRect)">QGraphicsView::render()</a>. The functions provide the same API: You can have the scene or the view render all or parts of their contents into any paint device by passing a <a href="../../../com/trolltech/qt/gui/QPainter.html">QPainter</a> to either of the rendering functions. This example shows how to print the whole scene into a full page, using <a href="../../../com/trolltech/qt/gui/QPrinter.html">QPrinter</a>. <pre class="snippet">
QGraphicsScene scene;
scene.addRect(QRectF(0, 0, 100, 200), QPen(Qt::black), QBrush(Qt::green));

QPrinter printer;
if (QPrintDialog(&printer).exec() == QDialog::Accepted) {
    QPainter painter(&printer);
    painter.setRenderHint(QPainter::Antialiasing);
    scene.render(&painter);
}
</pre> The difference between the scene and view rendering functions is that one operates in scene coordinates, and the other in view coordinates. <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRectF)">QGraphicsScene::render()</a> is often preferred for printing whole segments of a scene untransformed, such as for plotting geometrical data, or for printing a text document. <a href="../../../com/trolltech/qt/gui/QGraphicsView.html#render(com.trolltech.qt.gui.QPainter, com.trolltech.qt.core.QRectF, com.trolltech.qt.core.QRect)">QGraphicsView::render()</a>, on the other hand, is suitable for taking screenshots; its default behavior is to render the exact contents of the viewport using the provided painter. <pre class="snippet">
QGraphicsScene scene;
scene.addRect(QRectF(0, 0, 100, 200), QPen(Qt::black), QBrush(Qt::green));

QPixmap pixmap;
QPainter painter(&pixmap);
painter.setRenderHint(QPainter::Antialiasing);
scene.render(&painter);
painter.end();

pixmap.save("scene.png");
</pre> When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a <a href="../../../com/trolltech/qt/core/Qt.AspectRatioMode.html">Qt::AspectRatioMode</a> to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.<a name="drag-and-drop"><h3>Drag and Drop</h3> Because <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> inherits <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> indirectly, it already provides the same drag and drop functionality that <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> provides. In addition, as a convenience, the Graphics View framework provides drag and drop support for the scene, and for each and every item. As the view receives a drag, it translates the drag and drop events into a <a href="../../../com/trolltech/qt/gui/QGraphicsSceneDragDropEvent.html">QGraphicsSceneDragDropEvent</a>, which is then forwarded to the scene. The scene takes over scheduling of this event, and sends it to the first item under the mouse cursor that accepts drops. <p>To start a drag from an item, create a <a href="../../../com/trolltech/qt/gui/QDrag.html">QDrag</a> object, passing a pointer to the widget that starts the drag. Items can be observed by many views at the same time, but only one view can start the drag. Drags are in most cases started as a result of pressing or moving the mouse, so in mousePressEvent() or mouseMoveEvent(), you can get the originating widget pointer from the event. For example: <pre class="snippet">
void CustomItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    QMimeData *data = new QMimeData;
    data-&gt;setColor(Qt::green);

    QDrag *drag = new QDrag(event-&gt;widget());
    drag-&gt;setMimeData(data);
    drag-&gt;start();
}
</pre> To intercept drag and drop events for the scene, you reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#dragEnterEvent(com.trolltech.qt.gui.QGraphicsSceneDragDropEvent)">QGraphicsScene::dragEnterEvent()</a> and whichever event handlers your particular scene needs, in a <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> subclass. You can read more about drag and drop in Graphics View in the documentation for each of <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html">QGraphicsScene</a>'s event handlers. <p>Items can enable drag and drop support by calling <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setAcceptDrops(boolean)">QGraphicsItem::setAcceptDrops()</a>. To handle the incoming drag, reimplement <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#dragEnterEvent(com.trolltech.qt.gui.QGraphicsSceneDragDropEvent)">QGraphicsItem::dragEnterEvent()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#dragMoveEvent(com.trolltech.qt.gui.QGraphicsSceneDragDropEvent)">QGraphicsItem::dragMoveEvent()</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#dragLeaveEvent(com.trolltech.qt.gui.QGraphicsSceneDragDropEvent)">QGraphicsItem::dragLeaveEvent()</a>, and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#dropEvent(com.trolltech.qt.gui.QGraphicsSceneDragDropEvent)">QGraphicsItem::dropEvent()</a>. <p>See also the <a href="graphicsview-dragdroprobot.html">Drag and Drop Robot</a> example for a demonstration of Graphics View's support for drag and drop operations.<a name="cursors-and-tooltips"><h3>Cursors and Tooltips</h3> Like <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>, <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> also supports cursors (<a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setCursor(com.trolltech.qt.gui.QCursor)">QGraphicsItem::setCursor()</a>), and tooltips (<a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setToolTip(java.lang.String)">QGraphicsItem::setToolTip()</a>). The cursors and tooltips are activated by <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> as the mouse cursor enters the item's area (detected by calling <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#contains(com.trolltech.qt.core.QPointF)">QGraphicsItem::contains()</a>). <p>You can also set a default cursor directly on the view by calling QGraphicsView::setCursor(). <p>See also the <a href="graphicsview-dragdroprobot.html">Drag and Drop Robot</a> example for code that implements tooltips and cursor shape handling.<a name="animation"><h3>Animation</h3> Graphics View supports animation at several levels. You can easily assemble animation paths by associating a <a href="../../../com/trolltech/qt/gui/QGraphicsItemAnimation.html">QGraphicsItemAnimation</a> with your item. This allows timeline controlled animations that operate at a steady speed on all platforms (although the frame rate may vary depending on the platform's performance). <a href="../../../com/trolltech/qt/gui/QGraphicsItemAnimation.html">QGraphicsItemAnimation</a> allows you to create a path for an item's position, rotation, scale, shear and translation. The animation can be controlled by a <a href="../../../com/trolltech/qt/gui/QSlider.html">QSlider</a>, or more commonly by <a href="../../../com/trolltech/qt/core/QTimeLine.html">QTimeLine</a>. <p>Another option is to create a custom item that inherits from <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>. The item can the set up its own timers, and control animations with incremental steps in <a href="../../../com/trolltech/qt/core/QObject.html#timerEvent(com.trolltech.qt.core.QTimerEvent)">QObject::timerEvent()</a>. <p>A third option, which is mostly available for compatibility with <a href="porting4.html">QCanvas</a> in Qt 3, is to advance the scene by calling <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#advance()">QGraphicsScene::advance()</a>, which in turn calls <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#advance(int)">QGraphicsItem::advance()</a>. <p>See also the <a href="graphicsview-dragdroprobot.html">Drag and Drop Robot</a> example for an illustration of timeline-based animation techniques.<a name="opengl-rendering"><h3>OpenGL Rendering</h3> To enable OpenGL rendering, you simply set a new <a href="../../../com/trolltech/qt/opengl/QGLWidget.html">QGLWidget</a> as the viewport of <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> by calling <a href="../../../com/trolltech/qt/gui/QAbstractScrollArea.html#setViewport(com.trolltech.qt.gui.QWidget)">QGraphicsView::setViewport()</a>. If you want OpenGL with antialiasing, you need OpenGL sample buffer support (see <a href="../../../com/trolltech/qt/opengl/QGLFormat.html#sampleBuffers()">QGLFormat::sampleBuffers()</a>). <p>Example: <pre class="snippet">
QGraphicsView view(&scene);
view.setViewport(new QGLWidget(QGLFormat(QGL::SampleBuffers)));
</pre><a name="item-groups"><h3>Item Groups</h3> By making an item a child of another, you can achieve the most essential feature of item grouping: the items will move together, and all transformations are propagated from parent to child. <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> can also handle all events for its children (see <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html#setHandlesChildEvents(boolean)">QGraphicsItem::setHandlesChildEvents()</a>). This allows the parent item to act on behalf of its children, effectively treating all items as one. <p>In addition, <a href="../../../com/trolltech/qt/gui/QGraphicsItemGroup.html">QGraphicsItemGroup</a> is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a <a href="../../../com/trolltech/qt/gui/QGraphicsItemGroup.html">QGraphicsItemGroup</a> will keep the item's original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create <a href="../../../com/trolltech/qt/gui/QGraphicsItemGroup.html">QGraphicsItemGroup</a>s through the scene by calling <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#createItemGroup(java.util.List<com.trolltech.qt.gui.QGraphicsItemInterface>)">QGraphicsScene::createItemGroup()</a>.<a name="widgets-and-layouts"><h3>Widgets and Layouts</h3> Qt 4.4 introduced support for geometry and layout-aware items through <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a>. This special base item is similar to <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>, but unlike <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>, it doesn't inherit from <a href="../../../com/trolltech/qt/gui/QPaintDevice.html">QPaintDevice</a>; rather from <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> instead. This allows you to write complete widgets with events, signals & slots, size hints and policies, and you can also manage your widgets geometries in layouts through <a href="../../../com/trolltech/qt/gui/QGraphicsLinearLayout.html">QGraphicsLinearLayout</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsGridLayout.html">QGraphicsGridLayout</a>.<a name="qgraphicswidget"><h4>QGraphicsWidget</h4> Building on top of <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>'s capabilities and lean footprint, <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a> provides the best of both worlds: extra functionality from <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>, such as the style, font, palette, layout direction, and its geometry, and resolution independence and transformation support from <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a>. Because Graphics View uses real coordinates instead of integers, <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a>'s geometry functions also operate on <a href="../../../com/trolltech/qt/core/QRectF.html">QRectF</a> and <a href="../../../com/trolltech/qt/core/QPointF.html">QPointF</a>. This also applies to frame rects, margins and spacing. With <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a> it's not uncommon to specify contents margins of (0.5, 0.5, 0.5, 0.5), for example. You can create both subwidgets and "top-level" windows; in some cases you can now use Graphics View for advanced MDI applications. <p>Some of <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>'s properties are supported, including window flags and attributes, but not all. You should refer to <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a>'s class documentation for a complete overview of what is and what is not supported. For example, you can create decorated windows by passing the <a href="../../../com/trolltech/qt/core/Qt.WindowType.html">Qt::Window</a> window flag to <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a>'s constructor, but Graphics View currently doesn't support the <a href="../../../com/trolltech/qt/core/Qt.WindowType.html">Qt::Sheet</a> and <a href="../../../com/trolltech/qt/core/Qt.WindowType.html">Qt::Drawer</a> flags that are common on Mac OS X. <p>The capabilities of <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a> are expected to grow depending on community feedback.<a name="qgraphicslayout"><h4>QGraphicsLayout</h4> <a href="../../../com/trolltech/qt/gui/QGraphicsLayout.html">QGraphicsLayout</a> is part of a second-generation layout framework designed specifically for <a href="../../../com/trolltech/qt/gui/QGraphicsWidget.html">QGraphicsWidget</a>. Its API is very similar to that of <a href="../../../com/trolltech/qt/gui/QLayout.html">QLayout</a>. You can manage widgets and sublayouts inside either <a href="../../../com/trolltech/qt/gui/QGraphicsLinearLayout.html">QGraphicsLinearLayout</a> and <a href="../../../com/trolltech/qt/gui/QGraphicsGridLayout.html">QGraphicsGridLayout</a>. You can also easily write your own layout by subclassing <a href="../../../com/trolltech/qt/gui/QGraphicsLayout.html">QGraphicsLayout</a> yourself, or add your own <a href="../../../com/trolltech/qt/gui/QGraphicsItem.html">QGraphicsItem</a> items to the layout by writing an adaptor subclass of <a href="../../../com/trolltech/qt/gui/QGraphicsLayoutItem.html">QGraphicsLayoutItem</a>.<a name="embedded-widget-support"><h3>Embedded Widget Support</h3> Graphics View provides seamless support for embedding any widget into the scene. You can embed simple widgets, such as <a href="../../../com/trolltech/qt/gui/QLineEdit.html">QLineEdit</a> or <a href="../../../com/trolltech/qt/gui/QPushButton.html">QPushButton</a>, complex widgets such as <a href="../../../com/trolltech/qt/gui/QTabWidget.html">QTabWidget</a>, and even complete main windows. To embed your widget to the scene, simply call <a href="../../../com/trolltech/qt/gui/QGraphicsScene.html#addWidget(com.trolltech.qt.gui.QWidget, com.trolltech.qt.core.Qt.WindowType[])">QGraphicsScene::addWidget()</a>, or create an instance of <a href="../../../com/trolltech/qt/gui/QGraphicsProxyWidget.html">QGraphicsProxyWidget</a> to embed your widget manually. <p>Through <a href="../../../com/trolltech/qt/gui/QGraphicsProxyWidget.html">QGraphicsProxyWidget</a>, Graphics View is able to deeply integrate the client widget features including its cursors, tooltips, mouse, tablet and keyboard events, child widgets, animations, pop-ups (e.g., <a href="../../../com/trolltech/qt/gui/QComboBox.html">QComboBox</a> or <a href="../../../com/trolltech/qt/gui/QCompleter.html">QCompleter</a>), and the widget's input focus and activation. <a href="../../../com/trolltech/qt/gui/QGraphicsProxyWidget.html">QGraphicsProxyWidget</a> even integrates the embedded widget's tab order so that you can tab in and out of embedded widgets. You can even embed a new <a href="../../../com/trolltech/qt/gui/QGraphicsView.html">QGraphicsView</a> into your scene to provide complex nested scenes. <p>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
