<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Qt for Mac OS X - Specific Issues</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Qt for Mac OS X - Specific Issues</h1></center><p>A description of issues with Qt that are specific to Mac OS X. This file outlines known issues and possible workarounds when using Qt on Mac OS X. Contact Qt's technical support team if you find additional issues which are not covered here. (See also the document <a href="qtmac-as-native.html">Qt is Mac OS X Native</a>.) <ul><li> <a href="#gui-applications">GUI Applications</a></li><li> <a href="#painting">Painting</a></li><li> <a href="#library-support">Library Support</a></li> <ul><li> <a href="#qt-libraries-as-frameworks">Qt libraries as frameworks</a></li><li> <a href="#bundle-based-libraries">Bundle-Based Libraries</a></li><li> <a href="#combining-libraries">Combining Libraries</a></li><li> <a href="#initialization-order">Initialization Order</a></li></ul><li> <a href="#compile-time-flags">Compile-Time Flags</a></li><li> <a href="#mac-os-x-native-api-access">Mac OS X Native API Access</a></li> <ul><li> <a href="#accessing-the-bundle-path">Accessing the Bundle Path</a></li><li> <a href="#translating-the-application-menu-and-native-dialogs">Translating the Application Menu and Native Dialogs</a></li></ul><li> <a href="#user-interface">User Interface</a></li> <ul><li> <a href="#right-mouse-clicks">Right-Mouse Clicks</a></li><li> <a href="#menu-bar">Menu Bar</a></li><li> <a href="#special-keys">Special Keys</a></li></ul><li> <a href="#limitations">Limitations</a></li> <ul><li> <a href="#menu-actions">Menu Actions</a></li><li> <a href="#native-widgets">Native Widgets</a></li></ul></ul><a name="gui-applications"><h2>GUI Applications</h2> Mac OS X handles most applications as "bundles". A bundle is a directory structure that groups related files together (e.g., widgets.app/). GUI applications in particular must be run from a bundle or by using the open(1), because Mac OS X needs the bundle to dispatch events correctly, as well as for accessing the menu bar. <p>If you are using older versions of GDB you must run with the full path to the executable. Later versions allow you to pass the bundle name on the command line.<a name="painting"><h2>Painting</h2> Mac OS X always double buffers the screen so the <a href="../../../com/trolltech/qt/core/Qt.WidgetAttribute.html">Qt::WA_PaintOnScreen</a> attribute has no effect. Also it is impossible to paint outside of a paint event so <a href="../../../com/trolltech/qt/core/Qt.WidgetAttribute.html">Qt::WA_PaintOutsidePaintEvent</a> has no effect either.<a name="library-support"><h2>Library Support</h2><a name="qt-libraries-as-frameworks"><h3>Qt libraries as frameworks</h3> By default, Qt is built as a set of frameworks. Frameworks is the Mac OS X "preferred" way of distributing libraries. There are definite advantages to using them. See Apple's Framework Programming Guide for more information. <p>In general, this shouldn't be an issue because qmake takes care of the specifics for you. The Framework Programming Guide discusses issues to keep in mind when choosing frameworks over the more typical, dynamic libraries. However, one point to remember is: <b>Frameworks always link with "release" versions of libraries</b>. <p>If you actually want to use a debug version of a Qt framework, you must ensure that your application actually loads that debug version. This is often done by using the DYLD_IMAGE_SUFFIX environment variables, but that way often doesn't work so well. Instead, you can temporarily swap your debug and release versions, which is documented in Apple's "Debugging Magic" technical note. <p>If you don't want to use frameworks, simply configure Qt with <tt>-no-framework</tt>.<a name="bundle-based-libraries"><h3>Bundle-Based Libraries</h3> If you want to use some dynamic libraries in your Mac OS X application bundle (the application directory), create a subdirectory named "Frameworks" in the application bundle directory and place your dynamic libraries there. The application will find a dynamic library if it has the install name @executable_path/../Frameworks/libname.dylib. <p>If you use <tt>qmake</tt> and Makefiles, use the <tt>QMAKE_LFLAGS_SONAME</tt> setting: <pre class="snippet">
QMAKE_LFLAGS_SONAME  = -Wl,-install_name,&#64;executable_path/../Frameworks/
</pre> Alternatively, you can modify the install name using the install_name_tool(1) on the command line. See its manpage for more information. <p>Note that the <tt>DYLD_LIBRARY_PATH</tt> environment variable will override these settings, and any other default paths, such as a lookup of dynamic libraries inside <tt>/usr/lib</tt> and similar default locations.<a name="combining-libraries"><h3>Combining Libraries</h3> If you want to build a new dynamic library combining the Qt 4 dynamic libraries, you need to introduce the <tt>ld -r</tt> flag. Then relocation information is stored in the the output file, so that this file could be the subject of another <tt>ld</tt> run. This is done by setting the <tt>-r</tt> flag in the <tt>.pro</tt> file, and the <tt>LFLAGS</tt> settings.<a name="initialization-order"><h3>Initialization Order</h3> dyld(1) calls global static initializers in the order they are linked into your application. If a library links against Qt and references globals in Qt (from global initializers in your own library), be sure to link your application against Qt before linking it against the library. Otherwise the result will be undefined because Qt's global initializers have not been called yet.<a name="compile-time-flags"><h2>Compile-Time Flags</h2> The follewing flags are helpful when you want to define Mac OS X specific code: <ul><li> Q_OS_DARWIN is defined when Qt detects you are on a Darwin-based system (including the Open Source version)</li><li> Q_WS_MAC is defined when the Mac OS X GUI is present.</li><li> QT_MAC_USE_COCOA is defined when Qt is built to use the Cocoa framework. If it is not present, then Qt is using Carbon.</li></ul> A additional flag, Q_OS_MAC, is defined as a convenience whenever Q_OS_DARWIN is defined. <p>If you want to define code for specific versions of Mac OS X, use the availability macros defined in /usr/include/AvailabilityMacros.h. <p>See QSysInfo for information on runtime version checking.<a name="mac-os-x-native-api-access"><h2>Mac OS X Native API Access</h2><a name="accessing-the-bundle-path"><h3>Accessing the Bundle Path</h3> The Mac OS X application is actually a directory (ending with <tt>.app</tt>). This directory contains sub-directories and files. It may be useful to place items (e.g. plugins, online-documentation, etc.) inside this bundle. You might then want to find out where the bundle resides on the disk. The following code returns the path of the application bundle: <pre class="snippet">
#ifdef Q_WS_MAC
    CFURLRef appUrlRef = CFBundleCopyBundleURL(CFBundleGetMainBundle());
    CFStringRef macPath = CFURLCopyFileSystemPath(appUrlRef,
                                           kCFURLPOSIXPathStyle);
    const char *pathPtr = CFStringGetCStringPtr(macPath,
                                           CFStringGetSystemEncoding());
    qDebug("Path = %s", pathPtr);
    CFRelease(appUrlRef);
    CFRelease(macPath);
#endif
</pre> Note: When OS X is set to use Japanese, a bug causes this sequence to fail and return an empty string. Therefore, always test the returned string. <p>For more information about using the CFBundle API, see Apple's Developer Website.<a name="translating-the-application-menu-and-native-dialogs"><h3>Translating the Application Menu and Native Dialogs</h3> The items in the Application Menu will be merged correctly for your localized application, but they will not show up translated until you add a localized resource folder to the application bundle. The main thing you need to do is create a file called locversion.plist. Here is an example for Norwegian: <pre class="snippet">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN"
"http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;LprojCompatibleVersion&lt;/key&gt;
    &lt;string&gt;123&lt;/string&gt;
    &lt;key&gt;LprojLocale&lt;/key&gt;
    &lt;string&gt;no&lt;/string&gt;
    &lt;key&gt;LprojRevisionLevel&lt;/key&gt;
    &lt;string&gt;1&lt;/string&gt;
    &lt;key&gt;LprojVersion&lt;/key&gt;
    &lt;string&gt;123&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</pre> Now when you run the application with your preferred language set to Norwegian, you should see menu items like "Avslutt" instead of "Quit".<a name="user-interface"><h2>User Interface</h2><a name="right-mouse-clicks"><h3>Right-Mouse Clicks</h3> If you want to provide right-mouse click support for Mac OS X, use the <a href="../../../com/trolltech/qt/gui/QContextMenuEvent.html">QContextMenuEvent</a> class. This will map to a context menu event, i.e., a menu that will display a pop-up selection. This is the most common use of right-mouse clicks, and maps to a control-click with the Mac OS X one-button mouse support.<a name="menu-bar"><h3>Menu Bar</h3> Qt will automatically detect your menu bars for you and turn them into Mac native menu bars. Fitting this into your existing Qt application will normally be automatic. However, if you have special needs, the Qt implementation currently selects a menu bar by starting at the active window (i.e. <a href="../../../com/trolltech/qt/gui/QApplication.html#activeWindow()">QApplication::activeWindow()</a>) and applying the following tests: <ol><li> If the window has a <a href="../../../com/trolltech/qt/gui/QMenuBar.html">QMenuBar</a>, then it is used.</li><li> If the window is modal, then its menu bar is used. If no menu bar is specified, then a default menu bar is used (as documented below).</li><li> If the window has no parent, then the default menu bar is used (as documented below).</li></ol> These tests are followed all the way up the parent window chain until one of the above rules is satisifed. If all else fails, a default menu bar will be created. Note the default menu bar on Qt is an empty menu bar. However, you can create a different default menu bar by creating a parentless <a href="../../../com/trolltech/qt/gui/QMenuBar.html">QMenuBar</a>. The first one created will be designated the default menu bar and will be used whenever a default menu bar is needed. <p>Note that using native menu bars introduces certain limitations on Qt classes. See the <a href="mac-differences.html#limitations">list of limitations</a> below for more information about these.<a name="special-keys"><h3>Special Keys</h3> To provide the expected behavior for Qt applications on Mac OS X, the Qt::Meta, <a href="../../../com/trolltech/qt/core/Qt.KeyboardModifier.html">Qt::MetaModifier</a>, and <a href="../../../com/trolltech/qt/core/Qt.Modifier.html">Qt::META</a> enum values correspond to the Control keys on the standard Macintosh keyboard, and the Qt::Control, <a href="../../../com/trolltech/qt/core/Qt.KeyboardModifier.html">Qt::ControlModifier</a>, and <a href="../../../com/trolltech/qt/core/Qt.Modifier.html">Qt::CTRL</a> enum values correspond to the Command keys.<a name="limitations"><h2>Limitations</h2><a name="menu-actions"><h3>Menu Actions</h3> <ul><li> Actions in a <a href="../../../com/trolltech/qt/gui/QMenu.html">QMenu</a> with accelerators that have more than one keystroke (<a href="../../../com/trolltech/qt/gui/QKeySequence.html">QKeySequence</a>) will not display correctly, when the <a href="../../../com/trolltech/qt/gui/QMenu.html">QMenu</a> is translated into a Mac native menu bar. The first key will be displayed. However, the shortcut will still be activated as on all other platforms.</li><li> <a href="../../../com/trolltech/qt/gui/QMenu.html">QMenu</a> objects used in the native menu bar are not able to handle Qt events via the normal event handlers. For Carbon, you will have to install a Carbon event handler on the menu bar in order to receive Carbon events that are similar to <a href="../../../com/trolltech/qt/gui/QWidget.html#showEvent(com.trolltech.qt.gui.QShowEvent)">showEvent()</a>, <a href="../../../com/trolltech/qt/gui/QWidget.html#hideEvent(com.trolltech.qt.gui.QHideEvent)">hideEvent()</a>, and <a href="../../../com/trolltech/qt/gui/QWidget.html#mouseMoveEvent(com.trolltech.qt.gui.QMouseEvent)">mouseMoveEvent()</a>. For Cocoa, you will have to install a delegate on the menu itself to be notified of these changes. Alternatively, consider using the QMenu::aboutToShow() and QMenu::aboutToHide() signals to keep track of menu visibility; these provide a solution that should work on all platforms supported by Qt.</li></ul><a name="native-widgets"><h3>Native Widgets</h3> Qt has support for sheets and drawers, represented in the window flags by <a href="../../../com/trolltech/qt/core/Qt.WindowType.html">Qt::Sheet</a> and <a href="../../../com/trolltech/qt/core/Qt.WindowType.html">Qt::Drawer</a> respectiviely. Brushed metal windows can also be created by using the <a href="../../../com/trolltech/qt/core/Qt.WidgetAttribute.html">Qt::WA_MacMetalStyle</a> window attribute.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
