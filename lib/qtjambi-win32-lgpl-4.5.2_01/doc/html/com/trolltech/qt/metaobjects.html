<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Meta-Object System</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Meta-Object System</h1></center><p>An overview of Qt's meta-object system and introspection capabilities. <a name="meta-object"> Qt's meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information, and the dynamic property system. The meta-object system is based on three things: <ol><li> The <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> class provides a base class for objects that can take advantage of the meta-object system.</li><li> The Q_OBJECT macro inside the private section of the class declaration is used to enable meta-object features, such as dynamic properties, signals, and slots.</li><li> The <a href="moc.html">Meta-Object Compiler</a> (<tt>moc</tt>) supplies each <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass with the necessary code to implement meta-object features.</li></ol> The <tt>moc</tt> tool reads a C++ source file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces another C++ source file which contains the meta-object code for each of those classes. This generated source file is either <tt>#include</tt>'d into the class's source file or, more usually, compiled and linked with the class's implementation. <p>In addition to providing the <a href="qtjambi-signalsandslots.html">signals and slots</a> mechanism for communication between objects (the main reason for introducing the system), the meta-object code provides the following additional features: <ul><li> QObject::metaObject() returns the associated meta-object for the class.</li><li> QMetaObject::className() returns the class name as a string at run-time, without requiring native run-time type information (RTTI) support through the C++ compiler.</li><li> QObject::inherits() function returns whether an object is an instance of a class that inherits a specified class within the <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> inheritance tree.</li><li> QObject::tr() and QObject::trUtf8() translate strings for <a href="qtjambi-i18n.html">internationalization</a>.</li><li> <a href="../../../com/trolltech/qt/core/QObject.html#setProperty(java.lang.String, java.lang.Object)">QObject::setProperty()</a> and <a href="../../../com/trolltech/qt/core/QObject.html#property(java.lang.String)">QObject::property()</a> dynamically set and get properties by name.</li></ul><a name="qobjectcast"> It is also possible to perform dynamic casts using qobject_cast() on <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> classes. The qobject_cast() function behaves similarly to the standard C++ <tt>dynamic_cast()</tt>, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries. It attempts to cast its argument to the pointer type specified in angle-brackets, returning a non-zero pointer if the object is of the correct type (determined at run-time), or 0 if the object's type is incompatible. <p>For example, let's assume <tt>MyWidget</tt> inherits from <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> and is declared with the Q_OBJECT macro:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    QObject *obj = new MyWidget;
</pre> The <tt>obj</tt> variable, of type <tt>QObject *</tt>, actually refers to a <tt>MyWidget</tt> object, so we can cast it appropriately:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    QWidget *widget = qobject_cast&lt;QWidget *&gt;(obj);
</pre> The cast from <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> to <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> is successful, because the object is actually a <tt>MyWidget</tt>, which is a subclass of <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>. Since we know that <tt>obj</tt> is a <tt>MyWidget</tt>, we can also cast it to <tt>MyWidget *</tt>:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    MyWidget *myWidget = qobject_cast&lt;MyWidget *&gt;(obj);
</pre> The cast to <tt>MyWidget</tt> is successful because qobject_cast() makes no distinction between built-in Qt types and custom types.<br><br>The following code example is written in c++.<br> <pre class="snippet">
    QLabel *label = qobject_cast&lt;QLabel *&gt;(obj);

    // label is 0
</pre> The cast to <a href="../../../com/trolltech/qt/gui/QLabel.html">QLabel</a>, on the other hand, fails. The pointer is then set to 0. This makes it possible to handle objects of different types differently at run-time, based on the type:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    if (QLabel *label = qobject_cast&lt;QLabel *&gt;(obj)) {

        label-&gt;setText(tr("Ping"));
    } else if (QPushButton *button = qobject_cast&lt;QPushButton *&gt;(obj)) {
        button-&gt;setText(tr("Pong!"));
    }
</pre> While it is possible to use <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> as a base class without the Q_OBJECT macro and without meta-object code, neither signals and slots nor the other features described here will be available if the Q_OBJECT macro is not used. From the meta-object system's point of view, a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass without meta code is equivalent to its closest ancestor with meta-object code. This means for example, that QMetaObject::className() will not return the actual name of your class, but the class name of this ancestor. <p>Therefore, we strongly recommend that all subclasses of <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> use the Q_OBJECT macro regardless of whether or not they actually use signals, slots, and properties. <p><DT><b>See also:</b><br><DD>QMetaObject, <a href="properties.html">Qt's Property System</a>, and <a href="qtjambi-signalsandslots.html">Signals and Slots</a>. <br></DD></DT><p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
