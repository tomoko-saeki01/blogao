<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Using the Meta-Object Compiler (moc)</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Using the Meta-Object Compiler (moc)</h1></center><p><a name="moc"> The Meta-Object Compiler, <tt>moc</tt>, is the program that handles <a href="metaobjects.html">Qt's C++ extensions</a>. <p>The <tt>moc</tt> tool reads a C++ header file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system. <p>The C++ source file generated by <tt>moc</tt> must be compiled and linked with the implementation of the class. <p>If you use <a href="qmake-manual.html">qmake</a> to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on <tt>moc</tt>, see <a href="templates.html">Why Doesn't Qt Use Templates for Signals and Slots?</a><a name="usage"><h2>Usage</h2> <tt>moc</tt> is typically used with an input file containing class declarations like this: <pre class="snippet">
class MyClass : public QObject
{
    Q_OBJECT

public:
    MyClass(QObject *parent = 0);
    ~MyClass();

signals:
    void mySignal();

public slots:
    void mySlot();
};
</pre> In addition to the signals and slots shown above, <tt>moc</tt> also implements object properties as in the next example. The Q_PROPERTY() macro declares an object property, while Q_ENUMS() declares a list of enumeration types within the class to be usable inside the <a href="properties.html">property system</a>. <p>In the following example, we declare a property of the enumeration type <tt>Priority</tt> that is also called <tt>priority</tt> and has a get function <tt>priority()</tt> and a set function <tt>setPriority()</tt>. <pre class="snippet">
class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Priority priority READ priority WRITE setPriority)
    Q_ENUMS(Priority)

public:
    enum Priority { High, Low, VeryHigh, VeryLow };

    MyClass(QObject *parent = 0);
    ~MyClass();

    void setPriority(Priority priority);
    Priority priority() const;
};
</pre> The Q_FLAGS() macro declares enums that are to be used as flags, i.e. OR'd together. Another macro, Q_CLASSINFO(), allows you to attach additional name/value pairs to the class's meta-object: <pre class="snippet">
class MyClass : public QObject
{
    Q_OBJECT
    Q_CLASSINFO("Author", "Oscar Peterson")
    Q_CLASSINFO("Status", "Active")

public:
    MyClass(QObject *parent = 0);
    ~MyClass();
};
</pre> The output produced by <tt>moc</tt> must be compiled and linked, just like the other C++ code in your program; otherwise, the build will fail in the final link phase. If you use <tt>qmake</tt>, this is done automatically. Whenever <tt>qmake</tt> is run, it parses the project's header files and generates make rules to invoke <tt>moc</tt> for those files that contain a Q_OBJECT macro. <p>If the class declaration is found in the file <tt>myclass.h</tt>, the moc output should be put in a file called <tt>moc_myclass.cpp</tt>. This file should then be compiled as usual, resulting in an object file, e.g., <tt>moc_myclass.obj</tt> on Windows. This object should then be included in the list of object files that are linked together in the final building phase of the program.<a name="writing-make-rules-for-invoking"><h2>Writing Make Rules for Invoking moc</h2><tt>moc</tt> For anything but the simplest test programs, it is recommended that you automate running the <tt>moc</tt>. By adding some rules to your program's makefile, <tt>make</tt> can take care of running moc when necessary and handling the moc output. <p>We recommend using the <a href="qmake-manual.html">qmake</a> makefile generation tool for building your makefiles. This tool generates a makefile that does all the necessary <tt>moc</tt> handling. <p>If you want to create your makefiles yourself, here are some tips on how to include moc handling. <p>For Q_OBJECT class declarations in header files, here is a useful makefile rule if you only use GNU make: <pre class="snippet">
moc_%.cpp: %.h
        moc $(DEFINES) $(INCPATH) $&lt; -o $&#64;
</pre> If you want to write portably, you can use individual rules of the following form: <pre class="snippet">
moc_foo.cpp: foo.h
        moc $(DEFINES) $(INCPATH) $&lt; -o $&#64;
</pre> You must also remember to add <tt>moc_foo.cpp</tt> to your <tt>SOURCES</tt> (substitute your favorite name) variable and <tt>moc_foo.o</tt> or <tt>moc_foo.obj</tt> to your <tt>OBJECTS</tt> variable. <p>Both examples assume that <tt>$(DEFINES)</tt> and <tt>$(INCPATH)</tt> expand to the define and include path options that are passed to the C++ compiler. These are required by <tt>moc</tt> to preprocess the source files. <p>While we prefer to name our C++ source files <tt>.cpp</tt>, you can use any other extension, such as <tt>.C</tt>, <tt>.cc</tt>, <tt>.CC</tt>, <tt>.cxx</tt>, and <tt>.c++</tt>, if you prefer. <p>For Q_OBJECT class declarations in implementation (<tt>.cpp</tt>) files, we suggest a makefile rule like this: <pre class="snippet">
foo.o: foo.moc

foo.moc: foo.cpp
        moc $(DEFINES) $(INCPATH) -i $&lt; -o $&#64;
</pre> This guarantees that make will run the moc before it compiles <tt>foo.cpp</tt>. You can then put <pre class="snippet">
#include "foo.moc"
</pre> at the end of <tt>foo.cpp</tt>, where all the classes declared in that file are fully known.<a name="command-line-options"><h2>Command-Line Options</h2> Here are the command-line options supported by the moc: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Option</center></th><th><center> Description</center></th></tr></thead><tr valign="top" class="even"><td> <tt>-o&lt;file&gt;</tt></td><td> Write output to <tt>&lt;file&gt;</tt> rather than to standard output.</td></tr><tr valign="top" class="odd"><td> <tt>-f[&lt;file&gt;]</tt></td><td> Force the generation of an <tt>#include</tt> statement in the output. This is the default for header files whose extension starts with <tt>H</tt> or <tt>h</tt>. This option is useful if you have header files that do not follow the standard naming conventions. The <tt>&lt;file&gt;</tt> part is optional.</td></tr><tr valign="top" class="even"><td> <tt>-i</tt></td><td> Do not generate an <tt>#include</tt> statement in the output. This may be used to run the moc on on a C++ file containing one or more class declarations. You should then <tt>#include</tt> the meta-object code in the <tt>.cpp</tt> file.</td></tr><tr valign="top" class="odd"><td> <tt>-nw</tt></td><td> Do not generate any warnings. (Not recommended.)</td></tr><tr valign="top" class="even"><td> <tt>-p&lt;path&gt;</tt></td><td> Makes the moc prepend <tt>&lt;path&gt;/</tt> to the file name in the generated <tt>#include</tt> statement.</td></tr><tr valign="top" class="odd"><td> <tt>-I&lt;dir&gt;</tt></td><td> Add dir to the include path for header files.</td></tr><tr valign="top" class="even"><td> <tt>-E</tt></td><td> Preprocess only; do not generate meta-object code.</td></tr><tr valign="top" class="odd"><td> <tt>-D&lt;macro&gt;[=&lt;def&gt;]</tt></td><td> Define macro, with optional definition.</td></tr><tr valign="top" class="even"><td> <tt>-U&lt;macro&gt;</tt></td><td> Undefine macro.</td></tr><tr valign="top" class="odd"><td> <tt>@&lt;file&gt;</tt></td><td> Read additional command-line options from <tt>&lt;file&gt;</tt>. Each line of the file is treated as a single option. Empty lines are ignored. Note that this option is not supported within the options file itself (i.e. an options file can't "include" another file).</td></tr><tr valign="top" class="even"><td> <tt>-h</tt></td><td> Display the usage and the list of options.</td></tr><tr valign="top" class="odd"><td> <tt>-v</tt></td><td> Display <tt>moc</tt>'s version number.</td></tr><tr valign="top" class="even"><td> <tt>-Fdir</tt></td><td> Mac OS X. Add the framework directory <tt>dir</tt> to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by -I options and are scanned in a left-to-right order (see the manpage for gcc). Normally, use -F /Library/Frameworks/</td></tr></table> You can explicitly tell the moc not to parse parts of a header file. <tt>moc</tt> defines the preprocessor symbol <tt>Q_MOC_RUN</tt>. Any code surrounded by <pre class="snippet">
#ifndef Q_MOC_RUN
    ... 
#endif
</pre> is skipped by the <tt>moc</tt>.<a name="diagnostics"><h2>Diagnostics</h2> <tt>moc</tt> will warn you about a number of dangerous or illegal constructs in the Q_OBJECT class declarations. <p>If you get linkage errors in the final building phase of your program, saying that <tt>YourClass::className()</tt> is undefined or that <tt>YourClass</tt> lacks a vtable, something has been done wrong. Most often, you have forgotten to compile or <tt>#include</tt> the moc-generated C++ code, or (in the former case) include that object file in the link command. If you use <tt>qmake</tt>, try rerunning it to update your makefile. This should do the trick.<a name="limitations"><h2>Limitations</h2> <tt>moc</tt> does not handle all of C++. The main problem is that class templates cannot have signals or slots. Here is an example: <pre class="snippet">
class SomeTemplate&lt;int&gt; : public QFrame
{
    Q_OBJECT
    ...

signals:
    void mySignal(int);
};
</pre> Another limitation is that moc does not expand macros, so you for example cannot use a macro to declare a signal/slot or use one to define a base class for a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. <p>Less importantly, the following constructs are illegal. All of them have alternatives which we think are usually better, so removing these limitations is not a high priority for us.<a name="multiple-inheritance-requires-qobject-to-be-first"><h3>Multiple Inheritance Requires QObject to Be First</h3> If you are using multiple inheritance, <tt>moc</tt> assumes that the first inherited class is a subclass of <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. Also, be sure that only the first inherited class is a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. <pre class="snippet">
// correct
class SomeClass : public QObject, public OtherClass
{
    ...
};
</pre> Virtual inheritance with <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> is not supported.<a name="function-pointers-cannot-be-signal-or-slot-parameters"><h3>Function Pointers Cannot Be Signal or Slot Parameters</h3> In most cases where you would consider using function pointers as signal or slot parameters, we think inheritance is a better alternative. Here is an example of illegal syntax: <pre class="snippet">
class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(void (*apply)(List *, void *), char *); // WRONG
};
</pre> You can work around this restriction like this: <pre class="snippet">
typedef void (*ApplyFunction)(List *, void *);

class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(ApplyFunction, char *);
};
</pre> It may sometimes be even better to replace the function pointer with inheritance and virtual functions.<a name="enums-and-typedefs-must-be-fully-qualified-for-signal-and-slot-parameters"><h3>Enums and Typedefs Must Be Fully Qualified for Signal and Slot Parameters</h3> When checking the signatures of its arguments, QObject::connect() compares the data types literally. Thus, Alignment and Qt::Alignment are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example: <pre class="snippet">
class MyClass : public QObject
{
    Q_OBJECT

    enum Error {
        ConnectionRefused,
        RemoteHostClosed,
        UnknownError
    };

signals:
    void stateChanged(MyClass::Error error);
};
</pre><a name="type-macros-cannot-be-used-for-signal-and-slot-parameters"><h3>Type Macros Cannot Be Used for Signal and Slot Parameters</h3> Since <tt>moc</tt> doesn't expand <tt>#define</tt>s, type macros that take an argument will not work in signals and slots. Here is an illegal example: <pre class="snippet">
#ifdef ultrix
#define SIGNEDNESS(a) unsigned a
#else
#define SIGNEDNESS(a) a
#endif

class Whatever : public QObject
{
    Q_OBJECT

signals:
    void someSignal(SIGNEDNESS(int));
};
</pre> A macro without parameters will work.<a name="nested-classes-cannot-have-signals-or-slots"><h3>Nested Classes Cannot Have Signals or Slots</h3> Here's an example of the offending construct: <pre class="snippet">
class A
{
public:
    class B
    {
        Q_OBJECT

    public slots:   // WRONG
        void b();
    };
};
</pre><a name="signal-slot-return-types-cannot-be-references"><h3>Signal/Slot return types cannot be references</h3> Signals and slots can have return types, but signals or slots returning references will be treated as returning void.<a name="only-signals-and-slots-may-appear-in-the-and-sections-of-a-class"><h3>Only Signals and Slots May Appear in the signals and slots Sections of a Class</h3><tt>signals</tt><tt>slots</tt> <tt>moc</tt> will complain if you try to put other constructs in the <tt>signals</tt> or <tt>slots</tt> sections of a class than signals and slots. <p><DT><b>See also:</b><br><DD><a href="metaobjects.html">Meta-Object System</a>, <a href="qtjambi-signalsandslots.html">Signals and Slots</a>, and <a href="properties.html">Qt's Property System</a>. <br></DD></DT><p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
