<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Deploying Qt Jambi Applications</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Deploying Qt Jambi Applications</h1></center><p> Java provides a number of different features which makes it easier to deploy applications, such as the Web Start technology, Java Archives (<tt>.jar</tt> files) and, of course, the virtual machine that enables you to compile your application to bytecode once and run on all architectures. <p>The apparent challenge when deploying Qt Jambi applications is that Qt Jambi makes use of Qt's C++ libraries which means that platform dependent code must be distributed in addition to the platform independent bytecode. Qt Jambi provides a solution - all you have to do is to include the native libraries in a JAR bundle. <p>To include resources, the programmer must follow a particular syntax since Qt Jambi provides its own resource system. But note that this system makes it easy to access any kind of resource (e.g., pixmaps, translation files and xml data files), no matter whether they are located, directly on the disk or in a JAR bundle. <p>We will first take a look at which building blocks make up a Qt Jambi application. Then we will look at three common deployment scenarios, pure Qt Jambi applications, Qt Jambi applications making use of custom generated code and finally C++ applications making use of Qt Jambi. Where applicable, we'll also take a look at how one can bundle the application into a webstart application and/or a single executable .jar file. <ul><li> <a href="#composition-of-a-deployment-package">Composition of a Deployment Package</a></li> <ul><li> <a href="#class-files">Class Files</a></li><li> <a href="#native-libraries">Native Libraries</a></li> <ul><li> <a href="#qt-jambi-libraries">Qt Jambi libraries</a></li><li> <a href="#qt-libraries">Qt Libraries</a></li><li> <a href="#runtime-libraries">Runtime Libraries</a></li><li> <a href="#plugins">Plugins</a></li></ul></ul><li> <a href="#deployment-scenarios">Deployment Scenarios</a></li> <ul><li> <a href="#deploying-a-pure-qt-jambi-application">Deploying a Pure Qt Jambi Application</a></li> <ul><li> <a href="#creating-a-webstart-application">Creating a Webstart Application</a></li><li> <a href="#creating-an-executable-java-archive">Creating an Executable Java Archive</a></li><li> <a href="#creating-an-application-bundle-using-mac-os-x-jarbundler">Creating an Application Bundle using Mac OS X JarBundler</a></li></ul><li> <a href="#deploying-a-qt-jambi-application-making-use-of-generated-code">Deploying a Qt Jambi Application making use of generated code</a></li> <ul><li> <a href="#build-your-own-binaries">Build Your Own Binaries</a></li><li> <a href="#create-a-platform-archive">Create a Platform Archive</a></li><li> <a href="#creating-webstart-and-executable-archives">Creating Webstart and Executable Archives</a></li></ul><li> <a href="#deploying-a-native-application-using-qt-jambi">Deploying a Native Application using Qt Jambi</a></li> <ul><li> <a href="#building-the-sources">Building the Sources</a></li><li> <a href="#configuring-the-library-path">Configuring the Library Path</a></li><li> <a href="#setting-the-plugin-path">Setting the Plugin Path</a></li></ul><li> <a href="#troubleshooting">Troubleshooting</a></li></ul><li> <a href="#including-resources">Including Resources</a></li></ul><a name="composition-of-a-deployment-package"><h2>Composition of a Deployment Package</h2> A Qt Jambi application will contain a set of application class files, the Qt Jambi library class files and a collection of native libraries. In addition to these, it may contain resources such as images, translation files and data. It may also include some of the Qt C++ plugins to add support for additional image formats or accessibility etc. As the application class files are handled by the user, we won't go into details on these here. <p>The details covered in this section are primarly informational and a lot is handled automatically by Qt Jambi. When deploying a Java application making use of Qt Jambi and no other native libraries, all of this can be ignored. See the "Deploying a Pure Qt Jambi Application" section.<a name="class-files"><h3>Class Files</h3> The Qt Jambi class files are located in the library classed <tt>qtjambi.jar</tt> which is available in the root of the binary package and also in the root of a source package after the <tt>ant</tt> script has completed. The <tt>qtjambi.jar</tt> file also contains some resources that may be needed by some classes so it should be used as-is.<a name="native-libraries"><h3>Native Libraries</h3> In a prebuilt Qt Jambi package there are a number of different native libraries, located in certain subdirectories of the root directory. In the library directory, which is <tt>bin</tt> under Windows and <tt>lib</tt> under Linux and Mac OS X, one can find Qt libraries, Qt Jambi libraries and runtime libraries. The Qt C++ plugins can be found in the subdirectories of the <tt>JAMBIDIR/plugins</tt> directory in the prebuilt package.<a name="qt-jambi-libraries"><h4>Qt Jambi libraries</h4> Qt Jambi libraries are the libraries that implement the <tt>native</tt> part of Java functions and are usually named according to the package they implement, such as <tt>com_trolltech_qt_gui</tt> for the native implementation of the <tt>com.trolltech.qt.gui</tt> package. Qt Jambi libraries are explicitly loaded by Qt Jambi using called to <tt>System.load()</tt> or similar. These packages are named as following: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Platform</center></th><th><center> Prefix</center></th><th><center> Suffix</center></th><th><center> Example</center></th></tr></thead><tr valign="top" class="even"><td> Windows</td><td> None</td><td> .dll</td><td> qtjambi.dll</td></tr><tr valign="top" class="odd"><td> Linux</td><td> lib</td><td> .so</td><td> libqtjambi.so</td></tr><tr valign="top" class="even"><td> Mac OS X</td><td> lib</td><td> .jnilib</td><td> libqtjambi.jnilib</td></tr></table><a name="qt-libraries"><h4>Qt Libraries</h4> While the Qt Jambi libraries implement the native part of the Java functions, they merly translate the Java function calls into C++ function calls and calls into the Qt libraries. This means that the Qt Jambi libraries link against the Qt libraries and are dependent of them. For a process to be able to load a given library, it must be able to locate and load all its dependencies. Qt Jambi explicitly loads the dependent Qt libraries of a Qt Jambi library directly before trying to load a Qt library. This makes sure that the process has the library loaded and dependecies are resolved. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Platform</center></th><th><center> Prefix</center></th><th><center> Suffix</center></th><th><center> Example</center></th></tr></thead><tr valign="top" class="even"><td> Windows</td><td> None</td><td> .dll</td><td> QtCore4.dll</td></tr><tr valign="top" class="odd"><td> Linux</td><td> lib</td><td> .so.4</td><td> libQtCore.so.4</td></tr><tr valign="top" class="even"><td> Mac OS X</td><td> lib</td><td> .4.dylib</td><td> libQtCore.4.dylib</td></tr></table><a name="runtime-libraries"><h4>Runtime Libraries</h4> The Qt libraries also have dependencies on runtime libraries. For instance, if Qt Jambi was compiled with GCC 3.3, it would depend on the <tt>libstdc++.so.5</tt>, which is not always present on newer linux distributions. To be able to run on newer linux distributions this runtime library needs to be available and loaded/available prior to loading the Qt libraries. Qt Jambi calls these libraries "system libraries" and will load them based on a platform specific deployment specification. The specific runtimes depend on the C++ compiler used to build Qt and the operating system. <table align="center" border="0" cellpadding="2" cellspacing="1" width="75%"><thead><tr class="qt-style" valign="top"><th><center> Compiler</center></th><th><center> Runtime Libraries</center></th></tr></thead><tr valign="top" class="even"><td> MSVC 6.0</td><td> msvcr60.dll, msvcp60.dll</td></tr><tr valign="top" class="odd"><td> MSVC 2002</td><td> msvcr70.dll, msvcp70.dll</td></tr><tr valign="top" class="even"><td> MSVC 2003</td><td> msvcr71.dll, msvcp71.dll</td></tr><tr valign="top" class="odd"><td> MinGW</td><td> mingwm10.dll</td></tr><tr valign="top" class="even"><td> GCC 3.3 and older</td><td> libstdc++.so.5</td></tr><tr valign="top" class="odd"><td> GCC 3.4 and newer</td><td> libstdc++.so.6</td></tr><tr valign="top" class="even"><td> GCC on Mac OS X</td><td> no dependencies</td></tr><tr valign="top" class="odd"><td> MSVC 2005 and 2008</td><td> Microsoft Visual Studio 2005 and 2008 introduces manifest files as a way of describing dependencies between dll's. This restricts the way binaries can be deployed. Manifest based runtime libraries will in this case need to be available for Qt Jambi to load. These files are not available by default on Windows Vista, Windows XP nor Windows 2000. This is solved by either: <ul><li> Installing manifest based runtimes on the target system using Microsoft's Visual Studio Redistributable Package. At the time of writing this is possible using the application "vcredist_x86.exe", which is provided on the <tt>microsoft.com</tt> websites.</li><li> Redistribute the runtime libraries provided in the Qt Jambi package or in your own Visual Studio version along with their manifest next to every .dll. The redistributables can be placed either directly next to the Qt Jambi .dll's or in a subdirectory called Microsoft.VC80.CRT for MSVC 2005 and Microsoft.VC90.CRT for MSVC 2008. For projects with .dll's in multiple folders, such as the Qt Jambi plugins in the plugin sub directory, the files need to be duplicated in all places. Note: Since Qt treats all .dll files in a plugin folder as a plugin it will try to load the the runtime libraries as plugins. To prevent this, it is recommended that the redistributable runtime libraries are placed in a sub directory under each plugin.</li></ul></td></tr></table> To get a full overview of the dependencies of a library there are some tools available. <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Platform</center></th><th><center> Tools</center></th></tr></thead><tr valign="top" class="even"><td> Windows</td><td> <tt>depends.exe</tt>, GUI tool part of MSVC</td></tr><tr valign="top" class="odd"><td> Windows</td><td> <tt>dumpbin /dependents</tt>, command line tool part of MSVC</td></tr><tr valign="top" class="even"><td> Linux</td><td> <tt>ldd</tt>, command line tool, part of GCC</td></tr><tr valign="top" class="odd"><td> Mac OS X</td><td> <tt>otool</tt> -L, standard tool</td></tr></table><a name="plugins"><h4>Plugins</h4> Finally there are the Qt C++ plugins, which are loaded by Qt at runtime to support some features, such as loading / saving of jpeg images. By default, Qt will locate the plugin libraries where the C++ library was built, which is convenient for Qt C++ developers but less relevant for Qt Jambi developers or for deployment. It is possible to extend the default search location by adding directories to the environment variable <tt>QT_PLUGIN_PATH</tt> or by making a call to <tt>QApplication.addLibraryPath()</tt> in the Java code. Both will add searchpaths for Qt to look for plugins.<a name="deployment-scenarios"><h2>Deployment Scenarios</h2> In this section we'll look more closely at the three primary deployment scenarios that we picture for Qt Jambi. The first and easiest one is to deploy a pure Qt Jambi Application, not relying on any other native libraries than the Qt Jambi ones. Then we look at the scenario where a user has used the Qt Jambi generator to map his own libraries and deploys an application of native libraries from both Qt Jambi his own generated project. Finally we'll look at how it is possible to deploy a C++ application that makes use of Qt Jambi, like our own tool Qt Designer does. <p>Since 4.4, Qt Jambi provide two ways of loading libraries. The first and recommended one is via <tt>.jar</tt> file using a deployment specification. A deployment specification contains a list of all libraries to be loaded, directories they reside in and how Qt Jambi should treat them, be it a runtime library, Qt library, JNI library or a plugin. The benefit of this approach is that Qt Jambi handles custom plugin paths and loading of runtime libraries, etc and the user only has to relate to a <tt>.jar</tt> file as with any other Java application. A platform specific <tt>.jar</tt> file for your platform is available in the Qt Jambi binary package. <p>The other alternative for loading native libraries is by relying on the traditional method for loading native libraries into Java, which is to make sure that libraries are available in a directory specified in <tt>-Djava.library.path</tt> and simply load them. In this case <tt>QT_PLUGIN_PATH</tt> and dependency on runtime libraries has to be handled by the user. Using this method it would theoretically be possible to use pre-installed versions of Qt on a given system, such as a Linux distribution, but we <b>strongly discourage</b> this, as the libraries installed on the system may be binary incompatible with the libraries shipped with Qt Jambi. Mixing binary incompatible libraries may lead to load errors and sporadic crashes. Using the <tt>.jar</tt> approach ensures that only the precise libraries you want to load, will be loaded, and is <b> significantly safer </b>.<a name="deploying-a-pure-qt-jambi-application"><h3>Deploying a Pure Qt Jambi Application</h3> This method of deployment should be used when the application either makes only use of pure Java code in combination with the Qt Jambi libraries. In this scenario the user should make use of the binary package for the target platform. The final application should then consist of the following three pieces: <ul><li> The application classes, for instance called application.jar. This .jar file should only contain classes, making it cross platform.</li><li> The Qt Jambi classes, called qtjambi-$VERSION.jar, available in the binary package. This .jar file contains only java classes and is cross platform.</li><li> The Qt Jambi platform bundle, called qtjambi-$PLATFORM-$VERSION.jar available in the binary package.</li></ul> The only thing needed to deploy this application is to make sure the three <tt>.jar</tt> files are available in the applications <tt>CLASSPATH</tt> and start it. To make an application that can launch on multiple platforms, use the qtjambi classes .jar file from along with the platform .jar-file from the binary packages of Qt Jambi for the target platforms that you would like to support and make sure the right platform <tt>.jar</tt> file is available in the classpath when you launch the application.<a name="creating-a-webstart-application"><h4>Creating a Webstart Application</h4> To create a webstart application based on Qt Jambi, specify the application <tt>.jar</tt> file along with the <tt>qtjambi-$VERSION.jar</tt> file as normal resources.<pre>&lt;resources&gt;
  &lt;j2se version="1.5+"/&gt;
  &lt;jar href="application.jar"/&gt;
  &lt;jar href="qtjambi-4.4.0_01.jar"/&gt;
&lt;/resources&gt;</pre> Then, for each target platform to support, add a compatible platform bundle. For instance to add support for Windows 32-bit:<pre>&lt;resources os="Windows" arch="x86"&gt;
  &lt;jar href="qtjambi-win32-msvc2005-4.4.0_01.jar"/&gt;
&lt;/resources&gt;</pre><a name="creating-an-executable-java-archive"><h4>Creating an Executable Java Archive</h4> To create an executable <tt>.jar</tt> file for one platform is straightforward, simply unpack the contents of the three <tt>.jar</tt> files and repack them together as one .jar file with the appropriate manifest specifying <tt>Main-Class</tt>, etc. <p>To create a <tt>.jar</tt> file that runs on multiple platforms is only possible by creating an executable <tt>.jar</tt> file which uses jar <tt>.jar</tt> files in the current directory. For instance, deploying <tt>application.jar</tt> for windows 32 and linux32 would require the following files:<pre>APPDIR\application.jar
APPDIR\qtjambi-4.4.0_01.jar
APPDIR\qtjambi-win32-msvc2005-4.4.0_01.jar
APPDIR\qtjambi-linux32-gcc3.3-4.4.0_01.jar</pre> Where <tt>application.jar</tt> has the <tt>Class-Path</tt> attribute in its Manifest set to include both the platform specific <tt>.jar</tt> files,<pre>Class-Path: qtjambi-4.4.0_01.jar qtjambi-win32-msvc2005-4.4.0_01.jar qtjambi-linux32-gcc3.3-4.4.0_01.jar</pre> As long as the four files are distributed together, the application will run on both windows and linux using the command:<pre>  &gt; java -jar application.jar</pre><a name="creating-an-application-bundle-using-mac-os-x-jarbundler"><h4>Creating an Application Bundle using Mac OS X JarBundler</h4> Mac OS X provides a powerful and simple to use tool that lets the user build Mac OS X Application Bundles that can be launched using Finder. This tool is called <tt>Jar Bundler</tt> and is by defualt located in <tt>/Developer/Applications/Java Tools/Jar Bundler</tt>. Using the tool, one can specify the three classes in the classpath and specify class with the main method used for launching. <p>When creating bundles, the <tt>-XstartOnFirstThread</tt> parameter is specified by putting the <tt>StartOnMainThread</tt> boolean property into the applications <tt>Info.plist</tt> under the <tt>Java</tt> section.<pre>    &lt;key&gt;Java&lt;/key&gt;
    &lt;dict&gt;
      &lt;key&gt;StartOnMainThread&lt;/key&gt; &lt;true/&gt;
      ... other java properties...
    &lt;/dict&gt;</pre><a name="deploying-a-qt-jambi-application-making-use-of-generated-code"><h3>Deploying a Qt Jambi Application making use of generated code</h3> This method of deployment should be used for deploying applications that contain native libraries generated using the Qt Jambi Generator. This approach should also apply when making use of your own native libraries, but some details may vary from project to project.<a name="build-your-own-binaries"><h4>Build Your Own Binaries</h4> When building your own libraries, it is evident that all the libraries in your project, both Qt, Qt Jambi and your own generated libraries are compiled with the same compiler based on the same configuration of Qt. <b>Do not use the prebuilt binary package for this kind of distribution</b>. Compiling every part of with the same configuration avoids any binary compatibility issues. How to build Qt and Qt Jambi is documented in the <a href="qtjambi-installation.html">Building Qt Jambi from a Source Package</a> document.<a name="create-a-platform-archive"><h4>Create a Platform Archive</h4> By default, the Qt Jambi <tt>ant</tt> build script will generate a platform archive containing all the Qt and Qt Jambi libraries. This is done using some Qt Jambi specific <tt>ant</tt> tasks, namely the <tt>com.trolltech.tools.ant.PlatformJarTask</tt>, responsible for packaging the libraries, and the <tt>com.trolltech.tools.ant.InitializeTask</tt>, responsible for setting up custom variables, etc required by the packaging process. <p>We highly recommend you use the <tt>ant</tt> tasks to build the platform archive, as this will automate most of the work for you. Below we will walk through the steps of creating a custom platform archive containing Qt Core and Qt Gui and the jpeg plugin in addition to <tt>customlibrary</tt>. <p>Rather than using <tt>System.loadLibrary()</tt> to load custom libraries you should use <tt>com.trolltech.qt.Utilities.loadJambiLibrary()</tt> which supports loading native libraries via platform archives. <p>The <tt>build.xml</tt> file in the Qt Jambi source package can also be used as a source of information on how to build the platform archives.<pre>&lt;taskdef name="qtjambi-platform-jar"
         classpath="ant-qtjambi.jar"
         classname="com.trolltech.tools.ant.PlatformJarTask"/&gt;
&lt;taskdef name="qtjambi-initialize"
         classpath="ant-qtjambi.jar"
     classname="com.trolltech.tools.ant.InitializeTask"/&gt;</pre> These steps define the Qt Jambi ant tasks in the <tt>ant-qtjambi.jar</tt> archive as tasks for our ant script. The <tt>ant-qtjambi.jar</tt> file is built as part of the default build in the source package and is available once the source package is built. <p>The next step is to trigger the initialize task. This should be done early in the ant script as other tasks depends on it.<pre>&lt;qtjambi-initialize verbose="true" /&gt;</pre> Then at a later point, we go on to building the platform archive. This is done in three separate steps, first we define platform archive, but specifying which libraries should go into it and what kind of libraries they are. These libraries along with a generated deployment specification are copied to a temporary output directory. Then we bundle these libraries into our custom platform archive file, and finally we remove the temporary directory.<pre>&lt;target name="qtjambi-customplatform.jar"
    description="Creating .jar file with native libs..."&gt;

  &lt;qtjambi-platform-jar cacheKey="MyCompany.Application.${DSTAMP}.${TSTAMP}"
                        outdir="platform-output"&gt;</pre> The <tt>qtjambi-platform-jar</tt> section above starts the specification of the platform archive. One important piece here is the <b>cacheKey</b>, which is used to uniqly identify this set of libraries in the cache. If this key is not unique this platform archive may conflict with a different platform archive and the resulting application will most likely fail to run. <p>Then we go on to specify the Qt libraries that should be included. In this case we choose to inly include Qt Core and Qt Gui.<pre>    &lt;!-- Qt Libraries... --&gt;
    &lt;library name="QtCore"
             type="qt"
     rootPath="${qtjambi.qtdir}" /&gt;
    &lt;library name="QtGui"
         type="qt"
         rootPath="${qtjambi.qtdir}" /&gt;</pre> We specify the name of the library, excluding the platform specific suffix and extensions. The type of these libraries is <tt>qt</tt>, which means that we will assume the naming convention listed for Qt libraries above. Because plugins can have RPATH or similar set to load Qt Libraries from the <tt>bin</tt> or <tt>lib</tt> subdirectories, it is important that this directory structure is maintained in the final platform archive as well. We therefore only specify the <tt>rootPath</tt>, which describes the base on the directory structure and let the platform task figure out the correct subdirectory for the library. On windows for instance, the above results in files the following files inside the <tt>.jar</tt> file:<pre>  bin/QtCore4.dll
  bin/QtGui4.dll</pre> Then we move on to specify the <tt>jpeg</tt> plugin.<pre>    &lt;!-- Qt Plugins... --&gt;
    &lt;library name="qjpeg"
             type="plugin"
             rootPath="${qtjambi.qtdir}"
             subdir="plugins/imageformats"
             load="never"/&gt;

    &lt;plugin path="plugins" /&gt;</pre> In this case we override the operating system specific library subdirectory with the precise path to the plugin, since plugins don't follow the default library location. We also specify that the type of the library is a plugin which means that the library follows the naming convention for plugins. The we specify that the library should not be loaded explicitly. This is merly a safty measure, which will give us a runtime warning later if we try to explicitly load it ourselves. Finally we specify that the <tt>plugins</tt> subdirectory contains Qt C++ plugins, which tells Qt that the this part of the platform archive should be used by Qt to load C++ plugins. <p>Then we include the Qt Jambi JNI libraries. We always need to include the <tt>qtjambi</tt> library in addition to the JNI libraries for the Qt modules we are using, in this case Qt Core and Qt Gui, and finally our own custom library.<pre>    &lt;!-- Qt Jambi Libraries --&gt;
    &lt;library name="qtjambi"                  type="qtjambi" rootPath="${env.JAMBIDIR}" /&gt;
    &lt;library name="com_trolltech_qt_core"    type="qtjambi" rootPath="${env.JAMBIDIR}" /&gt;
    &lt;library name="com_trolltech_qt_gui"     type="qtjambi" rootPath="${env.JAMBIDIR}" /&gt;
&lt;library name="customlibrary"        type="qtjambi" rootPath="." subdir="." /&gt;

  &lt;/qtjambi-platform-jar&gt;</pre> The <tt>rootPath</tt> of the jambi libraries are referring to the environment variable <tt>JAMBIDIR</tt> which we assume is set in this case. The type of the libraries are qtjambi which means that they follow normal JNI naming rules for this platform, as specified in the table above. In addition we include <tt>customlibrary</tt> from the current directory. That is the final part of the <tt>qtjambi-platform-jar</tt> sub-task and we close it. <p>Then we move on to packaing the files into a <tt>.jar</tt> file and clearing the temporary directory.<pre>  &lt;jar destfile="mycustomjar-${qtjambi.osname}-${qtjambi.compiler}-${qtjambi.version}.jar"&gt;
    &lt;fileset dir="platform-output" /&gt;
  &lt;/jar&gt;

  &lt;delete dir="platform-output"/&gt;
&lt;/target&gt;</pre> Using these steps in an <tt>ant</tt> build script, building a custom platform archive is pretty straight forward.<a name="creating-webstart-and-executable-archives"><h4>Creating Webstart and Executable Archives</h4> Once the previous step is completed you have your own platform archive and can perform the steps outlined under section <a href="qtjambi-deployment.html#deploying-a-pure-qt-jambi-application">Deploying a Pure Qt Jambi Application</a> above and replace the qtjambi platform archive with our own archives.<a name="deploying-a-native-application-using-qt-jambi"><h3>Deploying a Native Application using Qt Jambi</h3> This section describes the less used scenario where a C++ application instantiates a virtual machine and starts making use of Qt Jambi. This is the case with for instance our own Qt Designer. The main problem in this case is that Qt will already be loaded into the process as part of the C++ application, prior to Qt Jambi starting. If loading is done via a platform archive, Qt Jambi will try to load the same libraries again, and the process will fail. The platform archive approach can for this reason \b not be used for using Qt Jambi in native applications.<a name="building-the-sources"><h4>Building the Sources</h4> As with the section <a href="qtjambi-deployment.html#deploying-a-qt-jambi-application-making-use-of-generated-code">Deploying a Qt Jambi Application making use of generated code</a>, it is important that Qt, Qt Jambi and the application is built using the same compiler and configuration.<a name="configuring-the-library-path"><h4>Configuring the Library Path</h4> For Qt Jambi to be able to load libraries, they need to be available through <tt>-Djava.library.path</tt>. This is for instance done by setting the environment variables: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Platform</center></th><th><center> Environment Variable</center></th></tr></thead><tr valign="top" class="even"><td> Windows</td><td> PATH</td></tr><tr valign="top" class="odd"><td> Linux</td><td> LD_LIBRARY_PATH</td></tr><tr valign="top" class="even"><td> Mac OS X</td><td> DYLD_LIBRARY_PATH</td></tr></table> It is also possible to explicitly set these variables using calls to <tt>setenv</tt> or by initializing the Virtual Maching with the appropriate input parameters.<a name="setting-the-plugin-path"><h4>Setting the Plugin Path</h4> One also need to set up the plugin path, either by specifying the environment variable <tt>QT_PLUGIN_PATH</tt> or by making explicit calls to <tt>QApplication.addLibraryPath()</tt>, if the application needs to find the Qt C++ Plugins.<a name="troubleshooting"><h3>Troubleshooting</h3> The most common problem when deploying is that the native libraries are not found. With the archive based deployment techniques this should be significantly simpler that in previous version of Qt Jambi, but in the event something failing, there are some standard topics to investigate to see where it fails. <ul><li> Enable verbose loading to better see what Qt Jambi does when trying to load libraries. This is done by starting the Virtual Machine with the option <tt>-Dcom.trolltech.qt.verbose-loading</tt>.</li><li> Check the dependency graph of the libraries you are distributing</li><li> Deploying binaries based on Microsoft Visual Studio 2005 or 2008 is hard, because of the manifests. Read the description above, the documentation on msdn.microsoft.com, and see how our platform archives are organized for guidance.</li><li> If you don't deploy a pure Qt Jambi application based on our binary package you must build <b>every</b> part binary your package yourself. If you mix parts from our Qt Jambi binary packages with system Qt or Qt binary packages, you will most likely run into problems.</li><li> Verify that the correct libraries are in fact loaded. If a Virtual Machine crashes the hs_err_xxx.log file contains a list of all libraries loaded into the process. There are also tools on each platform that can profile and detect which libraries are being loaded into the path. Be aware of the paths like /usr/lib are always part of LD_LIBRARY_PATH for instance.</li></ul><a name="including-resources"><h2>Including Resources</h2> Qt Jambi provides a complete file system abstraction that allows a uniform syntax (based on the Java classpath) for accessing resources, whether they are located directly on the disk or in a JAR bundle. While the standard Java API only supports accessing resources in an undocumented subset of its file I/O operations (which does not include the <tt>java.io.File</tt> class), Qt Jambi allows resources to be used wherever a file name is expected. Resources are identified by a <tt>classpath</tt>: prefix. <br><center><img src="images/accessing-resources.png"></center><br> Note that it is also possible to load resources as raw data:<pre>    QFile file = new QFile("classpath:images/fileopen.png");
    file.open(QIODevice.OpenModeFlag.ReadOnly);
    QByteArray rawData = file.readAll();</pre> To include resources in your distribution, all you have to do is to ensure that the application follows the Qt Jambi syntax for accessing resources and make the resources available by adding them to your JAR bundle.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
