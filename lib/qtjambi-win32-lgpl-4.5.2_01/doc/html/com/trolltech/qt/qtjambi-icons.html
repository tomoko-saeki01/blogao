<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Icons Example</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Icons Example</h1></center><p> <b>Code</b>: <ul><li> <a href="qtjambi-icons-code.html">Icons.java</a></li></ul> The Icons example shows how <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> can generate pixmaps reflecting an icon's state, mode and size. These pixmaps are generated from the set of pixmaps made available to the icon, and are used by Qt widgets to show an icon representing a particular action. <br><center><img src="images/icons-example.png"></center><br> Contents: <ul><li> <a href="#qicon-overview">QIcon Overview</a></li><li> <a href="#overview-of-the-icons-application">Overview of the Icons Application</a></li><li> <a href="#line-by-line-walkthrough">Line-by-Line Walkthrough</a></li> <ul><li> <a href="#iconpreviewarea-class-definition">IconPreviewArea Class Definition</a></li><li> <a href="#the-class-icon">The Class Icon</a></li><li> <a href="#the-iconsizespinbox-class">The IconSizeSpinBox Class</a></li><li> <a href="#the-imagedelegate-class">The ImageDelegate Class</a></li></ul></ul><a name="qicon-overview"><h2>QIcon Overview</h2> The <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> class provides scalable icons in different modes and states. An icon's state and mode are depending on the intended use of the icon. Qt currently defines four modes: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Mode</center></th><th><center> Description</center></th></tr></thead><tr valign="top" class="even"><td> <a href="../../../com/trolltech/qt/gui/QIcon.Mode.html">QIcon::Normal</a></td><td> Display the pixmap when the user is not interacting with the icon, but the functionality represented by the icon is available.</td></tr><tr valign="top" class="odd"><td> <a href="../../../com/trolltech/qt/gui/QIcon.Mode.html">QIcon::Active</a></td><td> Display the pixmap when the functionality represented by the icon is available and the user is interacting with the icon, for example, moving the mouse over it or clicking it.</td></tr><tr valign="top" class="even"><td> <a href="../../../com/trolltech/qt/gui/QIcon.Mode.html">QIcon::Disabled</a></td><td> Display the pixmap when the functionality represented by the icon is not available.</td></tr><tr valign="top" class="odd"><td> <a href="../../../com/trolltech/qt/gui/QIcon.Mode.html">QIcon::Selected</a></td><td> Display the pixmap when the icon is selected.</td></tr></table> <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a>'s states are <a href="../../../com/trolltech/qt/gui/QIcon.State.html">QIcon::On</a> and <a href="../../../com/trolltech/qt/gui/QIcon.State.html">QIcon::Off</a>, which will display the pixmap when the widget is in the respective state. The most common usage of <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a>'s states are when displaying checkable tool buttons or menu entries (see <a href="../../../com/trolltech/qt/gui/QAbstractButton.html#setCheckable(boolean)">QAbstractButton::setCheckable()</a> and <a href="../../../com/trolltech/qt/gui/QAction.html#setCheckable(boolean)">QAction::setCheckable()</a>). When a tool button or menu entry is checked, the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a>'s state is <a href="../../../com/trolltech/qt/gui/QIcon.State.html">On</a>, otherwise it's <a href="../../../com/trolltech/qt/gui/QIcon.State.html">Off</a>. You can, for example, use the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a>'s states to display differing pixmaps depending on whether the tool button or menu entry is checked or not. <p>A <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> can generate smaller, larger, active, disabled, and selected pixmaps from the set of pixmaps it is given. Such pixmaps are used by Qt widgets to show an icon representing a particular action.<a name="overview-of-the-icons-application"><h2>Overview of the Icons Application</h2> With the Icons application you get a preview of an icon's generated pixmaps reflecting its different states, modes and size. <p>When an image is loaded into the application, it is converted into a pixmap and becomes a part of the set of pixmaps available to the icon. An image can be excluded from this set by checking off the related checkbox. The application provides a sub directory containing sets of images explicitly designed to illustrate how Qt renders an icon in different modes and states. <p>The application allows you to manipulate the icon size with some predefined sizes and a spin box. The predefined sizes are style dependent, but most of the styles have the same values: Only the Macintosh style differ by using 32 pixels, instead of 16 pixels, for toolbar buttons. You can navigate between the available styles using the <b>View</b> menu. <br><center><img src="images/icons-view-menu.png"></center><br> The <b>View</b> menu also provide the option to make the application guess the icon state and mode from an image's file name. The <b>File</b> menu provide the options of adding an image and removing all images. These last options are also available through a context menu that appears if you press the right mouse button within the table of image files. In addition, the <b>File</b> menu provide an <b>Exit</b> option, and the <b>Help</b> menu provide information about the example and about Qt. <br><center><img src="images/icons_find_normal.png"></center><br> The screenshot above shows the application with one image file loaded. The <b>Guess Image Mode/State</b> is enabled and the style is Plastique. <p>When <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> is provided with only one available pixmap, that pixmap is used for all the states and modes. In this case the pixmap's icon mode is set to normal, and the generated pixmaps for the normal and active modes will look the same. But in disabled and selected mode, Qt will generate a slightly different pixmap. <p>The next screenshot shows the application with an additional file loaded, providing <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> with two available pixmaps. Note that the new image file's mode is set to disabled. When rendering the <b>Disabled</b> mode pixmaps, Qt will now use the new image. We can see the difference: The generated disabled pixmap in the first screenshot is slightly darker than the pixmap with the originally set disabled mode in the second screenshot. <br><center><img src="images/icons_find_normal_disabled.png"></center><br> When Qt renders the icon's pixmaps it searches through the set of available pixmaps following a particular algorithm. The algorithm is documented in <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a>, but we will describe some particular cases below. <br><center><img src="images/icons_monkey_active.png"></center><br> In the screenshot above, we have set <tt>monkey_on_32x32</tt> to be an Active/On pixmap and <tt>monkey_off_64x64</tt> to be Normal/Off. To render the other six mode/state combinations, <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> uses the search algorithm described in the table below: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Requested Pixmap</center></th><th><center> Preferred Alternatives (mode/state)</center></th></tr></thead><thead><tr class="qt-style" valign="top"><th><center> Mode</center></th><th><center> State</center></th><th><center> 1</center></th><th><center> 2</center></th><th><center> 3</center></th><th><center> 4</center></th><th><center> 5</center></th><th><center> 6</center></th><th><center> 7</center></th><th><center> 8</center></th></tr></thead><tr valign="top" class="even"><td rowspan=2> Normal</td><td> Off</td><td> <b>N0</b></td><td> A0</td><td> N1</td><td> A1</td><td> D0</td><td> S0</td><td> D1</td><td> S1</td></tr><tr valign="top" class="odd"><td> On</td><td> N1</td><td> <b>A1</b></td><td> N0</td><td> A0</td><td> D1</td><td> S1</td><td> D0</td><td> S0</td></tr><tr valign="top" class="even"><td rowspan=2> Active</td><td> Off</td><td> A0</td><td> <b>N0</b></td><td> A1</td><td> N1</td><td> D0</td><td> S0</td><td> D1</td><td> S1</td></tr><tr valign="top" class="odd"><td> On</td><td> <b>A1</b></td><td> N1</td><td> A0</td><td> N0</td><td> D1</td><td> S1</td><td> D0</td><td> S0</td></tr><tr valign="top" class="even"><td rowspan=2> Disabled</td><td> Off</td><td> D0</td><td> <b>N0'</b></td><td> A0'</td><td> D1</td><td> N1'</td><td> A1'</td><td> S0'</td><td> S1'</td></tr><tr valign="top" class="odd"><td> On</td><td> D1</td><td> N1'</td><td> <b>A1'</b></td><td> D0</td><td> N0'</td><td> A0'</td><td> S1'</td><td> S0'</td></tr><tr valign="top" class="even"><td rowspan=2> Selected</td><td> Off</td><td> S0</td><td> <b>N0''</b></td><td> A0''</td><td> S1</td><td> N1''</td><td> A1''</td><td> D0''</td><td> D1''</td></tr><tr valign="top" class="odd"><td> On</td><td> S1</td><td> N1''</td><td> <b>A1''</b></td><td> S0</td><td> N0''</td><td> A0''</td><td> D1''</td><td> D0''</td></tr></table> In the table, "0" and "1" stand for Off" and "On", respectively. Single quotes indicates that <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> generates a disabled ("grayed out") version of the pixmap; similarly, double quuote indicate that <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> generates a selected ("blued out") version of the pixmap. <p>The alternatives used in the screenshot above are shown in bold. For example, the Disabled/Off pixmap is derived by graying out the Normal/Off pixmap (<tt>monkey_off_64x64</tt>). <p>In the next screenshots, we loaded the whole set of monkey images. By checking or unchecking file names from the image list, we get different results: <table align="center" border="0" cellpadding="2" cellspacing="1"><tr valign="top" class="even"><td>  <br><center><img src="images/icons_monkey.png"></center><br></td><td>  <br><center><img src="images/icons_monkey_mess.png"></center><br></td></tr></table> For any given mode/state combination, it is possible to specify several images at different resolutions. When rendering an icon, <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> will automatically pick the most suitable image and scale it down if necessary. (<a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> never scales up images, because this rarely looks good.) <p>The screenshots below shows what happens when we provide <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> with three images (<tt>qtopia_16x16.png</tt>, <tt>qtopia_32x32.png</tt>, <tt>qtopia_48x48.png</tt>) and try to render the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> at various resolutions: <table align="center" border="0" cellpadding="2" cellspacing="1"><tr valign="top" class="even"><td></td><td>  <br><center><img src="images/icons_qtopia_8x8.png"></center><br></td><td>  <br><center><img src="images/icons_qtopia_16x16.png"></center><br></td><td>  <br><center><img src="images/icons_qtopia_17x17.png"></center><br></td></tr><tr valign="top" class="odd"><td></td><td> 8 x 8</td><td> <b>16 x 16</b></td><td> 17 x 17</td></tr><tr valign="top" class="even"><td>  <br><center><img src="images/icons_qtopia_32x32.png"></center><br></td><td>  <br><center><img src="images/icons_qtopia_33x33.png"></center><br></td><td>  <br><center><img src="images/icons_qtopia_48x48.png"></center><br></td><td>  <br><center><img src="images/icons_qtopia_64x64.png"></center><br></td></tr><tr valign="top" class="odd"><td> <b>32 x 32</b></td><td> 33 x 33</td><td> <b>48 x 48</b></td><td> 64 x 64</td></tr></table> For sizes up to 16 x 16, <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> uses <tt>qtopia_16x16.png</tt> and scales it down if necessary. For sizes between 17 x 17 and 32 x 32, it uses <tt>qtopia_32x32.png</tt>. For sizes above 32 x 32, it uses <tt>qtopia_48x48.png</tt>.<a name="line-by-line-walkthrough"><h2>Line-by-Line Walkthrough</h2> The Icons example consists of four classes: <ul><li> <tt>MainWindow</tt> inherits <a href="../../../com/trolltech/qt/gui/QMainWindow.html">QMainWindow</a> and is the main application window.</li><li> <tt>IconPreviewArea</tt> is a custom widget that displays all combinations of states and modes for a given icon.</li><li> <tt>IconSizeSpinBox</tt> is a subclass of <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a> that lets the user enter icon sizes (e.g., "48 x 48").</li><li> <tt>ImageDelegate</tt> is a subclass of <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> that provides comboboxes for letting the user set the mode and state associated with an image.</li></ul> We will start by reviewing the <tt>IconPreviewArea</tt> class before we take a look at the <tt>MainWindow</tt> class. Finally, we will review the <tt>IconSizeSpinBox</tt> and <tt>ImageDelegate</tt> classes.<a name="iconpreviewarea-class-definition"><h3>IconPreviewArea Class Definition</h3> An <tt>IconPreviewArea</tt> widget consists of a group box containing a grid of <a href="../../../com/trolltech/qt/gui/QLabel.html">QLabel</a> widgets displaying headers and pixmaps. <br><center><img src="images/icons_preview_area.png"></center><br> The <tt>IconPreviewArea</tt> class inherits <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>. It displays the generated pixmaps corresponding to an icon's possible states and modes at a given size. <p>We will now review the IconPreviewArea's implementation: <p>(I think we need to say something about the data members) <pre class="snippet">
        public IconPreviewArea()
        {
            QGridLayout mainLayout = new QGridLayout();
            setLayout(mainLayout);

            icon = new QIcon();

            stateLabels[0] = createHeaderLabel(tr("Off"));
            stateLabels[1] = createHeaderLabel(tr("On"));

            modeLabels[0] = createHeaderLabel(tr("Normal"));
            modeLabels[1] = createHeaderLabel(tr("Active"));
            modeLabels[2] = createHeaderLabel(tr("Disabled"));
            modeLabels[3] = createHeaderLabel(tr("Selected"));

            for (int j = 0; j &lt; NumStates; ++j)
                mainLayout.addWidget(stateLabels[j], j + 1, 0);

            for (int i = 0; i &lt; NumModes; ++i) {
                mainLayout.addWidget(modeLabels[i], 0, i + 1);

                for (int j = 0; j &lt; NumStates; ++j) {
                    pixmapLabels[i][j] = createPixmapLabel();
                    mainLayout.addWidget(pixmapLabels[i][j], j + 1, i + 1);
                }
            }
        }
</pre> In the constructor we create the labels displaying the headers and the icon's generated pixmaps, and add them to a grid layout. <pre class="snippet">
        public void setIcon(QIcon icon)
        {
            this.icon = icon;
            updatePixmapLabels();
        }

        public void setSize(QSize size)
        {
            if (size != this.size) {
                this.size = size;
                updatePixmapLabels();
            }
        }
</pre> The public <tt>setIcon()</tt> and <tt>setSize()</tt> methods change the icon or the icon size, and make sure that the generated pixmaps are updated. <pre class="snippet">
        private QLabel createHeaderLabel(String text)
        {
            QLabel label = new QLabel(tr("&lt;b&gt;"+text+"&lt;/b&gt;"));
            label.setAlignment(Qt.AlignmentFlag.AlignCenter);
            return label;
        }

        private QLabel createPixmapLabel()
        {
            QLabel label = new QLabel();
            label.setEnabled(false);
            label.setAlignment(Qt.AlignmentFlag.AlignCenter);
            label.setFrameShape(QFrame.Shape.Box);
            label.setSizePolicy(QSizePolicy.Policy.Expanding,
                                QSizePolicy.Policy.Expanding);
            label.setBackgroundRole(QPalette.ColorRole.Base);
            label.setAutoFillBackground(true);
            label.setMinimumSize(132, 132);
            return label;
        }
</pre> We use the <tt>createHeaderLabel()</tt> and <tt>createPixmapLabel()</tt> methods to create the preview area's labels displaying the headers and the icon's generated pixmaps. Both methods return the <a href="../../../com/trolltech/qt/gui/QLabel.html">QLabel</a> that is created. <pre class="snippet">
        private void updatePixmapLabels()
        {
            for (int i = 0; i &lt; NumModes; ++i) {
                QIcon.Mode mode;
                if (i == 0) {
                    mode = QIcon.Mode.Normal;
                } else if (i == 1) {
                    mode = QIcon.Mode.Active;
                } else if (i == 2) {
                    mode = QIcon.Mode.Disabled;
                } else {
                    mode = QIcon.Mode.Selected;
                }

                for (int j = 0; j &lt; NumStates; ++j) {
                    QIcon.State state = (j == 0) ? QIcon.State.Off : QIcon.State.On;
                    QPixmap pixmap = icon.pixmap(size, mode, state);
                    pixmapLabels[i][j].setPixmap(pixmap);
                    pixmapLabels[i][j].setEnabled(!pixmap.isNull());
                }
            }
        }
</pre> We use the private <tt>updatePixmapLabel()</tt> method to update the generated pixmaps displayed in the preview area. <p>For each mode, and for each state, we retrieve a pixmap using the <a href="../../../com/trolltech/qt/gui/QIcon.html#pixmap(com.trolltech.qt.core.QSize, com.trolltech.qt.gui.QIcon.Mode)">QIcon::pixmap()</a> method, which generates a pixmap corresponding to the given state, mode and size.<a name="the-class-icon"><h3>The Class Icon</h3> The <tt>Icons</tt> widget consists of three main elements: an images group box, an icons size group box and a preview area. <br><center><img src="images/icons-example.png"></center><br> The Icons class inherits from <a href="../../../com/trolltech/qt/gui/QMainWindow.html">QMainWindow</a>. We reimplement the constructor, and declare several private slots: <ul><li> The <tt>about()</tt> slot simply provides information about the example.</li><li> The <tt>changeStyle()</tt> slot changes the application's GUI style and adjust the style dependent size options.</li><li> The <tt>changeSize()</tt> slot changes the size of the preview area's icon.</li><li> The <tt>changeIcon()</tt> slot updates the set of pixmaps available to the icon displayed in the preview area.</li><li> The <tt>addImage()</tt> slot allows the user to load a new image into the application.</li></ul> In addition we declare several private methods - which will be examined later - to simplify the constructor. We will now review the implementation of the Icons class <pre class="snippet">
    public Icons()
    {
        centralWidget = new QWidget();
        setCentralWidget(centralWidget);

        createPreviewGroupBox();
        createImagesGroupBox();
        createIconSizeGroupBox();

        createActions();
        createMenus();
        createContextMenu();

        QGridLayout mainLayout = new QGridLayout();
        mainLayout.addWidget(previewGroupBox, 0, 0, 1, 2);
        mainLayout.addWidget(imagesGroupBox, 1, 0);
        mainLayout.addWidget(iconSizeGroupBox, 1, 1);
        centralWidget.setLayout(mainLayout);

        setWindowTitle(tr("Icons"));
        otherRadioButton.click();

        setTextOnRadioButtons();

        resize(minimumSizeHint());
    }
</pre> In the constructor, we first create the main window's central widget and its child widgets, and put them in a grid layout. Then we create the menus with their associated entries and actions. <p>Before we resize the application window to a suitable size, we set the window title and determine the current style for the application. We also enable the icon size spin box by clicking the associated radio button, making the current value of the spin box the icon's initial size. <pre class="snippet">
    private void about()
    {
        QMessageBox.about(this, tr("About Icons"),
            tr("The &lt;b&gt;Icons&lt;/b&gt; example illustrates how Qt renders an icon in "+
               "different modes (active, normal, disabled, and selected) and "+
               "states (on and off) based on a set of images."));
    }
</pre> The <tt>about()</tt> slot displays a message box using the static <a href="../../../com/trolltech/qt/gui/QMessageBox.html#about(com.trolltech.qt.gui.QWidget, java.lang.String, java.lang.String)">QMessageBox::about()</a> method. In this example it displays a simple box with information about the example. <p>The <tt>about()</tt> method looks for a suitable icon in four locations: It prefers its parent's icon if that exists. If it doesn't, the method tries the top-level widget containing parent, and if that fails, it tries the active window. As a last resort it uses the <a href="../../../com/trolltech/qt/gui/QMessageBox.html">QMessageBox</a>'s Information icon. <pre class="snippet">
    private void changeStyle(boolean checked)
    {
        if (!checked)
            return;

        QAction action = (QAction) QSignalEmitter.signalSender();
</pre> In the <tt>changeStyle()</tt> slot we first check the slot's parameter. If it is false we immediately return, otherwise we find out which style to change to, i.e. which action that triggered the slot, using the QSignalEmitter.signalSender() method. <p>This method returns the sender as a QSignalEmitter. Since we know that the sender is a <a href="../../../com/trolltech/qt/gui/QAction.html">QAction</a> object, we can safely cast the QSignalEmitter object. <pre class="snippet">
        QStyle style = QStyleFactory.create((String) action.data());


        if (style != null) {
            QApplication.setStyle(style);
            QApplication.setPalette(style.standardPalette());
        }

        setTextOnRadioButtons();

        changeSize(true);
    }
</pre> Once we have the action, we extract the style name using <a href="../../../com/trolltech/qt/gui/QAction.html#data()">QAction::data()</a>. Then we create a <a href="../../../com/trolltech/qt/gui/QStyle.html">QStyle</a> object using the static <a href="../../../com/trolltech/qt/gui/QStyleFactory.html#create(java.lang.String)">QStyleFactory::create()</a> method. <p>As a precaution, we check that the style is valid before we use the <a href="../../../com/trolltech/qt/gui/QApplication.html#setStyle(com.trolltech.qt.gui.QStyle)">QApplication::setStyle()</a> method to set the application's GUI style to the new style. <p>The predefined icon size options provided in the application are style dependent, so we need to update the labels in the icon size group box and in the end call the <tt>changeSize()</tt> slot to update the icon's size. <pre class="snippet">
    private void changeSize(int value)
    {
        changeSize(true);
    }
</pre> The <tt>changeSize()</tt> slot sets the size for the preview area's icon. <p>To determine the new size we first check if the spin box is enabled. If it is, we extract the extent of the new size from the box. If it's not, we search through the predefined size options, extract the <a href="../../../com/trolltech/qt/gui/QStyle.PixelMetric.html">QStyle::PixelMetric</a> and use the <a href="../../../com/trolltech/qt/gui/QStyle.html#pixelMetric(com.trolltech.qt.gui.QStyle.PixelMetric, com.trolltech.qt.gui.QStyleOption)">QStyle::pixelMetric()</a> method to determine the extent. Then we create a <a href="../../../com/trolltech/qt/core/QSize.html">QSize</a> object based on the extent, and use that object to set the size of the preview area's icon. <pre class="snippet">
    private void addImages()
    {
        List&lt;String&gt; fileNames = QFileDialog.getOpenFileNames(this,
                                    tr("Open Images"), "",
                                    new QFileDialog.Filter(tr("Images (*.png *.xpm *.jpg);;"+
                                       "All Files (*)")));
        if (!fileNames.isEmpty()) {
            for (String fileName : fileNames) {
                int row = imagesTable.rowCount();
                imagesTable.setRowCount(row + 1);
</pre> The first thing we do when the <tt>addImages()</tt> slot is called, is to show a file dialog to the user. The easiest way to create a file dialog is to use <a href="../../../com/trolltech/qt/gui/QFileDialog.html">QFileDialog</a>'s static methods. Here we use the <a href="../../../com/trolltech/qt/gui/QFileDialog.html#getOpenFileNames(com.trolltech.qt.gui.QWidget, java.lang.String, java.lang.String, com.trolltech.qt.gui.QFileDialog.Filter, com.trolltech.qt.gui.QFileDialog.Options)">getOpenFileNames()</a> method, which will return one or more existing files selected by the user. <p>For each of the files the file dialog returns, we add a row to the table widget. The table widget is listing the images the user has loaded into the application. <pre class="snippet">
                String imageName = new QFileInfo(fileName).baseName();

                QTableWidgetItem item0 = new QTableWidgetItem(imageName);
                item0.setData(Qt.ItemDataRole.UserRole, fileName);
                Qt.ItemFlags flags = item0.flags();
                flags.clear(Qt.ItemFlag.ItemIsEditable);
</pre> We retrieve the image name using the <a href="../../../com/trolltech/qt/core/QFileInfo.html#baseName()">QFileInfo::baseName()</a> method that returns the base name of the file without the path, and create the first table widget item in the row. Then we add the file's complete name to the item's data. Since an item can hold several information pieces, we need to assign the file name a role that will distinguish it from other data. This role can be Qt.ItemDataRole.UserRole or any value above it. <p>We also make sure that the item is not editable by removing the Qt.ItemFlag.ItemIsEditable flag. Table items are editable by default. <pre class="snippet">
                QTableWidgetItem item1 = new QTableWidgetItem(tr("Normal"));

                QTableWidgetItem item2 = new QTableWidgetItem(tr("Off"));

                if (guessModeStateAct.isChecked()) {
                    if (fileName.contains("_act")) {
                        item1.setText(tr("Active"));
                    } else if (fileName.contains("_dis")) {
                        item1.setText(tr("Disabled"));
                    } else if (fileName.contains("_sel")) {
                        item1.setText(tr("Selected"));
                    }

                    if (fileName.contains("_on"))
                        item2.setText(tr("On"));

                }
</pre> Then we create the second and third items in the row making the default mode Normal and the default state Off. But if the <b>Guess Image Mode/State</b> option is checked, and the file name contains "_act", "_dis", or "_sel", the modes are changed to Active, Disabled, or Selected. And if the file name contains "_on", the state is changed to On. The sample files in the example's <tt>images</tt> subdirectory respect this naming convension. <pre class="snippet">
                imagesTable.setItem(row, 0, item0);

                imagesTable.setItem(row, 1, item1);
                imagesTable.setItem(row, 2, item2);
                imagesTable.openPersistentEditor(item1);
                imagesTable.openPersistentEditor(item2);

                item0.setCheckState(Qt.CheckState.Checked);
            }
        }
    }
</pre> In the end we add the items to the associated row, and use the <a href="../../../com/trolltech/qt/gui/QTableWidget.html#openPersistentEditor(com.trolltech.qt.gui.QTableWidgetItem)">QTableWidget::openPersistentEditor()</a> method to create comboboxes for the mode and state columns of the items. <p>Due to the the connection between the table widget's itemChanged() signal and the <tt>changeIcon()</tt> slot, the new image is automatically converted into a pixmap and made part of the set of pixmaps available to the icon in the preview area. So we need to make sure that the new image's check box is enabled. <pre class="snippet">
    private void changeIcon()
    {
        QIcon icon = new QIcon();

        for (int row = 0; row &lt; imagesTable.rowCount(); ++row) {
            QTableWidgetItem item0 = imagesTable.item(row, 0);
            QTableWidgetItem item1 = imagesTable.item(row, 1);
            QTableWidgetItem item2 = imagesTable.item(row, 2);

            if (item0.checkState() == Qt.CheckState.Checked) {
                QIcon.Mode mode;
                if (item1.text().equals(tr("Normal"))) {
                    mode = QIcon.Mode.Normal;
                } else if (item1.text().equals(tr("Active"))) {
                    mode = QIcon.Mode.Active;
                } else if (item1.text().equals(tr("Disabled"))) {
                    mode = QIcon.Mode.Disabled;
                } else {
                    mode = QIcon.Mode.Selected;
                }

                QIcon.State state;
                if (item2.text().equals(tr("On"))) {
                    state = QIcon.State.On;
                } else {
                    state = QIcon.State.Off;

                }
</pre> The <tt>changeIcon()</tt> slot is called when the user alters the set of images listed in the <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a> to update the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> object rendered by the <tt>IconPreviewArea</tt>. <p>We first create a <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> object, and then we run through the <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a>, which lists the images the user has loaded into the application. <pre class="snippet">
                String fileName = (String) item0.data(Qt.ItemDataRole.UserRole);
                QImage image = new QImage(fileName);
                if (!image.isNull())
                    icon.addPixmap(QPixmap.fromImage(image), mode, state);

            }

        }
</pre> We also extract the image file's name using the <a href="../../../com/trolltech/qt/gui/QTableWidgetItem.html#data(int)">QTableWidgetItem::data()</a> method. This method takes a Qt::DataItemRole as an argument to retrieve the correct data (remember that an item can hold several pieces of information) and returns it as an Object. Then we use the <a href="../../../com/trolltech/qt/QVariant.html#toString(java.lang.Object)">QVariant::toString()</a> method to get the file name as a QString. <p>To create a pixmap from the file, we need to first create an image and then convert this image into a pixmap using <a href="../../../com/trolltech/qt/gui/QPixmap.html#fromImage(com.trolltech.qt.gui.QImage, com.trolltech.qt.core.Qt.ImageConversionFlag[])">QPixmap::fromImage()</a>. Once we have the final pixmap, we add it, with its associated mode and state, to the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a>'s set of available pixmaps. <pre class="snippet">
        previewArea.setIcon(icon);
    }
</pre> After running through the entire list of images, we change the icon of the preview area to the one we just created. <pre class="snippet">
    private void removeAllImages()
    {
        imagesTable.setRowCount(0);
        changeIcon();
    }
</pre> In the <tt>removeAllImages()</tt> slot, we simply set the table widget's row count to zero, automatically removing all the images the user has loaded into the application. Then we update the set of pixmaps available to the preview area's icon using the <tt>changeIcon()</tt> slot. <br><center><img src="images/icons_images_groupbox.png"></center><br> The <tt>createImagesGroupBox()</tt> method is implemented to simplify the constructor. The main purpose of the method is to create a <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a> that will keep track of the images the user has loaded into the application. <pre class="snippet">
    private void createImagesGroupBox()
    {
        imagesGroupBox = new QGroupBox(tr("Images"));

        imagesTable = new QTableWidget();
        imagesTable.setSelectionMode(QAbstractItemView.SelectionMode.NoSelection);
        imagesTable.setItemDelegate(new ImageDelegate(this));
</pre> First we create a group box that will contain the table widget. Then we create a <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a> and customize it to suit our purposes. <p>We call <a href="../../../com/trolltech/qt/gui/QAbstractItemView.html#setSelectionMode(com.trolltech.qt.gui.QAbstractItemView.SelectionMode)">QAbstractItemView::setSelectionMode()</a> to prevent the user from selecting items. <p>The <a href="../../../com/trolltech/qt/gui/QAbstractItemView.html#setItemDelegate(com.trolltech.qt.gui.QAbstractItemDelegate)">QAbstractItemView::setItemDelegate()</a> call sets the item delegate for the table widget. We create a <tt>ImageDelegate</tt> that we make the item delegate for our view. <p>The <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> class can be used to provide an editor for an item view class that is subclassed from <a href="../../../com/trolltech/qt/gui/QAbstractItemView.html">QAbstractItemView</a>. Using a delegate for this purpose allows the editing mechanism to be customized and developed independently from the model and view. <p>In this example we derive <tt>ImageDelegate</tt> from <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a>. <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> usually provides line editors, while our subclass <tt>ImageDelegate</tt>, provides comboboxes for the mode and state fields. <pre class="snippet">
        List&lt;String&gt; labels = new LinkedList&lt;String&gt;();

        labels.add(tr("Image"));
        labels.add(tr("Mode"));
        labels.add(tr("State"));

        imagesTable.horizontalHeader().setDefaultSectionSize(90);
        imagesTable.setColumnCount(3);
        imagesTable.setHorizontalHeaderLabels(labels);
        imagesTable.horizontalHeader().setResizeMode(0, QHeaderView.ResizeMode.Stretch);
        imagesTable.horizontalHeader().setResizeMode(1, QHeaderView.ResizeMode.Fixed);
        imagesTable.horizontalHeader().setResizeMode(2, QHeaderView.ResizeMode.Fixed);
        imagesTable.verticalHeader().hide();
</pre> Then we customize the <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a>'s horizontal header, and hide the vertical header. <pre class="snippet">
        imagesTable.itemChanged.connect(this, "changeIcon()");


        QVBoxLayout layout = new QVBoxLayout();
        layout.addWidget(imagesTable);
        imagesGroupBox.setLayout(layout);
    }
</pre> At the end, we connect the QTableWidget::itemChanged() signal to the <tt>changeIcon()</tt> slot to ensuret that the preview area is in sync with the image table. <br><center><img src="images/icons_size_groupbox.png"></center><br> The <tt>createIconSizeGroupBox()</tt> method is called from the constructor. It creates the widgets controlling the size of the preview area's icon. <pre class="snippet">
    private void createIconSizeGroupBox()
    {
        iconSizeGroupBox = new QGroupBox(tr("Icon Size"));

        smallRadioButton = new QRadioButton();
        largeRadioButton = new QRadioButton();
        toolBarRadioButton = new QRadioButton();
        listViewRadioButton = new QRadioButton();
        iconViewRadioButton = new QRadioButton();
        tabBarRadioButton = new QRadioButton();
        otherRadioButton = new QRadioButton(tr("Other:"));

        otherSpinBox = new IconSizeSpinBox();
        otherSpinBox.setRange(8, 128);
        otherSpinBox.setValue(64);
</pre> First we create a group box that will contain all the widgets. Then we create the radio buttons and the spin box. <p>The spin box is not a regular <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a> but an <tt>IconSizeSpinBox</tt>. The <tt>IconSizeSpinBox</tt> class inherits <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a> and reimplements two methods: <a href="../../../com/trolltech/qt/gui/QSpinBox.html#textFromValue(int)">QSpinBox::textFromValue()</a> and <a href="../../../com/trolltech/qt/gui/QSpinBox.html#valueFromText(java.lang.String)">QSpinBox::valueFromText()</a>. The <tt>IconSizeSpinBox</tt> is designed to handle icon sizes, e.g., "32 x 32", instead of plain integer values. <pre class="snippet">
        smallRadioButton.toggled.connect(this, "changeSize(boolean)");
        largeRadioButton.toggled.connect(this, "changeSize(boolean)");
        toolBarRadioButton.toggled.connect(this, "changeSize(boolean)");
        listViewRadioButton.toggled.connect(this, "changeSize(boolean)");
        iconViewRadioButton.toggled.connect(this, "changeSize(boolean)");
        tabBarRadioButton.toggled.connect(this, "changeSize(boolean)");
        otherRadioButton.toggled.connect(this, "changeSize(boolean)");
        otherSpinBox.valueChanged.connect(this, "changeSize(int)");

        QHBoxLayout otherSizeLayout = new QHBoxLayout();
        otherSizeLayout.addWidget(otherRadioButton);
        otherSizeLayout.addWidget(otherSpinBox);
        otherSizeLayout.addStretch();

        QGridLayout layout = new QGridLayout();
        layout.addWidget(smallRadioButton, 0, 0);
        layout.addWidget(largeRadioButton, 1, 0);
        layout.addWidget(toolBarRadioButton, 2, 0);
        layout.addWidget(listViewRadioButton, 0, 1);
        layout.addWidget(iconViewRadioButton, 1, 1);
        layout.addWidget(tabBarRadioButton, 2, 1);
        layout.addLayout(otherSizeLayout, 3, 0, 1, 2);
        layout.setRowStretch(4, 1);
        iconSizeGroupBox.setLayout(layout);
    }
</pre> Then we connect all of the radio buttons toggled() signals and the spin box's valueChanged() signal to the <tt>changeSize()</tt> slot to make sure that the size of the preview area's icon is updated whenever the user changes the icon size. In the end we put the widgets in a layout that we install on the group box. <pre class="snippet">
    private void createActions()
    {
        addImagesAct = new QAction(tr("&Add Images..."), this);
        addImagesAct.setShortcut(tr("Ctrl+A"));
        addImagesAct.triggered.connect(this, "addImages()");

        removeAllImagesAct = new QAction(tr("&Remove All Images"), this);
        removeAllImagesAct.setShortcut(tr("Ctrl+R"));
        removeAllImagesAct.triggered.connect(this, "removeAllImages()");

        exitAct = new QAction(tr("&Quit"), this);
        exitAct.setShortcut(tr("Ctrl+Q"));
        exitAct.triggered.connect(this, "close()");

        styleActionGroup = new QActionGroup(this);
        for (String styleName : QStyleFactory.keys()) {
            QAction action = new QAction(styleActionGroup);
            action.setText(styleName + " Style");
            action.setData(styleName);
            action.setCheckable(true);
            action.triggered.connect(this, "changeStyle(boolean)");
        }

        guessModeStateAct = new QAction(tr("&Guess Image Mode/State"), this);
        guessModeStateAct.setCheckable(true);
        guessModeStateAct.setChecked(true);

        aboutAct = new QAction(tr("&About"), this);
        aboutAct.triggered.connect(this, "about()");

        aboutQtAct = new QAction(tr("About &Qt"), this);
        aboutQtAct.triggered.connect(QApplication.instance(), "aboutQt()");
    }
</pre> In the <tt>createActions()</tt> method we create and customize all the actions needed to implement the functionality associated with the menu entries in the application. <p>In particular we create the <tt>styleActionGroup</tt> based on the currently available GUI styles using <a href="../../../com/trolltech/qt/gui/QStyleFactory.html">QStyleFactory</a>. <a href="../../../com/trolltech/qt/gui/QStyleFactory.html#keys()">QStyleFactory::keys()</a> returns a list of valid keys, typically including "windows", "motif", "cde", and "plastique". Depending on the platform, "windowsxp" and "macintosh" may be available. <p>We create one action for each key, and adds the action to the action group. Also, for each action, we call <a href="../../../com/trolltech/qt/gui/QAction.html#setData(java.lang.Object)">QAction::setData()</a> with the style name. We will retrieve it later using <a href="../../../com/trolltech/qt/gui/QAction.html#data()">QAction::data()</a>. <pre class="snippet">
    private void createMenus()
    {
        fileMenu = menuBar().addMenu(tr("&File"));
        fileMenu.addAction(addImagesAct);
        fileMenu.addAction(removeAllImagesAct);
        fileMenu.addSeparator();
        fileMenu.addAction(exitAct);

        viewMenu = menuBar().addMenu(tr("&View"));
        for (QAction action : styleActionGroup.actions())
            viewMenu.addAction(action);
        viewMenu.addSeparator();
        viewMenu.addAction(guessModeStateAct);

        menuBar().addSeparator();

        helpMenu = menuBar().addMenu(tr("&Help"));
        helpMenu.addAction(aboutAct);
        helpMenu.addAction(aboutQtAct);
    }
</pre> In the <tt>createMenu()</tt> method, we add the previously created actions to the <b>File</b>, <b>View</b> and <b>Help</b> menus. <p>The <a href="../../../com/trolltech/qt/gui/QMenu.html">QMenu</a> class provides a menu widget for use in menu bars, context menus, and other popup menus. We put each menu in the application's menu bar, which we retrieve using <a href="../../../com/trolltech/qt/gui/QMainWindow.html#menuBar()">QMainWindow::menuBar()</a>. <pre class="snippet">
    private void createContextMenu()
    {
        imagesTable.setContextMenuPolicy(Qt.ContextMenuPolicy.ActionsContextMenu);
        imagesTable.addAction(addImagesAct);
        imagesTable.addAction(removeAllImagesAct);
    }
</pre> QWidgets have a contextMenuPolicy property that controls how the widget should behave when the user requests a context menu (e.g., by right-clicking). We set the <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a>'s context menu policy to <a href="../../../com/trolltech/qt/core/Qt.ContextMenuPolicy.html">Qt::ActionsContextMenu</a>, meaning that the <a href="../../../com/trolltech/qt/gui/QAction.html">QAction</a>s associated with the widget should appear in its context menu. <p>Then we add the <b>Add Image</b> and <b>Remove All Images</b> actions to the table widget. They will then appear in the table widget's context menu. <pre class="snippet">
    private void checkCurrentStyle()
    {
        for (QAction action : styleActionGroup.actions()) {
            String styleName = action.data().toString();
            QStyle candidate = QStyleFactory.create(styleName);

            if (candidate.objectName().equals(
                    QApplication.style().objectName())) {
                action.trigger();
                return;
            }
        }
    }
</pre> In the <tt>checkCurrentStyle()</tt> method we go through the group of style actions, looking for the current GUI style. <p>For each action, we first extract the style name using <a href="../../../com/trolltech/qt/gui/QAction.html#data()">QAction::data()</a>. Since this is only a <a href="../../../com/trolltech/qt/gui/QStyleFactory.html">QStyleFactory</a> key (e.g., "macintosh"), we cannot compare it directly to the current style's class name. We need to create a <a href="../../../com/trolltech/qt/gui/QStyle.html">QStyle</a> object using the static <a href="../../../com/trolltech/qt/gui/QStyleFactory.html#create(java.lang.String)">QStyleFactory::create()</a> method and compare the class name of the created <a href="../../../com/trolltech/qt/gui/QStyle.html">QStyle</a> object with that of the current style.<a name="the-iconsizespinbox-class"><h3>The IconSizeSpinBox Class</h3> The <tt>IconSizeSpinBox</tt> class is a subclass of <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a>. A plain <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a> can only handle integers. But since we want to display the spin box's values in a more sophisticated way, we need to subclass <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a> and reimplement the <a href="../../../com/trolltech/qt/gui/QSpinBox.html#textFromValue(int)">QSpinBox::textFromValue()</a> and <a href="../../../com/trolltech/qt/gui/QSpinBox.html#valueFromText(java.lang.String)">QSpinBox::valueFromText()</a> methods. <br><center><img src="images/icons_size_spinbox.png"></center><br> The IconSizeSpinBox does not implement a constructor, so we move on to the <tt>textFromValue</tt> method: <pre class="snippet">
        public String textFromValue(int value)
        {
            return "" + value +" x " + value;
        }
</pre> <a href="../../../com/trolltech/qt/gui/QSpinBox.html#textFromValue(int)">QSpinBox::textFromValue()</a> is used by the spin box whenever it needs to display a value. The default implementation returns a base 10 representation of the <tt>value</tt> parameter. <p>Our reimplementation returns a QString of the form "32 x 32". <pre class="snippet">
        public int valueFromText(String text)
        {
            QRegExp regExp = new QRegExp(tr("(\\d+)(\\s*[xx]\\s*\\d+)?"));

            if (regExp.exactMatch(text)) {
                return Integer.parseInt(regExp.cap(1));
            } else {
                return 0;
            }
        }
</pre> The <a href="../../../com/trolltech/qt/gui/QSpinBox.html#valueFromText(java.lang.String)">QSpinBox::valueFromText()</a> method is used by the spin box whenever it needs to interpret text typed in by the user. Since we reimplement the <tt>textFromValue()</tt> method we also need to reimplement the <tt>valueFromText()</tt> method to interpret the parameter text and return the associated int value. <p>We parse the text using a regular expression (a <a href="../../../com/trolltech/qt/core/QRegExp.html">QRegExp</a>). We define an expression that matches one or several digits, optionally followed by whitespace, an "x" or the times symbol, whitespace and one or several digits again. <p>The first digits of the regular expression are captured using parentheses. This enables us to use the <a href="../../../com/trolltech/qt/core/QRegExp.html#cap()">QRegExp::cap()</a> or <a href="../../../com/trolltech/qt/core/QRegExp.html#capturedTexts()">QRegExp::capturedTexts()</a> methods to extract the matched characters. If the first and second numbers of the spin box value differ (e.g., "16 x 24"), we use the first number. <p>When the user presses <b>Enter</b>, <a href="../../../com/trolltech/qt/gui/QSpinBox.html">QSpinBox</a> first calls <a href="../../../com/trolltech/qt/gui/QSpinBox.html#valueFromText(java.lang.String)">QSpinBox::valueFromText()</a> to interpret the text typed by the user, then <a href="../../../com/trolltech/qt/gui/QSpinBox.html#textFromValue(int)">QSpinBox::textFromValue()</a> to present it in a canonical format (e.g., "16 x 16").<a name="the-imagedelegate-class"><h3>The ImageDelegate Class</h3> The <tt>ImageDelegate</tt> class is a subclass of <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a>. The <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> class provides display and editing facilities for data items from a model. A single <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> object is responsible for all items displayed in a item view (in our case, a <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a>). <p>A <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> can be used to provide an editor for an item view class that is subclassed from <a href="../../../com/trolltech/qt/gui/QAbstractItemView.html">QAbstractItemView</a>. Using a delegate for this purpose allows the editing mechanism to be customized and developed independently from the model and view. <p>The default implementation of <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> creates a <a href="../../../com/trolltech/qt/gui/QLineEdit.html">QLineEdit</a>. Since we want the editor to be a <a href="../../../com/trolltech/qt/gui/QComboBox.html">QComboBox</a>, we need to subclass <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a> and reimplement the <a href="../../../com/trolltech/qt/gui/QItemDelegate.html#createEditor(com.trolltech.qt.gui.QWidget, com.trolltech.qt.gui.QStyleOptionViewItem, com.trolltech.qt.core.QModelIndex)">QItemDelegate::createEditor()</a>, <a href="../../../com/trolltech/qt/gui/QItemDelegate.html#setEditorData(com.trolltech.qt.gui.QWidget, com.trolltech.qt.core.QModelIndex)">QItemDelegate::setEditorData()</a> and <a href="../../../com/trolltech/qt/gui/QItemDelegate.html#setModelData(com.trolltech.qt.gui.QWidget, com.trolltech.qt.core.QAbstractItemModel, com.trolltech.qt.core.QModelIndex)">QItemDelegate::setModelData()</a> methods. <p>We also implement <tt>emitCommitData()</tt>, which is a slot used to emit the QImageDelegate::commitData() signal with the appropriate argument. <p>We move on to examine the implementation of the individual methods. <pre class="snippet">
        public ImageDelegate(QWidget widget)
        {
            super(widget);
        }
</pre> The constructor is trivial. <pre class="snippet">
        public QWidget createEditor(QWidget parent, QStyleOptionViewItem option,
                                    QModelIndex index)
        {
            QComboBox comboBox = new QComboBox(parent);
            if (index.column() == 1) {
                comboBox.addItem(tr("Normal"));
                comboBox.addItem(tr("Active"));
                comboBox.addItem(tr("Disabled"));
                comboBox.addItem(tr("Selected"));
            } else if (index.column() == 2) {
                comboBox.addItem(tr("Off"));
                comboBox.addItem(tr("On"));
            }

            comboBox.activated.connect(this, "emitCommitData()");

            return comboBox;
        }
</pre> The default <a href="../../../com/trolltech/qt/gui/QItemDelegate.html#createEditor(com.trolltech.qt.gui.QWidget, com.trolltech.qt.gui.QStyleOptionViewItem, com.trolltech.qt.core.QModelIndex)">QItemDelegate::createEditor()</a> implementation returns the widget used to edit the item specified by the model and item index for editing. The parent widget and style option are used to control the appearance of the editor widget. <p>Our reimplementation create and populate a combobox instead of the default line edit. The contents of the combobox depends on the column in the table for which the editor is requested. Column 1 contains the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> modes, whereas column 2 contains the <a href="../../../com/trolltech/qt/gui/QIcon.html">QIcon</a> states. <p>In addition, we connect the combobox's activated() signal to the <tt>emitCommitData()</tt> slot to emit the QAbstractItemDelegate::commitData() signal whenever the user chooses an item using the combobox. This ensures that the rest of the application notices the change and updates itself. <pre class="snippet">
        public void setEditorData(QWidget editor, QModelIndex index)
        {
            QComboBox comboBox = (QComboBox) editor;
            if (comboBox == null)
                return;

            int pos = comboBox.findText((String) index.model().data(index),
                                         Qt.MatchFlag.MatchExactly);
            comboBox.setCurrentIndex(pos);
        }
</pre> The <a href="../../../com/trolltech/qt/gui/QItemDelegate.html#setEditorData(com.trolltech.qt.gui.QWidget, com.trolltech.qt.core.QModelIndex)">QItemDelegate::setEditorData()</a> method is used by <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a> to transfer data from a <a href="../../../com/trolltech/qt/gui/QTableWidgetItem.html">QTableWidgetItem</a> to the editor. The data is stored as a string; we use <a href="../../../com/trolltech/qt/gui/QComboBox.html#findText(java.lang.String, com.trolltech.qt.core.Qt.MatchFlag[])">QComboBox::findText()</a> to locate it in the combobox. <p>Delegates work in terms of models, not items. This makes it possible to use them with any item view class (e.g., <a href="../../../com/trolltech/qt/gui/QListView.html">QListView</a>, <a href="../../../com/trolltech/qt/gui/QListWidget.html">QListWidget</a>, <a href="../../../com/trolltech/qt/gui/QTreeView.html">QTreeView</a>, etc.). The transition between model and items is done implicitly by <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a>; we don't need to worry about it. <pre class="snippet">
        public void setModelData(QWidget editor, QAbstractItemModel model,
                                 QModelIndex index)
        {
            QComboBox comboBox = (QComboBox) editor;
            if (comboBox == null)
                return;

            model.setData(index, comboBox.currentText());
        }
</pre> The <a href="../../../com/trolltech/qt/gui/QItemDelegate.html#setEditorData(com.trolltech.qt.gui.QWidget, com.trolltech.qt.core.QModelIndex)">QItemDelegate::setEditorData()</a> method is used by <a href="../../../com/trolltech/qt/gui/QTableWidget.html">QTableWidget</a> to transfer data back from the editor to the <a href="../../../com/trolltech/qt/gui/QTableWidgetItem.html">QTableWidgetItem</a>. <pre class="snippet">
        private void emitCommitData()
        {
            commitData.emit((QWidget) QSignalEmitter.signalSender());
        }
</pre> The <tt>emitCommitData()</tt> slot simply emit the QAbstractItemDelegate::commitData() signal for the editor that triggered the slot. This signal must be emitted when the editor widget has completed editing the data, and wants to write it back into the model.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
