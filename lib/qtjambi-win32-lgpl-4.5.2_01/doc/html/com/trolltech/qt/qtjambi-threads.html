<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Thread Support in Qt</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Thread Support in Qt</h1></center><p>A detailed discussion of thread handling in Qt Jambi. Qt Jambi provides a thread-safe way of posting events. This makes it easy to develop portable multithreaded Qt Jambi applications and take advantage of multiprocessor machines. Multithreaded programming is also a useful paradigm for performing time-consuming operations without freezing the user interface of an application. <p>An application can use the Java Thread class to create new threads. The <tt>synchronized</tt> and <tt>volatile</tt> keywords are used in the standard way to control access to objects in threads. However, <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s (classes that inherit from <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>) can only be used in QThreads, and they can only be accessed from that thread. More on this in the Threads and QObjects section. <p>Qt Jambi also provides classes for thread handling, as an alternative to using <tt>synchronize</tt> and <tt>volatile</tt>. We discuss these briefly in the The Threading Classes section. <p>This document is intended for an audience that has knowledge of, and experience with multithreaded applications and Java thread handling. <p>Topics: <ul><li> <a href="#the-threading-classes">The Threading Classes</a></li> <ul><li> <a href="#creating-a-thread">Creating a Thread</a></li><li> <a href="#synchronizing-threads">Synchronizing Threads</a></li></ul><li> <a href="#qtconcurrent">QtConcurrent</a></li><li> <a href="#reentrancy-and-thread-safety">Reentrancy and Thread-Safety</a></li><li> <a href="#threads-and-qobjects">Threads and QObjects</a></li> <ul><li> <a href="#qobject-reentrancy">QObject Reentrancy</a></li><li> <a href="#using-signals-to-communicate-between-qobjects-in-separate-threads">Using Signals to Communicate Between QObjects in Separate Threads</a></li><li> <a href="#per-thread-event-loop">Per-Thread Event Loop</a></li><li> <a href="#accessing-qobject-subclasses-from-other-threads">Accessing QObject Subclasses from Other Threads</a></li></ul><li> <a href="#threads-and-the-sql-module">Threads and the SQL Module</a></li><li> <a href="#painting-in-threads">Painting in Threads</a></li><li> <a href="#threads-and-rich-text-processing">Threads and Rich Text Processing</a></li><li> <a href="#threads-and-the-svg-module">Threads and the SVG module</a></li></ul><a name="the-threading-classes"><h2>The Threading Classes</h2> Qt includes the following thread classes: <ul><li> QThread inherits <tt>java.lang.Thread</tt> and is used when <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s are used in threads.</li><li> <a href="../../../com/trolltech/qt/core/QRunnable.html">QRunnable</a> provides a runnable target, and contains the run() method, similar to <tt>java.lang.Runnable</tt>.</li><li> <a href="../../../com/trolltech/qt/core/QThreadPool.html">QThreadPool</a> manages a collection of threads.</li><li> <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> provides a mutual exclusion lock, or mutex.</li><li> <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a> provides a lock that allows simultaneous read access.</li><li> <a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a> provides an integer semaphore (a generalization of a mutex).</li><li> <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> provides a way for threads to go to sleep until woken up by another thread.</li></ul> The thread classes of Qt Jambi provides an alternative way to start and manage threads than using the Java thread handling, with its <tt>synchronized</tt> and <tt>volatile</tt> keywords. <p>Note that Qt Jambis's threading classes are implemented with native threading APIs; e.g., Win32 and pthreads. Therefore, they can be used with threads of the same native API.<a name="creating-a-thread"><h3>Creating a Thread</h3> You can create a thread by initializing a <tt>java.lang.Thread</tt> or QThread, and then call the start() method. For example: <pre class="snippet">
    class MyJavaRunnable implements Runnable
    {
        &#64;Override
        public void run()
        {
            // Do whatever
        }
    }
...
        MyJavaRunnable javaRunnable = new MyJavaRunnable();
        QThread runner = new QThread(javaRunnable);
        runner.start();
</pre> Qt Jambi also provides the <a href="../../../com/trolltech/qt/core/QThreadPool.html">QThreadPool</a> class, which allows starting threads by providing a <a href="../../../com/trolltech/qt/core/QRunnable.html">QRunnable</a>. To create a thread in this way, subclass <a href="../../../com/trolltech/qt/core/QRunnable.html">QRunnable</a> and reimplement its run() method. For example: <pre class="snippet">
    class MyJambiRunnable extends QRunnable
    {
        &#64;Override
        public void run()
        {
            // Do whatever
        }
    }
...
        MyJambiRunnable jambiRunnable = new MyJambiRunnable();
        QThreadPool.start(jambiRunnable);
</pre> Note that <a href="../../../com/trolltech/qt/core/QCoreApplication.html#exec()">QCoreApplication::exec()</a> must always be called from the main thread (the thread that executes <tt>main()</tt>), not from a another thread. In GUI applications, the main thread is also called the GUI thread because it's the only thread that is allowed to perform GUI-related operations.<a name="synchronizing-threads"><h3>Synchronizing Threads</h3> The <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>, <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a>, <a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a>, and <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> classes provide means to synchronize threads. While the main idea with threads is that they should be as concurrent as possible, there are points where threads must stop and wait for other threads. For example, if two threads try to access the same global variable simultaneously, the results are usually undefined. <p><a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> provides a mutually exclusive lock, or mutex. At most one thread can hold the mutex at any time. If a thread tries to acquire the mutex while the mutex is already locked, the thread will be put to sleep until the thread that currently holds the mutex unlocks it. Mutexes are often used to protect accesses to shared data (i.e., data that can be accessed from multiple threads simultaneously). In the Reentrancy and Thread-Safety section below, we will use it to make a class thread-safe. <p><a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a> is similar to <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>, except that it distinguishes between "read" and "write" access to shared data and allows multiple readers to access the data simultaneously. Using <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a> instead of <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> when it is possible can make multithreaded programs more concurrent. <p><a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a> is a generalization of <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> that protects a certain number of identical resources. In contrast, a mutex protects exactly one resource. The <a href="threads-semaphores.html">Semaphores</a> example shows a typical application of semaphores: synchronizing access to a circular buffer between a producer and a consumer. <p><a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> allows a thread to wake up other threads when some condition has been met. One or many threads can block waiting for a <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> to set a condition with <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeOne()">wakeOne()</a> or <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeAll()">wakeAll()</a>. Use <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeOne()">wakeOne()</a> to wake one randomly selected event or <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeAll()">wakeAll()</a> to wake them all. The <a href="threads-waitconditions.html">Wait Conditions</a> example shows how to solve the producer-consumer problem using <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> instead of <a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a>. <p>Note that Qt's synchronization classes rely on the use of properly aligned pointers. For instance, you cannot use packed classes with MSVC.<a name="qtconcurrent-intro"><a name="qtconcurrent"><h2>QtConcurrent</h2> The QtConcurrent namespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives such as mutexes, read-write locks, wait conditions, or semaphores. Programs written with QtConcurrent automatically adjust the number of threads used according to the number of processor cores available. This means that applications written today will continue to scale when deployed on multi-core systems in the future. <p>QtConcurrent includes functional programming style APIs for parallel list processing, including a MapReduce and FilterReduce implementation for shared-memory (non-distributed) systems, and classes for managing asynchronous computations in GUI applications: <ul><li> QtConcurrent::map() applies a method to every item in a container, modifying the items in-place.</li><li> QtConcurrent::mapped() is like map(), except that it returns a new container with the modifications.</li><li> QtConcurrent::mappedReduced() is like mapped(), except that the modified results are reduced or folded into a single result.</li><li> QtConcurrent::filter() removes all items from a container based on the result of a filter method.</li><li> QtConcurrent::filtered() is like filter(), except that it returns a new container with the filtered results.</li><li> QtConcurrent::filteredReduced() is like filtered(), except that the filtered results are reduced or folded into a single result.</li><li> QtConcurrent::run() runs a method in another thread.</li><li> <a href="../../../com/trolltech/qt/core/QFuture.html">QFuture</a> represents the result of an asynchronous computation.</li><li> <a href="../../../com/trolltech/qt/core/QFutureIterator.html">QFutureIterator</a> allows iterating through results available via <a href="../../../com/trolltech/qt/core/QFuture.html">QFuture</a>.</li><li> <a href="../../../com/trolltech/qt/core/QFutureWatcher.html">QFutureWatcher</a> allows monitoring a <a href="../../../com/trolltech/qt/core/QFuture.html">QFuture</a> using signals-and-slots.</li><li> <a href="../../../com/trolltech/qt/core/QFutureSynchronizer.html">QFutureSynchronizer</a> is a convenience class that automatically synchronizes several QFutures.</li></ul> Qt Concurrent supports several STL-compatible container and iterator types, but works best with Qt containers that have random-access iterators, such as QList or QVector. The map and filter methods accept both containers and begin/end iterators.<a name="reentrant"><a name="thread-safe"><a name="reentrancy-and-thread-safety"><h2>Reentrancy and Thread-Safety</h2> Throughout the Qt documentation, the terms reentrant and thread-safe are used to specify how a method can be used in multithreaded applications: <ul><li> A reentrant method can be called simultaneously by multiple threads provided that each invocation of the method references unique data.</li><li> A thread-safe method can be called simultaneously by multiple threads when each invocation references shared data. All access to the shared data is serialized.</li></ul> By extension, a class is said to be reentrant if each and every one of its methods can be called simultaneously by multiple threads on different instances of the class. Similarly, the class is said to be thread-safe if the methods can be called by different threads on the same instance. <p>Classes in the documentation will be documented as thread-safe only if they are intended to be used by multiple threads. <p>Note that the terminology in this domain isn't entirely standardized. POSIX uses a somewhat different definition of reentrancy and thread-safety for its C APIs. When dealing with an object-oriented C++ class library such as Qt, the definitions must be adapted. <p>Most Qt Jambi classes are reentrant and not thread-safe, to avoid the overhead of repeatedly locking and unlocking a <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>. For example, QString is reentrant, meaning that you can use it in different threads, but you can't access the same QString object from different threads simultaneously (unless you protect it with a mutex yourself). A few classes and methods are thread-safe; these are mainly thread-related classes such as <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>, or fundamental methods such as <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::postEvent()</a>.<a name="threads-and-qobjects"><h2>Threads and QObjects</h2> As mentioned previously, when a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> is to be created in a thread, you need to use the QThread class. For all other Qt Jambi classes, <tt>java.lang.Thread</tt> can be used. QThread is started the same way as a <tt>java.lang.Thread</tt>. <pre class="snippet">
        MyJavaRunnable javaRunnable = new MyJavaRunnable();
        QThread runner = new QThread(javaRunnable);
        runner.start();
</pre><a name="qobject-reentrancy"><h3>QObject Reentrancy</h3> <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> is reentrant. Most of its non-GUI subclasses, such as <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a>, <a href="../../../com/trolltech/qt/network/QTcpSocket.html">QTcpSocket</a>, <a href="../../../com/trolltech/qt/network/QUdpSocket.html">QUdpSocket</a>, <a href="../../../com/trolltech/qt/network/QHttp.html">QHttp</a>, <a href="../../../com/trolltech/qt/network/QFtp.html">QFtp</a>, and <a href="../../../com/trolltech/qt/core/QProcess.html">QProcess</a>, are also reentrant, making it possible to use these classes from multiple threads simultaneously. Note that these classes are designed to be created and used from within a single thread; creating an object in one thread and calling its methods from another thread is not guaranteed to work. There are three constraints to be aware of: <ul><li> The child of a QObject must always be created in the thread where the parent was created. This implies, among other things, that you should never pass the QThread object (<tt>this</tt>) as the parent of an object created in the thread (since the QThread object itself was created in another thread).</li><li> Event driven objects may only be used in a single thread. Specifically, this applies to the <a href="timers.html">timer mechanism</a> and the <a href="qtnetwork.html">network module</a>. For example, you cannot start a timer or connect a socket in a thread that is not the object's thread.</li></ul> Note also that the GUI classes, notably <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> and all its subclasses, can can only be used from the main thread (i.e., the thread where the <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> object were initialized). As noted earlier, <a href="../../../com/trolltech/qt/core/QCoreApplication.html#exec()">QCoreApplication::exec()</a> must also be called from that thread. <p>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the <a href="qtjambi-mandelbrot.html">Mandelbrot</a> example.<a name="using-signals-to-communicate-between-qobjects-in-separate-threads"><h3>Using Signals to Communicate Between QObjects in Separate Threads</h3> The functionality for the Qt Jambi signal mechanism is implemented in QSignalEmitter, which does not inherit <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. It is therefore possible to send signals between <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s living in different threads. The way to do this is to implement a class consisting of the signals to be sendt, and then emit or connect to these signals from the threads. A small example follows:Error parsing snippet.</pre><a name="per-thread-event-loop"><h3>Per-Thread Event Loop</h3> Each thread can have its own event loop. The initial thread starts its event loops using <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a>.initialize(). Other threads can start an event loop by creating a <a href="../../../com/trolltech/qt/core/QEventLoop.html">QEventLoop</a> instance: <pre class="snippet">
    class EventLoopThread implements Runnable
    {
        &#64;Iverride
        public void run()
        {
            QEventLoop loop = new QEventLoop();
            loop.exec();

            // Do whatever
            
            loop.exit();
        }
    }

</pre> Like the main event loop started with QApplication::initialize(), <a href="../../../com/trolltech/qt/core/QEventLoop.html">QEventLoop</a> provides an <a href="../../../com/trolltech/qt/core/QEventLoop.html#exit()">exit()</a> method and a <a href="../../../com/trolltech/qt/core/QEventLoop.html#quit()">quit()</a> slot. <p>An event loop in a thread makes it possible for the thread to use certain non-GUI Qt classes that require the presence of an event loop (such as <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a>, <a href="../../../com/trolltech/qt/network/QTcpSocket.html">QTcpSocket</a>, and <a href="../../../com/trolltech/qt/core/QProcess.html">QProcess</a>). It also makes it possible to connect signals from any threads to slots of a specific thread. This is explained in more detail in the <a href="qtjambi-threads.html">Signals and Slots Across Threads</a> section below. <br><center><img src=""></center><br> A <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> instance is said to live in the thread in which it is created. Events to that object are dispatched by that thread's event loop. The thread in which a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> lives is available using <a href="../../../com/trolltech/qt/core/QObject.html#thread()">QObject::thread()</a>. <p>Note that <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s must be created after the <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> is initialize(); if not, they will not be part of the main event loop. Use the <a href="../../../com/trolltech/qt/core/QObject.html#moveToThread(java.lang.Thread)">QObject::moveToThread()</a> method to change the thread affinity for an object and its children (the object cannot be moved if it has a parent). <p>If no event loop is running, events won't be delivered to the object. For example, if you create a <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a> object in a thread but never call exec(), the <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a> will never emit its timeout() signal. Calling deleteLater() won't work either. (These restrictions apply to the main thread as well.) <p>You can manually post events to any object in any thread at any time using the thread-safe method <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::postEvent()</a>. The events will automatically be dispatched by the event loop of the thread where the object was created. <p>Event filters are supported in all threads, with the restriction that the monitoring object must live in the same thread as the monitored object. Similarly, <a href="../../../com/trolltech/qt/core/QCoreApplication.html#sendEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::sendEvent()</a> (unlike <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">postEvent()</a>) can only be used to dispatch events to objects living in the thread from which the method is called.<a name="accessing-qobject-subclasses-from-other-threads"><h3>Accessing QObject Subclasses from Other Threads</h3> <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> and all of its subclasses are not thread-safe. This includes the entire event delivery system. It is important to keep in mind that the event loop may be delivering events to your <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass while you are accessing the object from another thread. <p>Like other objects, QThread objects live in the thread where the object was created -- not in the thread that is created when QThread::run() is called. It is generally unsafe to provide slots in your QThread subclass, unless you protect the member variables with a mutex. <p>On the other hand, you can safely emit signals from your QThread::run() implementation, because signal emission is thread-safe.<a name="threads-and-the-sql-module"><h2>Threads and the SQL Module</h2> A connection can only be used from within the thread that created it. Moving connections between threads or creating queries from a different thread is not supported. <p>In addition, the third party libraries used by the QSqlDrivers can impose further restrictions on using the SQL Module in a multithreaded program. Consult the manual of your database client for more information<a name="painting-in-threads"><h2>Painting in Threads</h2> <a href="../../../com/trolltech/qt/gui/QPainter.html">QPainter</a> can be used to paint onto <a href="../../../com/trolltech/qt/gui/QImage.html">QImage</a>, <a href="../../../com/trolltech/qt/gui/QPrinter.html">QPrinter</a>, and <a href="../../../com/trolltech/qt/gui/QPicture.html">QPicture</a> paint devices. Painting onto QPixmaps and QWidgets is not supported. On Mac OS X the automatic progress dialog will not be displayed if you are printing from outside the GUI thread. <p>Any number of threads can paint at any given time, however only one thread at a time can paint on a given paint device. In other words, two threads can paint at the same time if each paints onto separate QImages, but the two threads cannot paint onto the same <a href="../../../com/trolltech/qt/gui/QImage.html">QImage</a> at the same time. <p>Note that on X11 systems without FontConfig support, Qt cannot render text outside of the GUI thread. You can use the <a href="../../../com/trolltech/qt/gui/QFontDatabase.html#supportsThreadedFontRendering()">QFontDatabase::supportsThreadedFontRendering()</a> method to detect whether or not font rendering can be used outside the GUI thread.<a name="threads-and-rich-text-processing"><h2>Threads and Rich Text Processing</h2> The <a href="../../../com/trolltech/qt/gui/QTextDocument.html">QTextDocument</a>, <a href="../../../com/trolltech/qt/gui/QTextCursor.html">QTextCursor</a>, and <a href="richtext.html">all related classes</a> are reentrant. <p>Note that a <a href="../../../com/trolltech/qt/gui/QTextDocument.html">QTextDocument</a> instance created in the GUI thread may contain <a href="../../../com/trolltech/qt/gui/QPixmap.html">QPixmap</a> image resources. Use <a href="../../../com/trolltech/qt/gui/QTextDocument.html#clone()">QTextDocument::clone()</a> to create a copy of the document, and pass the copy to another thread for further processing (such as printing).<a name="threads-and-the-svg-module"><h2>Threads and the SVG module</h2> The <a href="../../../com/trolltech/qt/svg/QSvgGenerator.html">QSvgGenerator</a> and <a href="../../../com/trolltech/qt/svg/QSvgRenderer.html">QSvgRenderer</a> classes in the <a href="qtsvg.html">QtSvg</a> module are reentrant.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
