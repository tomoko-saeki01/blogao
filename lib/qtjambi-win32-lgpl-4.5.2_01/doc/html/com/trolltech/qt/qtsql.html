<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>QtSql Module</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>QtSql Module</h1></center><p>[Previous: <a href="qtscript.html">QtScript Module</a>][<a href="modules.html">Qt's Modules</a>][Next: <a href="qtsvg.html">QtSvg Module</a>]<p><h2>Namespaces</h2> <table align="center" border="0" cellpadding="2" cellspacing="1" width="100%"><tr valign="top" class="even"><td>QSql</td><td></td></tr></table><h2>Classes</h2> <table align="center" border="0" cellpadding="2" cellspacing="1" width="100%"><tr valign="top" class="even"><td><a href="../../../com/trolltech/qt/sql/QSqlDatabase.html">QSqlDatabase</a></td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlDriver.html">QSqlDriver</a></td><td></td></tr><tr valign="top" class="even"><td>QSqlDriverCreator</td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlDriverCreatorBase.html">QSqlDriverCreatorBase</a></td><td></td></tr><tr valign="top" class="even"><td>QSqlDriverPlugin</td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlError.html">QSqlError</a></td><td></td></tr><tr valign="top" class="even"><td><a href="../../../com/trolltech/qt/sql/QSqlField.html">QSqlField</a></td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlIndex.html">QSqlIndex</a></td><td></td></tr><tr valign="top" class="even"><td><a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a></td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a></td><td></td></tr><tr valign="top" class="even"><td><a href="../../../com/trolltech/qt/sql/QSqlRecord.html">QSqlRecord</a></td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlRelation.html">QSqlRelation</a></td><td></td></tr><tr valign="top" class="even"><td><a href="../../../com/trolltech/qt/sql/QSqlRelationalDelegate.html">QSqlRelationalDelegate</a></td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a></td><td></td></tr><tr valign="top" class="even"><td><a href="../../../com/trolltech/qt/sql/QSqlResult.html">QSqlResult</a></td><td></td></tr><tr valign="top" class="odd"><td><a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a></td><td></td></tr></table>The <a href="qtsql.html">QtSql</a> module helps you provide seamless database integration to your Qt applications. The SQL classes are divided into three layers: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Layer</center></th><th><center> Description</center></th></tr></thead><tr valign="top" class="even"><td> <b>Driver Layer</b></td><td> This comprises the classes <a href="../../../com/trolltech/qt/sql/QSqlDriver.html">QSqlDriver</a>, QSqlDriverCreator&lt;T&gt;, <a href="../../../com/trolltech/qt/sql/QSqlDriverCreatorBase.html">QSqlDriverCreatorBase</a>, QSqlDriverPlugin, and <a href="../../../com/trolltech/qt/sql/QSqlResult.html">QSqlResult</a>. This layer provides the low-level bridge between the specific databases and the SQL API layer. See <a href="sql-driver.html">SQL Database Drivers</a> for more information.</td></tr><tr valign="top" class="odd"><td> <b>SQL API Layer</b></td><td> These classes provide access to databases. Connections are made using the <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html">QSqlDatabase</a> class. Database interaction is achieved by using the <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> class. In addition to <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html">QSqlDatabase</a> and <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a>, the SQL API layer is supported by <a href="../../../com/trolltech/qt/sql/QSqlError.html">QSqlError</a>, <a href="../../../com/trolltech/qt/sql/QSqlField.html">QSqlField</a>, <a href="../../../com/trolltech/qt/sql/QSqlIndex.html">QSqlIndex</a>, and <a href="../../../com/trolltech/qt/sql/QSqlRecord.html">QSqlRecord</a>.</td></tr><tr valign="top" class="even"><td> <b>User Interface Layer</b></td><td> These classes link the data from a database to data-aware widgets. They include <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a>, <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a>, and <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a>. These classes are designed to work with Qt's model/view framework.</td></tr></table> Note that to use any of these classes, a <a href="../../../com/trolltech/qt/core/QCoreApplication.html">QCoreApplication</a> object must have been instantiated first. To include the definitions of the module's classes, use the following directive: <pre class="snippet">
#include &lt;QtSql&gt;
</pre> To link against the module, add this line to your <a href="qmake-manual.html">qmake</a><tt>.pro</tt> file: <pre class="snippet">
QT += sql
</pre> The <a href="qtsql.html">QtSql</a> module is part of the <a href="commercialeditions.html">Qt Full Framework Edition</a> and the <a href="opensourceedition.html">Qt Open Source Edition</a>. <p>This overview assumes that you have at least a basic knowledge of SQL. You should be able to understand simple <tt>SELECT</tt>, <tt>INSERT</tt>, <tt>UPDATE</tt>, and <tt>DELETE</tt> statements. Although the <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> class provides an interface to database browsing and editing that does not require a knowledge of SQL, a basic understanding of SQL is highly recommended. A standard text covering SQL databases is An Introduction to Database Systems (7th Ed.) by C. J. Date, ISBN 0201385902. <p>Topics: <ul><li> <a href="#connecting-to-databases">Connecting to Databases</a></li><li> <a href="#executing-sql-statements">Executing SQL Statements</a></li> <ul><li> <a href="#executing-a-query">Executing a Query</a></li><li> <a href="#navigating-the-result-set">Navigating the Result Set</a></li><li> <a href="#inserting-updating-and-deleting-records">Inserting, Updating, and Deleting Records</a></li><li> <a href="#transactions">Transactions</a></li></ul><li> <a href="#using-the-sql-model-classes">Using the SQL Model Classes</a></li> <ul><li> <a href="#the-sql-query-model">The SQL Query Model</a></li><li> <a href="#the-sql-table-model">The SQL Table Model</a></li><li> <a href="#the-sql-relational-table-model">The SQL Relational Table Model</a></li></ul><li> <a href="#presenting-data-in-a-table-view">Presenting Data in a Table View</a></li><li> <a href="#creating-data-aware-forms">Creating Data-Aware Forms</a></li></ul><a name="connecting-to-databases"><h2>Connecting to Databases</h2> To access a database with <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> or <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a>, create and open one or more database connections. Database connections are normally identified by connection name, not by database name. You can have multiple connections to the same database. <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html">QSqlDatabase</a> also supports the concept of a default connection, which is an unnamed connection. When calling <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> or <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a> member functions that take a connection name argument, if you don't pass a connection name, the default connection will be used. Creating a default connection is convenient when your application only requires one database connection. <p>Note the difference between creating a connection and opening it. Creating a connection involves creating an instance of class <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html">QSqlDatabase</a>. The connection is not usable until it is opened. The following snippet shows how to create a default connection and then open it: <pre class="snippet">
        QSqlDatabase db = QSqlDatabase.addDatabase("QMYSQL");
        db.setHostName("bigblue");
        db.setDatabaseName("flightdb");
        db.setUserName("acarlson");
        db.setPassword("1uTbSbAs");
        boolean ok = db.open();
    </pre> The first line creates the connection object, and the last line opens it for use. In between, we initialize some connection information, including the <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#setDatabaseName(java.lang.String)">database name</a>, the <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#setHostName(java.lang.String)">host name</a>, the <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#setUserName(java.lang.String)">user name</a>, and the <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#setPassword(java.lang.String)">password</a>. In this case, we are connecting to the MySQL database <tt>flightdb</tt> on the host <tt>bigblue</tt>. The <tt>"QMYSQL"</tt> argument to <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#addDatabase(com.trolltech.qt.sql.QSqlDriver)">addDatabase()</a> specifies the type of database driver to use for the connection. The set of database drivers included with Qt are shown in the table of <a href="sql-driver.html#supported-databases">supported database drivers</a>. <p>The connection in the snippet will be the default connection, because we don't pass the second argument to <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#addDatabase(com.trolltech.qt.sql.QSqlDriver)">addDatabase()</a>, which is the connection name. For example, here we establish two MySQL database connections named <tt>"first"</tt> and <tt>"second"</tt>: <pre class="snippet">
        QSqlDatabase firstDB = QSqlDatabase.addDatabase("QMYSQL", "first");
        QSqlDatabase secondDB = QSqlDatabase.addDatabase("QMYSQL", "second");
    </pre> After these connections have been initialized, <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#open()">open()</a> for each one to establish the live connections. If the <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#open()">open()</a> fails, it returns false. In that case, call <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#lastError()">QSqlDatabase::lastError()</a> to get error information. <p>Once a connection is established, we can call the static function <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#database(java.lang.String)">QSqlDatabase::database()</a> from anywhere with a connection name to get a pointer to that database connection. If we don't pass a connection name, it will return the default connection. For example: <pre class="snippet">
        QSqlDatabase defaultDB = QSqlDatabase.database();
    
        QSqlDatabase firstDB = QSqlDatabase.database("first");
    
        QSqlDatabase secondDB = QSqlDatabase.database("second");
    </pre> To remove a database connection, first close the database using <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#close()">QSqlDatabase::close()</a>, then remove it using the static method <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#removeDatabase(java.lang.String)">QSqlDatabase::removeDatabase()</a>.<a name="executing-sql-statements"><h2>Executing SQL Statements</h2> The <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> class provides an interface for executing SQL statements and navigating through the result set of a query. <p>The <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a> and <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> classes described in the next section provide a higher-level interface for accessing databases. If you are unfamiliar with SQL, you might want to skip directly to the next section (<a href="qtsql.html#using-the-sql-model-classes">Using the SQL Model Classes</a>).<a name="executing-a-query"><h3>Executing a Query</h3> To execute an SQL statement, simply create a <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> object and call <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#exec()">QSqlQuery::exec()</a> like this: <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        query.exec("SELECT name, salary FROM employee WHERE salary &gt; 50000");
    </pre> The <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> constructor accepts an optional <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html">QSqlDatabase</a> object that specifies which database connection to use. In the example above, we don't specify any connection, so the default connection is used. <p>If an error occurs, <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#exec()">exec()</a> returns false. The error is then available as <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#lastError()">QSqlQuery::lastError()</a>.<a name="navigating-the-result-set"><h3>Navigating the Result Set</h3> <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> provides access to the result set one record at a time. After the call to <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#exec()">exec()</a>, <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a>'s internal pointer is located one position before the first record. We must call <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#next()">QSqlQuery::next()</a> once to advance to the first record, then <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#next()">next()</a> again repeatedly to access the other records, until it returns false. Here's a typical loop that iterates over all the records in order: <pre class="snippet">
        while (query.next()) {
            String name = query.value(0).toString();
            int salary = ((Integer) query.value(1)).intValue();
            System.err.println(name + " " +salary);
        }
    </pre> The <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#value(int)">QSqlQuery::value()</a> function returns the value of a field in the current record. Fields are specified as zero-based indexes. <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#value(int)">QSqlQuery::value()</a> returns a <a href="../../../com/trolltech/qt/QVariant.html">QVariant</a>, a type that can hold various C++ and core Qt data types such as <tt>int</tt>, QString, and <a href="../../../com/trolltech/qt/core/QByteArray.html">QByteArray</a>. The different database types are automatically mapped into the closest Qt equivalent. In the code snippet, we call <a href="../../../com/trolltech/qt/QVariant.html#toString(java.lang.Object)">QVariant::toString()</a> and <a href="../../../com/trolltech/qt/QVariant.html#toInt(java.lang.Object)">QVariant::toInt()</a> to convert variants to QString and <tt>int</tt>. <p>You can iterate back and forth using <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#next()">QSqlQuery::next()</a>, <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#previous()">QSqlQuery::previous()</a>, <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#first()">QSqlQuery::first()</a>, <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#last()">QSqlQuery::last()</a>, and <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#seek(int)">QSqlQuery::seek()</a>. The current row index is returned by <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#at()">QSqlQuery::at()</a>, and the total number of rows in the result set is avaliable as <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#size()">QSqlQuery::size()</a> for databases that support it. <p>To determine whether a database driver supports a given feature, use <a href="../../../com/trolltech/qt/sql/QSqlDriver.html#hasFeature(com.trolltech.qt.sql.QSqlDriver.DriverFeature)">QSqlDriver::hasFeature()</a>. In the following example, we call <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#size()">QSqlQuery::size()</a> to determine the size of a result set of the underlying database supports that feature; otherwise, we navigate to the last record and use the query's position to tell us how many records there are. <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        int numRows;
        query.exec("SELECT name, salary FROM employee WHERE salary &gt; 50000");

        QSqlDatabase defaultDB = QSqlDatabase.database();
        if (defaultDB.driver().hasFeature(QSqlDriver.DriverFeature.QuerySize)) {
            numRows = query.size();
        } else {
            // this can be very slow
            query.last();
            numRows = query.at() + 1;
        }
    </pre> If you iterate through a result set only using next() and seek() with positive values, you can call QSqlQuery::setForwardOnly(true) before calling exec(). This is an easy optimization that will speed up the query significantly when operating on large result sets.<a name="inserting-updating-and-deleting-records"><h3>Inserting, Updating, and Deleting Records</h3> <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> can execute arbitrary SQL statements, not just <tt>SELECT</tt>s. The following example inserts a record into a table using <tt>INSERT</tt>: <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        query.exec("INSERT INTO employee (id, name, salary) " +
                   "VALUES (1001, 'Thad Beaumont', 65000)");
    </pre> If you want to insert many records at the same time, it is often more efficient to separate the query from the actual values being inserted. This can be done using placeholders. Qt supports two placeholder syntaxes: named binding and positional binding. Here's an example of named binding: <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        query.prepare("INSERT INTO employee (id, name, salary) " +
                      "VALUES (:id, :name, :salary)");
        query.bindValue(":id", 1001);
        query.bindValue(":name", "Thad Beaumont");
        query.bindValue(":salary", 65000);
        query.exec();
    </pre> Here's an example of positional binding: <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        query.prepare("INSERT INTO employee (id, name, salary) " +
                      "VALUES (?, ?, ?)");
        query.addBindValue(1001);
        query.addBindValue("Thad Beaumont");
        query.addBindValue(65000);
        query.exec();
    </pre> Both syntaxes work with all database drivers provided by Qt. If the database supports the syntax natively, Qt simply forwards the query to the DBMS; otherwise, Qt simulates the placeholder syntax by preprocessing the query. The actual query that ends up being executed by the DBMS is available as <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#executedQuery()">QSqlQuery::executedQuery()</a>. <p>When inserting multiple records, you only need to call <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#prepare(java.lang.String)">QSqlQuery::prepare()</a> once. Then you call <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#bindValue(java.lang.String, java.lang.Object, com.trolltech.qt.sql.QSql.ParamTypeFlag[])">bindValue()</a> or <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#addBindValue(java.lang.Object, com.trolltech.qt.sql.QSql.ParamTypeFlag[])">addBindValue()</a> followed by <a href="../../../com/trolltech/qt/sql/QSqlQuery.html#exec()">exec()</a> as many times as necessary. <p>Besides performance, one advantage of placeholders is that you can easily specify arbitrary values without having to worry about escaping special characters. <p>Updating a record is similar to inserting it into a table: <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        query.exec("UPDATE employee SET salary = 70000 WHERE id = 1003");
    </pre> You can also use named or positional binding to associate parameters to actual values. <p>Finally, here's an example of a <tt>DELETE</tt> statement: <pre class="snippet">
        QSqlQuery query = new QSqlQuery();
        query.exec("DELETE FROM employee WHERE id = 1007");
    </pre><a name="transactions"><h3>Transactions</h3> If the underlying database engine supports transactions, QSqlDriver::hasFeature(<a href="../../../com/trolltech/qt/sql/QSqlDriver.DriverFeature.html">QSqlDriver::Transactions</a>) will return true. You can use <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#transaction()">QSqlDatabase::transaction()</a> to initiate a transaction, followed by the SQL commands you want to execute within the context of the transaction, and then either <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#commit()">QSqlDatabase::commit()</a> or <a href="../../../com/trolltech/qt/sql/QSqlDatabase.html#rollback()">QSqlDatabase::rollback()</a>. When using transactions you must start the transaction before you create your query. <p>Example: <pre class="snippet">
        QSqlDatabase.database().transaction();
        QSqlQuery query = new QSqlQuery();
        query.exec("SELECT id FROM employee WHERE name = 'Torild Halvorsen'");
        if (query.next()) {
            int employeeId = ((Integer) query.value(0)).intValue();
            query.exec("INSERT INTO project (id, name, ownerid) " +
                       "VALUES (201, 'Manhattan Project', "
                       + String.valueOf(employeeId) + ")");
        }
        QSqlDatabase.database().commit();
    </pre> Transactions can be used to ensure that a complex operation is atomic (for example, looking up a foreign key and creating a record), or to provide a means of canceling a complex change in the middle.<a name="using-the-sql-model-classes"><h2>Using the SQL Model Classes</h2> In addition to <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a>, Qt offers three higher-level classes for accessing databases. These classes are <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a>, <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a>, and <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a>. <table align="center" border="0" cellpadding="2" cellspacing="1"><tr valign="top" class="even"><td> <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a></td><td> A read-only model based on an arbitrary SQL query.</td></tr><tr valign="top" class="odd"><td> <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a></td><td> A read-write model that works on a single table.</td></tr><tr valign="top" class="even"><td> <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a></td><td> A <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> subclass with foreign key support.</td></tr></table> These classes derive from <a href="../../../com/trolltech/qt/gui/QAbstractTableModel.html">QAbstractTableModel</a> (which in turn inherits from <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html">QAbstractItemModel</a>) and make it easy to present data from a database in an item view class such as <a href="../../../com/trolltech/qt/gui/QListView.html">QListView</a> and <a href="../../../com/trolltech/qt/gui/QTableView.html">QTableView</a>. This is explained in detail in the <a href="qtsql.html#presenting-data-in-a-table-view">Presenting Data in a Table View</a> section. <p>Another advantage of using these classes is that it can make your code easier to adapt to other data sources. For example, if you use <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> and later decide to use XML files to store data instead of a database, it is essentially just a matter of replacing one data model with another.<a name="the-sql-query-model"><h3>The SQL Query Model</h3> <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a> offers a read-only model based on an SQL query. <p>Example: <pre class="snippet">
        QSqlQueryModel model = new QSqlQueryModel();
        model.setQuery("SELECT * FROM employee");

        for (int i = 0; i &lt; model.rowCount(); ++i) {
            int id = ((Integer) model.record(i).value("id")).intValue();
            String name = model.record(i).value("name").toString();
            System.out.println(String.valueOf(id) + " " + name);
        }
    </pre> After setting the query using <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html#setQuery(com.trolltech.qt.sql.QSqlQuery)">QSqlQueryModel::setQuery()</a>, you can use QSqlQueryModel::record(int) to access the individual records. You can also use <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html#data(com.trolltech.qt.core.QModelIndex, int)">QSqlQueryModel::data()</a> and any of the other functions inherited from <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html">QAbstractItemModel</a>. <p>There's also a <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html#setQuery(com.trolltech.qt.sql.QSqlQuery)">setQuery()</a> overload that takes a <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> object and operates on its result set. This enables you to use any features of <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> to set up the query (e.g., prepared queries).<a name="the-sql-table-model"><h3>The SQL Table Model</h3> <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> offers a read-write model that works on a single SQL table at a time. <p>Example: <pre class="snippet">
        QSqlTableModel model = new QSqlTableModel();
        model.setTable("employee");
        model.setFilter("salary &gt; 50000");
        model.setSort(2, Qt.SortOrder.DescendingOrder);
        model.select();

        for (int i = 0; i &lt; model.rowCount(); ++i) {
            String name = model.record(i).value("name").toString();
            int salary = ((Integer) model.record(i).value("salary")).intValue();
            System.out.println(name + " " + salary);
        }
    </pre> <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> is a high-level alternative to <a href="../../../com/trolltech/qt/sql/QSqlQuery.html">QSqlQuery</a> for navigating and modifying individual SQL tables. It typically results in less code and requires no knowledge of SQL syntax. <p>Use <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html#record()">QSqlTableModel::record()</a> to retrieve a row in the table, and <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#setRecord(int, com.trolltech.qt.sql.QSqlRecord)">QSqlTableModel::setRecord()</a> to modify the row. For example, the following code will increase every employee's salary by 10 per cent: <pre class="snippet">
        for (int i = 0; i &lt; model.rowCount(); ++i) {
            QSqlRecord record = model.record(i);
            double salary = ((Double) record.value("salary")).doubleValue();
            salary = 1.1;
            record.setValue("salary", salary);
            model.setRecord(i, record);
        }
        model.submitAll();
    </pre> You can also use <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html#data(com.trolltech.qt.core.QModelIndex)">QSqlTableModel::data()</a> and <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#setData(com.trolltech.qt.core.QModelIndex, java.lang.Object, int)">QSqlTableModel::setData()</a>, which are inherited from <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html">QAbstractItemModel</a>, to access the data. For example, here's how to update a record using <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#setData(com.trolltech.qt.core.QModelIndex, java.lang.Object, int)">setData()</a>: <pre class="snippet">
        model.setData(model.index(row, column), 75000);
        model.submitAll();
    </pre> Here's how to insert a row and populate it: <pre class="snippet">
        model.insertRows(row, 1);
        model.setData(model.index(row, 0), 1013);
        model.setData(model.index(row, 1), "Peter Gordon");
        model.setData(model.index(row, 2), 68500);
        model.submitAll();
    </pre> Here's how to delete five consecutive rows: <pre class="snippet">
        model.removeRows(row, 5);
    
        model.submitAll();
    </pre> The first argument to <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#removeRows(int, int, com.trolltech.qt.core.QModelIndex)">QSqlTableModel::removeRows()</a> is the index of the first row to delete. <p>When you're finished changing a record, you should always call <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#submitAll()">QSqlTableModel::submitAll()</a> to ensure that the changes are written to the database. <p>When and whether you actually need to call submitAll() depends on the table's <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#editStrategy()">edit strategy</a>. The default strategy is <a href="../../../com/trolltech/qt/sql/QSqlTableModel.EditStrategy.html">QSqlTableModel::OnRowChange</a>, which specifies that pending changes are applied to the database when the user selects a different row. Other strategies are <a href="../../../com/trolltech/qt/sql/QSqlTableModel.EditStrategy.html">QSqlTableModel::OnManualSubmit</a> (where all changes are cached in the model until you call submitAll()) and <a href="../../../com/trolltech/qt/sql/QSqlTableModel.EditStrategy.html">QSqlTableModel::OnFieldChange</a> (where no changes are cached). These are mostly useful when <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> is used with a view. <p><a href="../../../com/trolltech/qt/sql/QSqlTableModel.EditStrategy.html">QSqlTableModel::OnFieldChange</a> seems to deliver the promise that you never need to call submitAll() explicitly. There are two pitfalls, though: <ul><li> Without any caching, performance may drop significantly.</li><li> If you modify a primary key, the record might slip through your fingers while you are trying to populate it.</li></ul><a name="the-sql-relational-table-model"><h3>The SQL Relational Table Model</h3> <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a> extends <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> to provide support for foreign keys. A foreign key is a 1-to-1 mapping between a field in one table and the primary key field of another table. For example, if a <tt>book</tt> table has a field called <tt>authorid</tt> that refers to the author table's <tt>id</tt> field, we say that <tt>authorid</tt> is a foreign key. <table align="center" border="0" cellpadding="2" cellspacing="1"><tr valign="top" class="even"><td>  <br><center><img src="images/noforeignkeys.png"></center><br></td><td>  <br><center><img src="images/foreignkeys.png"></center><br></td></tr></table> The screenshot on the left shows a plain <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> in a <a href="../../../com/trolltech/qt/gui/QTableView.html">QTableView</a>. Foreign keys (<tt>city</tt> and <tt>country</tt>) aren't resolved to human-readable values. The screenshot on the right shows a <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a>, with foreign keys resolved into human-readable text strings. <p>The following code snippet shows how the <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a> was set up:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    model-&gt;setTable("employee");
<br>
    model-&gt;setRelation(2, QSqlRelation("city", "id", "name"));

    model-&gt;setRelation(3, QSqlRelation("country", "id", "name"));
</pre> See the <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a> documentation for details.<a name="presenting-data-in-a-table-view"><h2>Presenting Data in a Table View</h2> The <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a>, <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a>, and <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a> classes can be used as a data source for Qt's view classes such as <a href="../../../com/trolltech/qt/gui/QListView.html">QListView</a>, <a href="../../../com/trolltech/qt/gui/QTableView.html">QTableView</a>, and <a href="../../../com/trolltech/qt/gui/QTreeView.html">QTreeView</a>. In practice, <a href="../../../com/trolltech/qt/gui/QTableView.html">QTableView</a> is by far the most common choice, because an SQL result set is essentially a two-dimensional data structure. <br><center><img src="images/relationaltable.png"></center><br> The following example creates a view based on an SQL data model: <pre class="snippet">
        QTableView view = new QTableView();
    
        view.setModel(model);
    
        view.show();
     </pre> If the model is a read-write model (e.g., <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a>), the view lets the user edit the fields. You can disable this by calling <pre class="snippet">
        view.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers);
    </pre> You can use the same model as a data source for multiple views. If the user edits the model through one of the views, the other views will reflect the changes immediately. The <a href="sql-tablemodel.html">Table Model</a> example shows how it works. <p>View classes display a header at the top to label the columns. To change the header texts, call <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html#setHeaderData(int, com.trolltech.qt.core.Qt.Orientation, java.lang.Object)">setHeaderData()</a> on the model. The header's labels default to the table's field names. For example:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    model-&gt;setHeaderData(0, Qt::Horizontal, QObject::tr("ID"));
    model-&gt;setHeaderData(1, Qt::Horizontal, QObject::tr("Name"));
    model-&gt;setHeaderData(2, Qt::Horizontal, QObject::tr("City"));
    model-&gt;setHeaderData(3, Qt::Horizontal, QObject::tr("Country"));
</pre> <a href="../../../com/trolltech/qt/gui/QTableView.html">QTableView</a> also has a vertical header on the left with numbers identifying the rows. If you insert rows programmatically using <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#insertRows(int, int, com.trolltech.qt.core.QModelIndex)">QSqlTableModel::insertRows()</a>, the new rows will be marked with an asterisk (*) until they are submitted using <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#submitAll()">submitAll()</a> or automatically when the user moves to another record (assuming the <a href="../../../com/trolltech/qt/sql/QSqlTableModel.EditStrategy.html">edit strategy</a> is <a href="../../../com/trolltech/qt/sql/QSqlTableModel.EditStrategy.html">QSqlTableModel::OnRowChange</a>). <br><center><img src="images/insertrowinmodelview.png"></center><br> Likewise, if you remove rows using <a href="../../../com/trolltech/qt/sql/QSqlTableModel.html#removeRows(int, int, com.trolltech.qt.core.QModelIndex)">removeRows()</a>, the rows will be marked with an exclamation mark (!) until the change is submitted. <p>The items in the view are rendered using a delegate. The default delegate, <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a>, handles the most common data types (<tt>int</tt>, QString, <a href="../../../com/trolltech/qt/gui/QImage.html">QImage</a>, etc.). The delegate is also responsible for providing editor widgets (e.g., a combobox) when the user starts editing an item in the view. You can create your own delegates by subclassing <a href="../../../com/trolltech/qt/gui/QAbstractItemDelegate.html">QAbstractItemDelegate</a> or <a href="../../../com/trolltech/qt/gui/QItemDelegate.html">QItemDelegate</a>. See <a href="model-view-programming.html">Model/View Programming</a> for more information. <p><a href="../../../com/trolltech/qt/sql/QSqlTableModel.html">QSqlTableModel</a> is optimized to operate on a single table at a time. If you need a read-write model that operates on an arbitrary result set, you can subclass <a href="../../../com/trolltech/qt/sql/QSqlQueryModel.html">QSqlQueryModel</a> and reimplement <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html#flags(com.trolltech.qt.core.QModelIndex)">flags()</a> and <a href="../../../com/trolltech/qt/core/QAbstractItemModel.html#setData(com.trolltech.qt.core.QModelIndex, java.lang.Object)">setData()</a> to make it read-write. The following two functions make fields 1 and 2 of a query model editable:<br><br>The following code example is written in c++.<br> <pre class="snippet">
Qt::ItemFlags EditableSqlModel::flags(
        const QModelIndex &index) const
{
    Qt::ItemFlags flags = QSqlQueryModel::flags(index);
    if (index.column() == 1 || index.column() == 2)
        flags |= Qt::ItemIsEditable;
    return flags;
}
<br>
bool EditableSqlModel::setData(const QModelIndex &index, const QVariant &value, int  role )
{
    if (index.column() &lt; 1 || index.column() &gt; 2)
        return false;

    QModelIndex primaryKeyIndex = QSqlQueryModel::index(index.row(), 0);
    int id = data(primaryKeyIndex).toInt();

    clear();

    bool ok;
    if (index.column() == 1) {
        ok = setFirstName(id, value.toString());
    } else {
        ok = setLastName(id, value.toString());
    }
    refresh();
    return ok;
}
</pre> The setFirstName() helper function is defined as follows:<br><br>The following code example is written in c++.<br> <pre class="snippet">
bool EditableSqlModel::setFirstName(int personId, const QString &firstName)
{
    QSqlQuery query;
    query.prepare("update person set firstname = ? where id = ?");
    query.addBindValue(firstName);
    query.addBindValue(personId);
    return query.exec();
}
</pre> The setLastName() function is similar. See the <a href="sql-querymodel.html">Query Model</a> example for the complete source code. <p>Subclassing a model makes it possible to customize it in many ways: You can provide tooltips for the items, change the background color, provide calculated values, provide different values for viewing and editing, handle null values specially, and more. See <a href="model-view-programming.html">Model/View Programming</a> as well as the <a href="../../../com/trolltech/qt/gui/QAbstractItemView.html">QAbstractItemView</a> reference documentation for details. <p>If all you need is to resolve a foreign key to a more human-friendly string, you can use <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a>. For best results, you should also use <a href="../../../com/trolltech/qt/sql/QSqlRelationalDelegate.html">QSqlRelationalDelegate</a>, a delegate that provides combobox editors for editing foreign keys. <br><center><img src="images/relationaltable.png"></center><br> The <a href="sql-relationaltablemodel.html">Relational Table Model</a> example illustrates how to use <a href="../../../com/trolltech/qt/sql/QSqlRelationalTableModel.html">QSqlRelationalTableModel</a> in conjunction with <a href="../../../com/trolltech/qt/sql/QSqlRelationalDelegate.html">QSqlRelationalDelegate</a> to provide tables with foreign key support.<a name="creating-data-aware-forms"><h2>Creating Data-Aware Forms</h2> Using the SQL models described above, the contents of a database can be presented to other model/view components. For some applications, it is sufficient to present this data using a standard item view, such as <a href="../../../com/trolltech/qt/gui/QTableView.html">QTableView</a>. However, users of record-based applications often require a form-based user interface in which data from a specific row or column in a database table is used to populate editor widgets on a form. <p>Such data-aware forms can be created with the <a href="../../../com/trolltech/qt/gui/QDataWidgetMapper.html">QDataWidgetMapper</a> class, a generic model/view component that is used to map data from a model to specific widgets in a user interface. <p><a href="../../../com/trolltech/qt/gui/QDataWidgetMapper.html">QDataWidgetMapper</a> operates on a specific database table, mapping items in the table on a row-by-row or column-by-column basis. As a result, using <a href="../../../com/trolltech/qt/gui/QDataWidgetMapper.html">QDataWidgetMapper</a> with a SQL model is as simple as using it with any other table model. <br><center><img src="images/qdatawidgetmapper-simple.png"></center><br> The <a href="demos-books.html">Books</a> demonstration shows how information can be presented for easy access by using <a href="../../../com/trolltech/qt/gui/QDataWidgetMapper.html">QDataWidgetMapper</a> and a set of simple input widgets.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
