<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Thread Support in Qt</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Thread Support in Qt</h1></center><p>A detailed discussion of thread handling in Qt. Qt provides thread support in the form of platform-independent threading classes, a thread-safe way of posting events, and signal-slot connections across threads. This makes it easy to develop portable multithreaded Qt applications and take advantage of multiprocessor machines. Multithreaded programming is also a useful paradigm for performing time-consuming operations without freezing the user interface of an application. <p>Earlier versions of Qt offered an option to build the library without thread support. Since Qt 4.0, threads are always enabled. <p>This document is intended for an audience that has knowledge of, and experience with, multithreaded applications. If you are new to threading see our <a href="threads.html#reading">Recommended Reading</a> list. <p>Topics: <ul><li> <a href="#the-threading-classes">The Threading Classes</a></li> <ul><li> <a href="#creating-a-thread">Creating a Thread</a></li><li> <a href="#synchronizing-threads">Synchronizing Threads</a></li></ul><li> <a href="#qtconcurrent">QtConcurrent</a></li><li> <a href="#reentrancy-and-thread-safety">Reentrancy and Thread-Safety</a></li><li> <a href="#threads-and-qobjects">Threads and QObjects</a></li> <ul><li> <a href="#qobject-reentrancy">QObject Reentrancy</a></li><li> <a href="#per-thread-event-loop">Per-Thread Event Loop</a></li><li> <a href="#accessing-qobject-subclasses-from-other-threads">Accessing QObject Subclasses from Other Threads</a></li><li> <a href="#signals-and-slots-across-threads">Signals and Slots Across Threads</a></li></ul><li> <a href="#threads-and-implicit-sharing">Threads and Implicit Sharing</a></li><li> <a href="#threads-and-the-sql-module">Threads and the SQL Module</a></li><li> <a href="#painting-in-threads">Painting in Threads</a></li><li> <a href="#threads-and-rich-text-processing">Threads and Rich Text Processing</a></li><li> <a href="#threads-and-the-svg-module">Threads and the SVG module</a></li><li> <a href="#recommended-reading">Recommended Reading</a></li></ul><a name="the-threading-classes"><h2>The Threading Classes</h2> Qt includes the following thread classes: <ul><li> QThread provides the means to start a new thread.</li><li> QThreadStorage provides per-thread data storage.</li><li> <a href="../../../com/trolltech/qt/core/QThreadPool.html">QThreadPool</a> manages a pool of threads that run <a href="../../../com/trolltech/qt/core/QRunnable.html">QRunnable</a> objects.</li><li> <a href="../../../com/trolltech/qt/core/QRunnable.html">QRunnable</a> is an abstract class representing a runnable object.</li><li> <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> provides a mutual exclusion lock, or mutex.</li><li> QMutexLocker is a convenience class that automatically locks and unlocks a <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>.</li><li> <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a> provides a lock that allows simultaneous read access.</li><li> QReadLocker and QWriteLocker are convenience classes that automatically lock and unlock a <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a>.</li><li> <a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a> provides an integer semaphore (a generalization of a mutex).</li><li> <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> provides a way for threads to go to sleep until woken up by another thread.</li><li> QAtomicInt provides atomic operations on integers.</li><li> QAtomicPointer provides atomic operations on pointers.</li></ul> <b>Note:</b> Qt's threading classes are implemented with native threading APIs; e.g., Win32 and pthreads. Therefore, they can be used with threads of the same native API.<a name="creating-a-thread"><h3>Creating a Thread</h3> To create a thread, subclass QThread and reimplement its run() function. For example: <pre class="snippet">
class MyThread : public QThread
{
    Q_OBJECT

protected:
    void run();
};
<br>
    void run()
    
    {
    ...
    }
    </pre> Then, create an instance of the thread object and call QThread::start(). The code that appears in the run() reimplementation will then be executed in a separate thread. Creating threads is explained in more detail in the QThread documentation. <p>Note that <a href="../../../com/trolltech/qt/core/QCoreApplication.html#exec()">QCoreApplication::exec()</a> must always be called from the main thread (the thread that executes <tt>main()</tt>), not from a QThread. In GUI applications, the main thread is also called the GUI thread because it's the only thread that is allowed to perform GUI-related operations. <p>In addition, you must create the <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> (or <a href="../../../com/trolltech/qt/core/QCoreApplication.html">QCoreApplication</a>) object before you can create a QThread.<a name="synchronizing-threads"><h3>Synchronizing Threads</h3> The <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>, <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a>, <a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a>, and <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> classes provide means to synchronize threads. While the main idea with threads is that they should be as concurrent as possible, there are points where threads must stop and wait for other threads. For example, if two threads try to access the same global variable simultaneously, the results are usually undefined. <p><a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> provides a mutually exclusive lock, or mutex. At most one thread can hold the mutex at any time. If a thread tries to acquire the mutex while the mutex is already locked, the thread will be put to sleep until the thread that currently holds the mutex unlocks it. Mutexes are often used to protect accesses to shared data (i.e., data that can be accessed from multiple threads simultaneously). In the Reentrancy and Thread-Safety section below, we will use it to make a class thread-safe. <p><a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a> is similar to <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>, except that it distinguishes between "read" and "write" access to shared data and allows multiple readers to access the data simultaneously. Using <a href="../../../com/trolltech/qt/core/QReadWriteLock.html">QReadWriteLock</a> instead of <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> when it is possible can make multithreaded programs more concurrent. <p><a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a> is a generalization of <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a> that protects a certain number of identical resources. In contrast, a mutex protects exactly one resource. The <a href="threads-semaphores.html">Semaphores</a> example shows a typical application of semaphores: synchronizing access to a circular buffer between a producer and a consumer. <p><a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> allows a thread to wake up other threads when some condition has been met. One or many threads can block waiting for a <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> to set a condition with <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeOne()">wakeOne()</a> or <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeAll()">wakeAll()</a>. Use <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeOne()">wakeOne()</a> to wake one randomly selected event or <a href="../../../com/trolltech/qt/core/QWaitCondition.html#wakeAll()">wakeAll()</a> to wake them all. The <a href="threads-waitconditions.html">Wait Conditions</a> example shows how to solve the producer-consumer problem using <a href="../../../com/trolltech/qt/core/QWaitCondition.html">QWaitCondition</a> instead of <a href="../../../com/trolltech/qt/core/QSemaphore.html">QSemaphore</a>. <p>Note that Qt's synchronization classes rely on the use of properly aligned pointers. For instance, you cannot use packed classes with MSVC.<a name="qtconcurrent-intro"><a name="qtconcurrent"><h2>QtConcurrent</h2> The QtConcurrent namespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives such as mutexes, read-write locks, wait conditions, or semaphores. Programs written with QtConcurrent automatically adjust the number of threads used according to the number of processor cores available. This means that applications written today will continue to scale when deployed on multi-core systems in the future. <p>QtConcurrent includes functional programming style APIs for parallel list processing, including a MapReduce and FilterReduce implementation for shared-memory (non-distributed) systems, and classes for managing asynchronous computations in GUI applications: <ul><li> QtConcurrent::map() applies a function to every item in a container, modifying the items in-place.</li><li> QtConcurrent::mapped() is like map(), except that it returns a new container with the modifications.</li><li> QtConcurrent::mappedReduced() is like mapped(), except that the modified results are reduced or folded into a single result.</li><li> QtConcurrent::filter() removes all items from a container based on the result of a filter function.</li><li> QtConcurrent::filtered() is like filter(), except that it returns a new container with the filtered results.</li><li> QtConcurrent::filteredReduced() is like filtered(), except that the filtered results are reduced or folded into a single result.</li><li> QtConcurrent::run() runs a function in another thread.</li><li> <a href="../../../com/trolltech/qt/core/QFuture.html">QFuture</a> represents the result of an asynchronous computation.</li><li> <a href="../../../com/trolltech/qt/core/QFutureIterator.html">QFutureIterator</a> allows iterating through results available via <a href="../../../com/trolltech/qt/core/QFuture.html">QFuture</a>.</li><li> <a href="../../../com/trolltech/qt/core/QFutureWatcher.html">QFutureWatcher</a> allows monitoring a <a href="../../../com/trolltech/qt/core/QFuture.html">QFuture</a> using signals-and-slots.</li><li> <a href="../../../com/trolltech/qt/core/QFutureSynchronizer.html">QFutureSynchronizer</a> is a convenience class that automatically synchronizes several QFutures.</li></ul> Qt Concurrent supports several STL-compatible container and iterator types, but works best with Qt containers that have random-access iterators, such as QList or QVector. The map and filter functions accept both containers and begin/end iterators. <p>STL Iterator support overview: <table align="center" border="0" cellpadding="2" cellspacing="1"><thead><tr class="qt-style" valign="top"><th><center> Iterator Type</center></th><th><center> Example classes</center></th><th><center> Support status</center></th></tr></thead><tr valign="top" class="even"><td> Input Iterator</td><td></td><td> Not Supported</td></tr><tr valign="top" class="odd"><td> Output Iterator</td><td></td><td> Not Supported</td></tr><tr valign="top" class="even"><td> Forward Iterator</td><td> std::slist</td><td> Supported</td></tr><tr valign="top" class="odd"><td> Bidirectional Iterator</td><td> QLinkedList, std::list</td><td> Supported</td></tr><tr valign="top" class="even"><td> Random Access Iterator</td><td> QList, QVector, std::vector</td><td> Supported and Recommended</td></tr></table> Random access iterators can be faster in cases where Qt Concurrent is iterating over a large number of lightweight items, since they allow skipping to any point in the container. In addition, using random access iterators allows Qt Concurrent to provide progress information trough <a href="../../../com/trolltech/qt/core/QFuture.html#progressValue()">QFuture::progressValue()</a> and QFutureWatcher:: progressValueChanged(). <p>The non in-place modifying functions such as mapped() and filtered() makes a copy of the container when called. If you are using STL containers this copy operation might take some time, in this case we recommend specifying the begin and end iterators for the container instead.<a name="reentrant"><a name="thread-safe"><a name="reentrancy-and-thread-safety"><h2>Reentrancy and Thread-Safety</h2> Throughout the Qt documentation, the terms reentrant and thread-safe are used to specify how a function can be used in multithreaded applications: <ul><li> A reentrant function can be called simultaneously by multiple threads provided that each invocation of the function references unique data.</li><li> A thread-safe function can be called simultaneously by multiple threads when each invocation references shared data. All access to the shared data is serialized.</li></ul> By extension, a class is said to be reentrant if each and every one of its functions can be called simultaneously by multiple threads on different instances of the class. Similarly, the class is said to be thread-safe if the functions can be called by different threads on the same instance. <p>Classes in the documentation will be documented as thread-safe only if they are intended to be used by multiple threads. <p>Note that the terminology in this domain isn't entirely standardized. POSIX uses a somewhat different definition of reentrancy and thread-safety for its C APIs. When dealing with an object-oriented C++ class library such as Qt, the definitions must be adapted. <p>Most C++ classes are inherently reentrant, since they typically only reference member data. Any thread can call such a member function on an instance of the class, as long as no other thread is calling a member function on the same instance. For example, the <tt>Counter</tt> class below is reentrant: <pre class="snippet">
    class Counter
    
    {
    public:
        Counter() { n = 0; }

        void increment() { ++n; }
        void decrement() { --n; }
        int value() { return n; }

    private:
        int n;
    };
    </pre> The class isn't thread-safe, because if multiple threads try to modify the data member <tt>n</tt>, the result is undefined. This is because C++'s <tt>++</tt> and <tt>--</tt> operators aren't necessarily atomic. Indeed, they usually expand to three machine instructions: <ol><li> Load the variable's value in a register.</li><li> Increment or decrement the register's value.</li><li> Store the register's value back into main memory.</li></ol> If thread A and thread B load the variable's old value simultaneously, increment their register, and store it back, they end up overwriting each other, and the variable is incremented only once! <p>Clearly, the access must be serialized: Thread A must perform steps 1, 2, 3 without interruption (atomically) before thread B can perform the same steps; or vice versa. An easy way to make the class thread-safe is to protect all access to the data members with a <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>: <pre class="snippet">
    class Counter
    
    {
    public:
        Counter() { n = 0; }

        void increment() { QMutexLocker locker(mutex); ++n; }
        void decrement() { QMutexLocker locker(mutex); --n; }
        int value() { QMutexLocker locker(mutex); return n; }

    private:
        mutable QMutex mutex;
        int n;
    };
    </pre> The QMutexLocker class automatically locks the mutex in its constructor and unlocks it when the destructor is invoked, at the end of the function. Locking the mutex ensures that access from different threads will be serialized. The <tt>mutex</tt> data member is declared with the <tt>mutable</tt> qualifier because we need to lock and unlock the mutex in <tt>value()</tt>, which is a const function. <p>Most Qt classes are reentrant and not thread-safe, to avoid the overhead of repeatedly locking and unlocking a <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>. For example, QString is reentrant, meaning that you can use it in different threads, but you can't access the same QString object from different threads simultaneously (unless you protect it with a mutex yourself). A few classes and functions are thread-safe; these are mainly thread-related classes such as <a href="../../../com/trolltech/qt/core/QMutex.html">QMutex</a>, or fundamental functions such as <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::postEvent()</a>.<a name="threads-and-qobjects"><h2>Threads and QObjects</h2> QThread inherits <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>. It emits signals to indicate that the thread started or finished executing, and provides a few slots as well. <p>More interesting is that <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a>s can be used in multiple threads, emit signals that invoke slots in other threads, and post events to objects that "live" in other threads. This is possible because each thread is allowed to have its own event loop.<a name="qobject-reentrancy"><h3>QObject Reentrancy</h3> <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> is reentrant. Most of its non-GUI subclasses, such as <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a>, <a href="../../../com/trolltech/qt/network/QTcpSocket.html">QTcpSocket</a>, <a href="../../../com/trolltech/qt/network/QUdpSocket.html">QUdpSocket</a>, <a href="../../../com/trolltech/qt/network/QHttp.html">QHttp</a>, <a href="../../../com/trolltech/qt/network/QFtp.html">QFtp</a>, and <a href="../../../com/trolltech/qt/core/QProcess.html">QProcess</a>, are also reentrant, making it possible to use these classes from multiple threads simultaneously. Note that these classes are designed to be created and used from within a single thread; creating an object in one thread and calling its functions from another thread is not guaranteed to work. There are three constraints to be aware of: <ul><li> The child of a QObject must always be created in the thread where the parent was created. This implies, among other things, that you should never pass the QThread object (<tt>this</tt>) as the parent of an object created in the thread (since the QThread object itself was created in another thread).</li><li> Event driven objects may only be used in a single thread. Specifically, this applies to the <a href="timers.html">timer mechanism</a> and the <a href="qtnetwork.html">network module</a>. For example, you cannot start a timer or connect a socket in a thread that is not the <a href="../../../com/trolltech/qt/core/QObject.html#thread()">object's thread</a>.</li><li> You must ensure that all objects created in a thread are deleted before you delete the QThread. This can be done easily by creating the objects on the stack in your run() implementation.</li></ul> Although <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> is reentrant, the GUI classes, notably <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> and all its subclasses, are not reentrant. They can only be used from the main thread. As noted earlier, <a href="../../../com/trolltech/qt/core/QCoreApplication.html#exec()">QCoreApplication::exec()</a> must also be called from that thread. <p>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the <a href="qtjambi-mandelbrot.html">Mandelbrot</a> and the <a href="network-blockingfortuneclient.html">Blocking Fortune Client</a> example.<a name="per-thread-event-loop"><h3>Per-Thread Event Loop</h3> Each thread can have its own event loop. The initial thread starts its event loops using <a href="../../../com/trolltech/qt/core/QCoreApplication.html#exec()">QCoreApplication::exec()</a>; other threads can start an event loop using QThread::exec(). Like <a href="../../../com/trolltech/qt/core/QCoreApplication.html">QCoreApplication</a>, QThread provides an exit(int) function and a quit() slot. <p>An event loop in a thread makes it possible for the thread to use certain non-GUI Qt classes that require the presence of an event loop (such as <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a>, <a href="../../../com/trolltech/qt/network/QTcpSocket.html">QTcpSocket</a>, and <a href="../../../com/trolltech/qt/core/QProcess.html">QProcess</a>). It also makes it possible to connect signals from any threads to slots of a specific thread. This is explained in more detail in the <a href="threads.html#signals-and-slots-across-threads">Signals and Slots Across Threads</a> section below. <br><center><img src="images/threadsandobjects.png"></center><br> A <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> instance is said to live in the thread in which it is created. Events to that object are dispatched by that thread's event loop. The thread in which a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> lives is available using <a href="../../../com/trolltech/qt/core/QObject.html#thread()">QObject::thread()</a>. <p>Note that for QObjects that are created before <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a>, <a href="../../../com/trolltech/qt/core/QObject.html#thread()">QObject::thread()</a> returns zero. This means that the main thread will only handle posted events for these objects; other event processing is not done at all for objects with no thread. Use the <a href="../../../com/trolltech/qt/core/QObject.html#moveToThread(java.lang.Thread)">QObject::moveToThread()</a> function to change the thread affinity for an object and its children (the object cannot be moved if it has a parent). <p>Calling <tt>delete</tt> on a <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> from another thread than the thread where it is created (or accessing the object in other ways) is unsafe unless you can guarantee that the object isn't processing events at the same moment. Use QObject::deleteLater() instead; it will post a <a href="../../../com/trolltech/qt/core/QEvent.Type.html">DeferredDelete</a> event, which the event loop of the object's thread will eventually pick up. <p>If no event loop is running, events won't be delivered to the object. For example, if you create a <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a> object in a thread but never call exec(), the <a href="../../../com/trolltech/qt/core/QTimer.html">QTimer</a> will never emit its timeout() signal. Calling deleteLater() won't work either. (These restrictions apply to the main thread as well.) <p>You can manually post events to any object in any thread at any time using the thread-safe function <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::postEvent()</a>. The events will automatically be dispatched by the event loop of the thread where the object was created. <p>Event filters are supported in all threads, with the restriction that the monitoring object must live in the same thread as the monitored object. Similarly, <a href="../../../com/trolltech/qt/core/QCoreApplication.html#sendEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">QCoreApplication::sendEvent()</a> (unlike <a href="../../../com/trolltech/qt/core/QCoreApplication.html#postEvent(com.trolltech.qt.core.QObject, com.trolltech.qt.core.QEvent)">postEvent()</a>) can only be used to dispatch events to objects living in the thread from which the function is called.<a name="accessing-qobject-subclasses-from-other-threads"><h3>Accessing QObject Subclasses from Other Threads</h3> <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> and all of its subclasses are not thread-safe. This includes the entire event delivery system. It is important to keep in mind that the event loop may be delivering events to your <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass while you are accessing the object from another thread. <p>If you are calling a function on an <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass that doesn't live in the current thread and the object might receive events, you must protect all access to your <a href="../../../com/trolltech/qt/core/QObject.html">QObject</a> subclass's internal data with a mutex; otherwise, you may experience crashes or other undesired behavior. <p>Like other objects, QThread objects live in the thread where the object was created -- not in the thread that is created when QThread::run() is called. It is generally unsafe to provide slots in your QThread subclass, unless you protect the member variables with a mutex. <p>On the other hand, you can safely emit signals from your QThread::run() implementation, because signal emission is thread-safe.<a name="signals-and-slots-across-threads"><h3>Signals and Slots Across Threads</h3> Qt supports three types of signal-slot connections: <ul><li> With <a href="../../../com/trolltech/qt/core/Qt.ConnectionType.html">direct connections</a>, the slot gets called immediately when the signal is emitted. The slot is executed in the thread that emitted the signal (which is not necessarily the thread where the receiver object lives).</li><li> With <a href="../../../com/trolltech/qt/core/Qt.ConnectionType.html">queued connections</a>, the slot is invoked when control returns to the event loop of the thread to which the object belongs. The slot is executed in the thread where the receiver object lives.</li><li> With <a href="../../../com/trolltech/qt/core/Qt.ConnectionType.html">auto connections</a> (the default), the behavior is the same as with direct connections if the signal is emitted in the thread where the receiver lives; otherwise, the behavior is that of a queued connection.</li></ul> The connection type can be specified by passing an additional argument to connect(). Be aware that using direct connections when the sender and receiver live in different threads is unsafe if an event loop is running in the receiver's thread, for the same reason that calling any function on an object living in another thread is unsafe. <p>QObject::connect() itself is thread-safe. <p>The <a href="qtjambi-mandelbrot.html">Mandelbrot</a> example uses a queued connection to communicate between a worker thread and the main thread. To avoid freezing the main thread's event loop (and, as a consequence, the application's user interface), all the Mandelbrot fractal computation is done in a separate worker thread. The thread emits a signal when it is done rendering the fractal. <p>Similarly, the <a href="network-blockingfortuneclient.html">Blocking Fortune Client</a> example uses a separate thread for communicating with a TCP server asynchronously.<a name="threads-and-implicit-sharing"><h2>Threads and Implicit Sharing</h2> Qt uses an optimization called <a href="shared.html">implicit sharing</a> for many of its value class, notably <a href="../../../com/trolltech/qt/gui/QImage.html">QImage</a> and QString. Beginning with Qt 4, implicit shared classes can safely be copied across threads, like any other value classes. They are fully <a href="threads.html#reentrant">reentrant</a>. The implicit sharing is really implicit. <p>In many people's minds, implicit sharing and multithreading are incompatible concepts, because of the way the reference counting is typically done. Qt, however, uses atomic reference counting to ensure the integrity of the shared data, avoiding potential corruption of the reference counter. <p>Note that atomic reference counting does not guarantee <a href="threads.html#thread-safe">thread-safety</a>. Proper locking should be used when sharing an instance of an implicitly shared class between threads. This is the same requirement placed on all <a href="threads.html#reentrant">reentrant</a> classes, shared or not. Atomic reference counting does, however, guarantee that a thread working on its own, local instance of an implicitly shared class is safe. We recommend using <a href="threads.html#signals-and-slots-across-threads">signals and slots</a> to pass data between threads, as this can be done without the need for any explicit locking. <p>To sum it up, implicitly shared classes in Qt 4 are really implicitly shared. Even in multithreaded applications, you can safely use them as if they were plain, non-shared, reentrant value-based classes.<a name="threads-and-the-sql-module"><h2>Threads and the SQL Module</h2> A connection can only be used from within the thread that created it. Moving connections between threads or creating queries from a different thread is not supported. <p>In addition, the third party libraries used by the QSqlDrivers can impose further restrictions on using the SQL Module in a multithreaded program. Consult the manual of your database client for more information<a name="painting-in-threads"><h2>Painting in Threads</h2> <a href="../../../com/trolltech/qt/gui/QPainter.html">QPainter</a> can be used to paint onto <a href="../../../com/trolltech/qt/gui/QImage.html">QImage</a>, <a href="../../../com/trolltech/qt/gui/QPrinter.html">QPrinter</a>, and <a href="../../../com/trolltech/qt/gui/QPicture.html">QPicture</a> paint devices. Painting onto QPixmaps and QWidgets is not supported. On Mac OS X the automatic progress dialog will not be displayed if you are printing from outside the GUI thread. <p>Any number of threads can paint at any given time, however only one thread at a time can paint on a given paint device. In other words, two threads can paint at the same time if each paints onto separate QImages, but the two threads cannot paint onto the same <a href="../../../com/trolltech/qt/gui/QImage.html">QImage</a> at the same time. <p>Note that on X11 systems without FontConfig support, Qt cannot render text outside of the GUI thread. You can use the <a href="../../../com/trolltech/qt/gui/QFontDatabase.html#supportsThreadedFontRendering()">QFontDatabase::supportsThreadedFontRendering()</a> function to detect whether or not font rendering can be used outside the GUI thread.<a name="threads-and-rich-text-processing"><h2>Threads and Rich Text Processing</h2> The <a href="../../../com/trolltech/qt/gui/QTextDocument.html">QTextDocument</a>, <a href="../../../com/trolltech/qt/gui/QTextCursor.html">QTextCursor</a>, and <a href="richtext.html">all related classes</a> are reentrant. <p>Note that a <a href="../../../com/trolltech/qt/gui/QTextDocument.html">QTextDocument</a> instance created in the GUI thread may contain <a href="../../../com/trolltech/qt/gui/QPixmap.html">QPixmap</a> image resources. Use <a href="../../../com/trolltech/qt/gui/QTextDocument.html#clone()">QTextDocument::clone()</a> to create a copy of the document, and pass the copy to another thread for further processing (such as printing).<a name="threads-and-the-svg-module"><h2>Threads and the SVG module</h2> The <a href="../../../com/trolltech/qt/svg/QSvgGenerator.html">QSvgGenerator</a> and <a href="../../../com/trolltech/qt/svg/QSvgRenderer.html">QSvgRenderer</a> classes in the <a href="qtsvg.html">QtSvg</a> module are reentrant.<a name="reading"><a name="recommended-reading"><h2>Recommended Reading</h2> <ul><li> <a href="http://www.amazon.com/exec/obidos/ASIN/0134436989/trolltech/t">Threads Primer: A Guide to Multithreaded Programming</a></li><li> <a href="http://www.amazon.com/exec/obidos/ASIN/0131900676/trolltech/t">Thread Time: The Multithreaded Programming Guide</a></li><li> <a href="http://www.amazon.com/exec/obidos/ASIN/1565921151/trolltech/t">Pthreads Programming: A POSIX Standard for Better Multiprocessing</a></li><li> <a href="http://www.amazon.com/exec/obidos/ASIN/1565922964/trolltech/t">Win32 Multithreaded Programming</a></li></ul><p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
