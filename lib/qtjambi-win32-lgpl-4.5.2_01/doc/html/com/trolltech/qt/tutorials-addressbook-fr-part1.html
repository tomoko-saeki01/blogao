<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Carnet d'adresses 1 - Concevoir l'interface utilisateur</title><link href="classic.css" rel="stylesheet" type="text/css" />
</head><table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
 <td align="left" valign="top" width="32"> <img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /> </td>
 <td width="1">&nbsp;&nbsp;</td> <td class="postheader" valign="center"> <a href="qtjambi-index.html"> <font color="#004faf">Home</font></a>&nbsp;&middot; <a href="qtjambi-examples.html"> <font color="#004faf">Examples</font></a>&nbsp; </td>
 </tr></table><body><p><hr><p><center><h1>Carnet d'adresses 1 - Concevoir l'interface utilisateur</h1></center><p>[<a href="tutorials-addressbook-fr.html">Tutoriel "Carnet d'adresses"</a>][Next: <a href="tutorials-addressbook-fr-part2.html">Carnet d'adresses 2 - Ajouter des adresses</a>]<p> La première partie de ce tutoriel traite de la conception d'une interface graphique (GUI) basique, que l'on utilisera pour l'application Carnet d'adresses. <p>La première étape dans la création d'applications graphiques est la conception de l'interface utilisateur. Dans ce chapitre, nous verrons comment créer les labels et champs de saisie nécessaires à l'implementation d'un carnet d'adresses de base. Le résultat attendu est illustré par la capture d'écran ci-dessous. <br><center><img src="images/addressbook-tutorial-part1-screenshot.png"></center><br> Nous allons avoir besoin de deux objets <a href="../../../com/trolltech/qt/gui/QLabel.html">QLabel</a>, <tt>nameLabel</tt> et <tt>addressLabel</tt>, ainsi que deux champs de saisie: un objet <a href="../../../com/trolltech/qt/gui/QLineEdit.html">QLineEdit</a>, <tt>nameLine</tt>, et un objet <a href="../../../com/trolltech/qt/gui/QTextEdit.html">QTextEdit</a>, <tt>addressText</tt>, afin de permettre à l'utilisateur d'entrer le nom d'un contact et son adresse. Les widgets utilisés ainsi que leur placement sont visibles ci-dessous. <br><center><img src="images/addressbook-tutorial-part1-labeled-screenshot.png"></center><br> Trois fichiers sont nécessaires à l'implémentation de ce carnet d'adresses: <ul><li> <tt>addressbook.h</tt> - le fichier de définition (header) pour la classe <tt>AddressBook</tt>,</li><li> <tt>addressbook.cpp</tt> - le fichier source, qui comprend l'implémentation de la classe <tt>AddressBook</tt></li><li> <tt>main.cpp</tt> - le fichier qui contient la méthode <tt>main()</tt> , et une instance de la classe <tt>AddressBook</tt>.</li></ul><a name="programmation-en-qt-h-ritage"><h2>Programmation en Qt - héritage</h2> Lorsque l'on écrit des programmes avec Qt, on a généralement recours à l'héritage depuis des objets Qt, afin d'y ajouter des fonctionnalités. C'est l'un des concepts fondamentaux de la création de widgets personnalisés ou de collections de widgets. Utiliser l'héritage afin de compléter ou modifier le comportement d'un widget présente les avantages suivants: <ul><li> La possibilité d'implémenter des méthodes virtuelles et des méthodes virtuelles pures pour obtenir exactement ce que l'on souhaite, avec la possibilité d'utiliser l'implémentation de la classe mère si besoin est.</li><li> Cela permet l'encapsulation partielle de l'interface utilisateur dans une classe, afin que les autres parties de l'application n'aient pas à se soucier de chacun des widgets qui forment l'interface utilisateur.</li><li> La classe fille peut être utilisée pour créer de nombreux widgets personnalisés dans une même application ou bibliothèque, et le code de la classe fille peut être réutilisé dans d'autres projets</li></ul> Comme Qt ne fournit pas de widget standard pour un carnet d'adresses, nous partirons d'une classe de widget Qt standard et y ajouterons des fonctionnalités. La classe <tt>AddressBook</tt> crée dans ce tutoriel peut être réutilisée si on a besoin d'un widget carnet d'adresses basique.<a name="la-classe-addressbook"><h2>La classe AddressBook</h2> Le fichier <tt>addressbook.h</tt> permet de définir la classe <tt>AddressBook</tt>. <p>On commence par définir <tt>AddressBook</tt> comme une classe fille de <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a> et déclarer un constructeur. On utilise également la macro Q_OBJECT pour indiquer que la classe exploite les fonctionnalités de signaux et slots offertes par Qt ainsi que l'internationalisation, bien que nous ne les utilisions pas à ce stade. <pre class="snippet">
class AddressBook : public QWidget
{
    Q_OBJECT

public:
    AddressBook(QWidget *parent = 0);

private:
    QLineEdit *nameLine;
    QTextEdit *addressText;
};
</pre> La classe contient les déclarations de <tt>nameLine</tt> et <tt>addressText</tt>, les instances privées de <a href="../../../com/trolltech/qt/gui/QLineEdit.html">QLineEdit</a> et <a href="../../../com/trolltech/qt/gui/QTextEdit.html">QTextEdit</a> mentionnées précédemment. Vous verrez, dans les chapitres à venir que les informations contenues dans <tt>nameLine</tt> et <tt>addressText</tt> sont nécessaires à de nombreuses méthodes du carnet d'adresses. <p>Il n'est pas nécessaire de déclarer les objets <a href="../../../com/trolltech/qt/gui/QLabel.html">QLabel</a> que nous allons utiliser puisque nous n'aurons pas besoin d'y faire référence après leur création. La façon dont Qt gère la parenté des objets est traitée dans la section suivante. <p>La macro Q_OBJECT implémente des fonctionnalités parmi les plus avancées de Qt. Pour le moment, il est bon de voir la macro Q_OBJECT comme un raccourci nous permettant d'utiliser les méthodes tr() et connect(). <p>Nous en avons maintenant terminé avec le fichier <tt>addressbook.h</tt> et allons passer à l'implémentation du fichier <tt>addressbook.cpp</tt>.<a name="impl-menter-la-classe-addressbook"><h2>Implémenter la classe AddressBook</h2> Le constructeur de la classe <tt>AddressBook</tt> prend en paramètre un <a href="../../../com/trolltech/qt/gui/QWidget.html">QWidget</a>, <tt>parent</tt>. Par convention, on passe ce paramètre au constructeur de la classe mère. Ce concept de parenté, où un parent peut avoir un ou plusieurs enfants, est utile pour regrouper les Widgets avec Qt. Par exemple, si vous détruisez le parent, tous ses enfants seront détruits égalament.<br><br>The following code example is written in c++.<br> <pre class="snippet">
AddressBook::AddressBook(QWidget *parent)
    : QWidget(parent)
{
    QLabel *nameLabel = new QLabel(tr("Name:"));
    nameLine = new QLineEdit;

    QLabel *addressLabel = new QLabel(tr("Address:"));
    addressText = new QTextEdit;
</pre> À l'intérieur de ce constructeur, on déclare et instancie deux objets locaux <a href="../../../com/trolltech/qt/gui/QLabel.html">QLabel</a>, <tt>nameLabel</tt> et <tt>addressLabel</tt>, de même on instancie <tt>nameLine</tt> et <tt>addressText</tt>. La méthode tr() renvoie une version traduite de la chaîne de caractères, si elle existe; dans le cas contraire, elle renvoie la chaîne elle même. On peut voir cette méthode comme un marqueur <tt>&lt;insérer la traduction ici&gt;</tt>, permettant de repérer les objets QString à considérer pour traduire une application. Vous remarquerez, dans les chapitres à venir comme dans les <a href="examples.html">exemples Qt</a>, qu'elle est utilisée chaque fois que l'on utilise une chaîne susceptible d'être traduite. <p>Lorsque l'on programme avec Qt, il est utile de savoir comment fonctionnent les agencements ou layouts. Qt fournit trois classes principales de layouts pour contrôler le placement des widgets: <a href="../../../com/trolltech/qt/gui/QHBoxLayout.html">QHBoxLayout</a>, <a href="../../../com/trolltech/qt/gui/QVBoxLayout.html">QVBoxLayout</a> et <a href="../../../com/trolltech/qt/gui/QGridLayout.html">QGridLayout</a>. <br><center><img src="images/addressbook-tutorial-part1-labeled-layout.png"></center><br> On utilise un <a href="../../../com/trolltech/qt/gui/QGridLayout.html">QGridLayout</a> pour positionner nos labels et champs de saisie de manière structurée. <a href="../../../com/trolltech/qt/gui/QGridLayout.html">QGridLayout</a> divise l'espace disponible en une grille, et place les widgets dans les cellules que l'on spécifie par les numéros de ligne et de colonne. Le diagramme ci-dessus présente les cellules et la position des widgets, et cette organisation est obtenue à l'aide du code suivant:<br><br>The following code example is written in c++.<br> <pre class="snippet">
    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&gt;addWidget(nameLabel, 0, 0);
    mainLayout-&gt;addWidget(nameLine, 0, 1);
    mainLayout-&gt;addWidget(addressLabel, 1, 0, Qt::AlignTop);
    mainLayout-&gt;addWidget(addressText, 1, 1);
</pre> On remarque que le label <tt>AddressLabel</tt> est positionné en utilisant <a href="../../../com/trolltech/qt/core/Qt.AlignmentFlag.html">Qt::AlignTop</a> comme argument optionnel. Ceci est destiné à assurer qu'il ne sera pas centré verticalement dans la cellule (1,0). Pour un aperçu rapide des layouts de Qt, consultez la section <a href="qtjambi-layout.html">Layout Classes</a>. <p>Afin d'installer l'objet layout dans un widget, il faut appeler la méthode <a href="../../../com/trolltech/qt/gui/QWidget.html#setLayout(com.trolltech.qt.gui.QLayout)">setLayout()</a> du widget en question:<br><br>The following code example is written in c++.<br> <pre class="snippet">    
    setLayout(mainLayout);
    setWindowTitle(tr("Simple Address Book"));
}
</pre> Enfin, on initialise le titre du widget à "Simple Address Book"<a name="lancer-l-application"><h2>Lancer l'application</h2> Un fichier séparé, <tt>main.cpp</tt>, est utilisé pour la méthode <tt>main()</tt>. Dans cette fonction, on crée une instance de <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a>, <tt>app</tt>. <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> se charge de des ressources communes à l'ensemble de l'application, tel que les polices de caractères et le curseur par défaut, ainsi que de l'exécution de la boucle d'évènements. De ce fait, il y a toujours un objet <a href="../../../com/trolltech/qt/gui/QApplication.html">QApplication</a> dans toute application graphique en Qt.<br><br>The following code example is written in c++.<br> <pre class="snippet">
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    AddressBook *addressBook = new AddressBook;
    addressBook-&gt;show();

    return app.exec();
}
</pre> On construit un nouveau widget <tt>AddressBook</tt> sur le tas en utilisant le mot-clé <tt>new</tt> et en invoquant sa méthode <a href="../../../com/trolltech/qt/gui/QWidget.html#show()">show()</a> pour l'afficher. Cependant, le widget ne sera pas visible tant que la boucle d'évènements n'aura pas été lancée. On démarre la boucle d'évènements en appelant la méthode <a href="../../../com/trolltech/qt/gui/QApplication.html#exec()">exec()</a> de l'application; le résultat renvoyé par cette méthode est lui même utilisé comme valeur de retour pour la méthode <tt>main()</tt>.<p /><address><hr /><div align="center">
 <table width="100%" cellspacing="0" border="0"><tr class="address">
 <td width="30%">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
 <td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
 <td width="30%" align="right"><div align="right">Qt Jambi 4.5.2_01</div></td>
 </tr></table></div></address></body></html>
